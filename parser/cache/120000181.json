{
  "id": "120000181",
  "premium": false,
  "billing_type": {
    "id": "standard",
    "name": "Стандарт"
  },
  "relations": [],
  "name": "Специалист по складскому учету (складской аналитик)",
  "insider_interview": null,
  "response_letter_required": false,
  "area": {
    "id": "4",
    "name": "Новосибирск",
    "url": "https://api.hh.ru/areas/4"
  },
  "salary": null,
  "salary_range": null,
  "type": {
    "id": "open",
    "name": "Открытая"
  },
  "address": {
    "city": "Новосибирск",
    "street": "Советское шоссе",
    "building": "1",
    "lat": 54.930714,
    "lng": 82.93765,
    "description": null,
    "raw": "Новосибирск, Советское шоссе, 1",
    "metro": null,
    "metro_stations": []
  },
  "allow_messages": true,
  "experience": {
    "id": "between1And3",
    "name": "От 1 года до 3 лет"
  },
  "schedule": {
    "id": "fullDay",
    "name": "Полный день"
  },
  "employment": {
    "id": "full",
    "name": "Полная занятость"
  },
  "department": null,
  "show_contacts": false,
  "contacts": null,
  "description": "<strong>Обязанности:</strong> <ul> <li>Работа по претензиям от клиентов и DC-DC;</li> <li>Снижение потерь готовой продукции, тары и материалов при хранении, обходы склада, выявление критичных мест образования боя;</li> <li>Анализ отклонений по FEFO и улучшение показателя;</li> <li>Своевременный анализ отклонений при инвентаризациях;</li> <li>Контроль уходимости продукции с короткими сроками;</li> <li>Контроль постановки продукции в систему SAP и соответствие физического наличия продукции с системой;</li> <li>Контроль размещения товарно-материальных ценностей с учетом наиболее рационального использования складских площадей, идентификации и быстрого поиска хранимых товарно-материальных ценностей;</li> <li>Участие в ежемесячных инвентаризациях;</li> <li>Проведение в системе SAP и EWM ежемесячных инвентаризаций;</li> <li>Настройка правил размещения, планирования и отбора продукции в EWM;</li> <li>Настройка групп товаров в EWM, включая АВС анализ;</li> <li>Обучение сотрудников по программе EWM;</li> <li>Выявление и анализ корневых ошибок по EWM;</li> <li>Настройка топологии склада (добавление новых зон, ячеек);</li> <li>Проведение циклических пересчетов склада на сходимость в EWM и SAP;</li> <li>Консолидация и ведение VPO отчетности;</li> <li>Контроль над выявлением корневых причин отклонений в показателях;</li> <li>Консолидация еженедельных и ежемесячных презентаций.</li> </ul> <strong>Требования:</strong> <ul> <li>Высшее образование;</li> <li>Желателен опыт работы в логистике;</li> <li>Аналитические навыки;</li> <li>Лидерские качества, целеустремленность, стрессоустойчивость;</li> <li>Умение работать в команде и организовывать процесс;</li> <li>Уверенное владение MS Office, важно знание MS Excel (ВПР, сводные таблицы);</li> <li>Желательно знание SAP;</li> <li>Желательно, но не обязательно знание английского языка.</li> </ul>",
  "branded_description": "\n<style>\n@charset \"UTF-8\";\n/**\n * Swiper 11.1.0\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2024 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: March 28, 2024\n */\n@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA');font-weight:400;font-style:normal}\n:root{--swiper-theme-color:#007aff}\n:host{position:relative;display:block;margin-left:auto;margin-right:auto;z-index:1}\n.swiper{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1;display:block}\n.swiper-vertical>.swiper-wrapper{flex-direction:column}\n.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);box-sizing:content-box}\n.swiper-android .swiper-slide,.swiper-ios .swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}\n.swiper-horizontal{touch-action:pan-y}\n.swiper-vertical{touch-action:pan-x}\n.swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}\n.swiper-slide-invisible-blank{visibility:hidden}\n.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}\n.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}\n.swiper-backface-hidden .swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}\n.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}\n.swiper-3d .swiper-wrapper{transform-style:preserve-3d}\n.swiper-3d{perspective:1200px}\n.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide{transform-style:preserve-3d}\n.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}\n.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}\n.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}\n.swiper-css-mode.swiper-horizontal>.swiper-wrapper{scroll-snap-type:x mandatory}\n.swiper-css-mode.swiper-vertical>.swiper-wrapper{scroll-snap-type:y mandatory}\n.swiper-css-mode.swiper-free-mode>.swiper-wrapper{scroll-snap-type:none}\n.swiper-css-mode.swiper-free-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:none}\n.swiper-css-mode.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}\n.swiper-css-mode.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center;scroll-snap-stop:always}\n.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{margin-inline-start:var(--swiper-centered-offset-before)}\n.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}\n.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{margin-block-start:var(--swiper-centered-offset-before)}\n.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}\n.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}\n.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}\n.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}\n.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}\n.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}\n.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}\n.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}\n.swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader,.swiper:not(.swiper-watch-progress) .swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear}\n.swiper-lazy-preloader-white{--swiper-preloader-color:#fff}\n.swiper-lazy-preloader-black{--swiper-preloader-color:#000}\n@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}\n.tmpl-hh-wrapper {\n  box-shadow: 1px 1px 15px #000;\n  border-radius: 4px;\n  box-sizing: border-box;\n}\n.hht-vacancydescription {\n  padding: 0 !important;\n}\n.vacancy-branded-user-content ul,\n.vacancy-branded-user-content ol {\n  margin-left: 0;\n}\n.vacancy-branded-user-content p:first-child {\n  margin-top: 0 !important;\n}\n.vacancy-branded-user-content p:first-child b,\n.vacancy-branded-user-content p:first-child strong {\n  margin-top: 0 !important;\n}\n.tmpl-hh-wrapper {\n  width: 100%;\n  margin: 0 auto;\n  max-width: 690px;\n  position: relative;\n  overflow: hidden;\n  font-family: \"Arial\", sans-serif;\n  font-style: normal;\n  font-weight: 400;\n  font-size: 16px;\n  line-height: 1.2;\n  color: #000;\n}\n@media (max-width: 699px) {\n  .tmpl-hh-wrapper {\n    font-size: 14px;\n  }\n}\n.tmpl-hh-wrapper * {\n  box-sizing: border-box;\n  padding: 0;\n  margin: 0;\n}\n.tmpl-hh-wrapper sup {\n  vertical-align: top;\n}\n.tmpl-hh-content ol li:not(:first-child),\n.tmpl-hh-content ul li:not(:first-child) {\n  margin-top: 8px;\n}\n@media (max-width: 699px) {\n  .tmpl-hh-content ol li:not(:first-child),\n  .tmpl-hh-content ul li:not(:first-child) {\n    margin-top: 8px;\n  }\n}\n.tmpl-hh-content ol li p,\n.tmpl-hh-content ul li p {\n  margin: 0 !important;\n}\n.tmpl-hh-content ol li p b,\n.tmpl-hh-content ol li p strong,\n.tmpl-hh-content ul li p b,\n.tmpl-hh-content ul li p strong {\n  font-weight: 700;\n  font-size: inherit !important;\n  margin: 0 !important;\n  text-transform: none;\n  color: inherit !important;\n  display: initial;\n}\n.tmpl-hh-content ol li em,\n.tmpl-hh-content ul li em {\n  font-style: normal !important;\n}\n.tmpl-hh-content ol li em b,\n.tmpl-hh-content ol li em strong,\n.tmpl-hh-content ul li em b,\n.tmpl-hh-content ul li em strong {\n  text-transform: none;\n  display: inherit;\n  font-weight: 700;\n  font-size: inherit;\n  color: inherit;\n  font-style: normal !important;\n}\n.tmpl-hh-content ol li b,\n.tmpl-hh-content ol li strong,\n.tmpl-hh-content ul li b,\n.tmpl-hh-content ul li strong {\n  font-weight: 700;\n  font-size: inherit !important;\n  margin: 0 !important;\n  text-transform: none;\n  color: inherit !important;\n}\n.tmpl-hh-content p {\n  margin-top: 8px;\n}\n.tmpl-hh-content p:first-child {\n  padding-top: 0 !important;\n  margin-top: 0 !important;\n}\n.tmpl-hh-content p:first-child b, .tmpl-hh-content p:first-child strong {\n  padding-top: 0 !important;\n  margin-top: 0 !important;\n}\n.tmpl-hh-content p:last-child {\n  padding-bottom: 0 !important;\n  margin-bottom: 0 !important;\n}\n.tmpl-hh-content p:last-child b,\n.tmpl-hh-content p:last-child strong {\n  padding-bottom: 0 !important;\n  margin-bottom: 0 !important;\n}\n@media (max-width: 699px) {\n  .tmpl-hh-content p {\n    margin-top: 8px;\n  }\n}\n.tmpl-hh-content p b,\n.tmpl-hh-content p strong {\n  display: inline-block;\n  width: 100%;\n  font-weight: 400;\n  font-size: 20px;\n  line-height: 1.2;\n  color: #000;\n  padding-top: 35px;\n  padding-bottom: 16px;\n}\n@media (max-width: 699px) {\n  .tmpl-hh-content p b,\n  .tmpl-hh-content p strong {\n    font-size: 16px;\n    padding-top: 35px;\n    padding-bottom: 16px;\n  }\n}\n.tmpl-hh-content p em {\n  font-style: normal !important;\n}\n.tmpl-hh-content p em b,\n.tmpl-hh-content p em strong {\n  text-transform: none;\n  display: inherit;\n  font-weight: 700;\n  font-size: inherit;\n  color: inherit !important;\n  font-style: normal !important;\n  background: transparent;\n  padding: 0;\n}\n.tmpl-hh-content .l-paddings {\n  padding: 0;\n}\n@media (max-width: 1019px) {\n  .tmpl-hh-wrapper {\n    max-width: 610px;\n  }\n}\n.slider-button {\n  display: flex;\n  width: 30px;\n  height: 30px;\n  border: none;\n  border-radius: 50%;\n  align-items: center;\n  justify-content: center;\n  background-color: #012169;\n  cursor: pointer;\n}\n.slider-button svg {\n  width: 5px;\n  height: 11px;\n}\n.slider-button svg path {\n  stroke: #fff;\n}\n@media (max-width: 699px) {\n  .slider-button {\n    width: 26px;\n    height: 26px;\n  }\n}\n.tmpl-hh-header {\n  position: relative;\n  padding: 35px 40px 0;\n  margin-bottom: 8px;\n}\n.tmpl-hh-header__background {\n  position: absolute;\n  top: 0;\n  right: 0;\n  left: 0;\n  height: 90%;\n  border-bottom-left-radius: 16px;\n  border-bottom-right-radius: 16px;\n  background-color: #012169;\n  opacity: 0.1;\n}\n.tmpl-hh-header__logo {\n  position: relative;\n  z-index: 1;\n  display: flex;\n  margin-bottom: 31px;\n  justify-content: flex-end;\n}\n.tmpl-hh-header__heading {\n  position: relative;\n  z-index: 1;\n  max-width: 448px;\n  margin-bottom: 20px;\n  font-size: 54px;\n  font-weight: 700;\n  text-transform: uppercase;\n  line-height: 1.03;\n  color: #012169;\n}\n.tmpl-hh-header__label {\n  position: absolute;\n  top: 159px;\n  left: 387px;\n  max-width: 220px;\n  padding: 4px 20px;\n  border-radius: 40px;\n  font-size: 16px;\n  line-height: normal;\n  background-color: #012169;\n  color: #fff;\n}\n.tmpl-hh-header__slider {\n  overflow: hidden;\n  width: 100%;\n  height: fit-content;\n  border-radius: 8px;\n}\n.tmpl-hh-header__slider-slide {\n  width: 100%;\n}\n.tmpl-hh-header__slider-slide img {\n  width: 100%;\n  height: 100%;\n}\n.tmpl-hh-header__slider-nav-button {\n  position: absolute;\n  top: 50%;\n  z-index: 10;\n}\n.tmpl-hh-header__slider-nav-button_prev {\n  left: 20px;\n  transform: translateY(-50%) rotate(180deg);\n}\n.tmpl-hh-header__slider-nav-button_next {\n  right: 20px;\n  transform: translateY(-50%);\n}\n.tmpl-hh-header__slider-pagination {\n  position: absolute;\n  bottom: 20px;\n  left: 50%;\n  z-index: 10;\n  display: flex;\n  align-items: center;\n  column-gap: 6px;\n  transform: translateX(-50%);\n}\n.tmpl-hh-header__slider-bullet {\n  display: block;\n  width: 2px;\n  height: 2px;\n  border-radius: 10px;\n  background-color: #fff;\n  transition: width 0.3s ease-in-out;\n}\n.tmpl-hh-header__slider-bullet_active {\n  width: 20px;\n}\n@media (max-width: 1019px) {\n  .tmpl-hh-header__heading {\n    font-size: 42px;\n  }\n  .tmpl-hh-header__label {\n    top: 142px;\n    left: 306px;\n    max-width: 173px;\n    font-size: 12px;\n  }\n}\n@media (max-width: 699px) {\n  .tmpl-hh-header {\n    padding: 26px 16px 0;\n    margin-bottom: 8px;\n  }\n  .tmpl-hh-header__logo {\n    margin-bottom: 30px;\n    justify-content: center;\n  }\n  .tmpl-hh-header__logo img {\n    width: auto;\n    height: 24px;\n  }\n  .tmpl-hh-header__heading {\n    width: 100%;\n    margin-bottom: 60px;\n    font-size: 30px;\n  }\n  .tmpl-hh-header__label {\n    top: 150px;\n    right: 16px;\n    left: unset;\n    max-width: 166px;\n    padding: 4px 16px;\n    font-size: 12px;\n  }\n  .tmpl-hh-header__slider-navigation {\n    padding: 0 8px;\n  }\n  .tmpl-hh-header__slider-pagination {\n    bottom: 10px;\n  }\n}\n.tmpl-hh-about {\n  position: relative;\n  padding: 0 40px;\n}\n.tmpl-hh-about__content {\n  padding: 20px;\n  border-radius: 8px;\n  background-color: #012169;\n  color: #fff;\n}\n.tmpl-hh-about__content p {\n  max-width: 525px;\n  font-size: 20px;\n  line-height: 1.2;\n}\n.tmpl-hh-about__stamp {\n  position: absolute;\n  right: 0;\n  bottom: -67px;\n  z-index: 10;\n  width: 130px;\n  height: 130px;\n}\n.tmpl-hh-about__stamp img {\n  width: 100%;\n  height: auto;\n}\n@media (max-width: 699px) {\n  .tmpl-hh-about {\n    padding: 0 16px;\n  }\n  .tmpl-hh-about__content {\n    padding: 20px 16px;\n  }\n  .tmpl-hh-about__content p {\n    max-width: 226px;\n    font-size: 16px;\n  }\n  .tmpl-hh-about__stamp {\n    right: -18px;\n    bottom: -67px;\n    width: 101px;\n    height: 101px;\n  }\n}\n.tmpl-hh-content {\n  position: relative;\n  padding-top: 50px;\n  padding-right: 40px;\n  padding-bottom: 50px;\n  padding-left: 40px;\n}\n.tmpl-hh-content ul {\n  list-style: none;\n}\n.tmpl-hh-content ul li {\n  position: relative;\n  padding-left: 24px;\n}\n.tmpl-hh-content ul li::before {\n  position: absolute;\n  top: 7px;\n  left: 10px;\n  display: block;\n  width: 4px;\n  height: 4px;\n  border-radius: 50%;\n  background-color: #000;\n  content: \"\";\n}\n.tmpl-hh-content__stamp {\n  position: absolute;\n}\n.tmpl-hh-content__stamp_joy {\n  bottom: 163px;\n  left: -46px;\n  width: 105px;\n  height: 105px;\n  transform: rotate(-1.047deg);\n}\n.tmpl-hh-content__stamp_dream {\n  right: 13px;\n  bottom: 32px;\n  width: 125px;\n  height: 125px;\n  transform: rotate(-114.997deg);\n}\n.tmpl-hh-content__stamp_moments {\n  right: 84px;\n  bottom: -6px;\n  width: 87px;\n  height: 87px;\n  transform: rotate(119.498deg);\n}\n@media (max-width: 1019px) {\n  .tmpl-hh-content__stamp_joy {\n    left: -65px;\n  }\n  .tmpl-hh-content__stamp_dream {\n    right: -65px;\n  }\n  .tmpl-hh-content__stamp_moments {\n    right: 0;\n  }\n}\n@media (max-width: 699px) {\n  .tmpl-hh-content {\n    padding-top: 50px;\n    padding-right: 16px;\n    padding-bottom: 50px;\n    padding-left: 16px;\n  }\n  .tmpl-hh-content ul li {\n    padding-left: 21px;\n  }\n  .tmpl-hh-content ul li::before {\n    top: 7px;\n    left: 8px;\n    width: 3px;\n    height: 3px;\n  }\n  .tmpl-hh-content__stamp_joy {\n    bottom: 337px;\n    left: -65px;\n    width: 94px;\n    height: 94px;\n  }\n  .tmpl-hh-content__stamp_dream {\n    right: -30px;\n    bottom: 18px;\n    width: 75px;\n    height: 75px;\n  }\n  .tmpl-hh-content__stamp_moments {\n    right: 13px;\n    bottom: -5px;\n    width: 52px;\n    height: 52px;\n  }\n}\n.tmpl-hh-propose {\n  padding: 0 40px 40px;\n}\n.tmpl-hh-propose__title {\n  margin-bottom: 30px;\n  font-size: 20px;\n  font-weight: 700;\n  text-transform: uppercase;\n  line-height: 1.03;\n}\n.tmpl-hh-propose__wrapper {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 8px;\n}\n.tmpl-hh-propose__item {\n  position: relative;\n  width: calc((100% - 8px) / 3 * 1.5);\n  height: 129px;\n  padding: 16px 20px;\n  border-radius: 8px;\n  background-color: #012169;\n}\n.tmpl-hh-propose__item_small {\n  width: calc((100% - 8px) / 3 * 1);\n}\n.tmpl-hh-propose__item_big {\n  width: calc((100% - 8px) / 3 * 2);\n}\n.tmpl-hh-propose__item_increased-height {\n  height: 156px;\n}\n.tmpl-hh-propose__item-text {\n  width: 100%;\n  font-size: 16px;\n  line-height: 1.2;\n  color: #fff;\n}\n.tmpl-hh-propose__item-icon {\n  position: absolute;\n  right: 20px;\n  bottom: 16px;\n  width: 40px;\n  height: 40px;\n}\n.tmpl-hh-propose__item-icon svg {\n  width: 100%;\n  height: 100%;\n  fill: #fff;\n}\n@media (max-width: 699px) {\n  .tmpl-hh-propose {\n    padding: 0 16px 30px;\n  }\n  .tmpl-hh-propose__title {\n    margin-bottom: 23px;\n    font-size: 16px;\n  }\n  .tmpl-hh-propose__item {\n    display: flex;\n    width: 100%;\n    height: unset;\n    padding: 16px;\n    flex-direction: column;\n    align-items: flex-end;\n    row-gap: 8px;\n  }\n  .tmpl-hh-propose__item-text {\n    font-size: 14px;\n  }\n  .tmpl-hh-propose__item-icon {\n    position: static;\n    width: 30px;\n    height: 30px;\n  }\n}\n.tmpl-hh-banner {\n  padding: 0 40px;\n}\n.tmpl-hh-banner__wrapper {\n  position: relative;\n  padding: 60px 30px 291px;\n  border-radius: 8px;\n  background-color: #ba0c2f;\n}\n.tmpl-hh-banner__decor {\n  position: absolute;\n}\n.tmpl-hh-banner__decor img {\n  width: 100%;\n}\n.tmpl-hh-banner__decor_small {\n  top: 0;\n  left: 0;\n  width: 313px;\n}\n.tmpl-hh-banner__decor_big {\n  right: 5px;\n  bottom: 0;\n  width: 451px;\n}\n.tmpl-hh-banner__text-content {\n  position: relative;\n  z-index: 1;\n  max-width: 414px;\n  line-height: 1.03;\n  color: #fff;\n}\n.tmpl-hh-banner__title {\n  font-size: 44px;\n  font-weight: 700;\n  text-transform: uppercase;\n}\n.tmpl-hh-banner__text {\n  padding-left: 44px;\n  font-size: 20px;\n}\n@media (max-width: 1019px) {\n  .tmpl-hh-banner__decor_small {\n    width: 290px;\n  }\n  .tmpl-hh-banner__decor_big {\n    width: 430px;\n  }\n}\n@media (max-width: 699px) {\n  .tmpl-hh-banner {\n    padding: 0 16px;\n  }\n  .tmpl-hh-banner__wrapper {\n    padding: 35px 0 226px 16px;\n  }\n  .tmpl-hh-banner__decor_small {\n    width: 216px;\n  }\n  .tmpl-hh-banner__decor_big {\n    right: 0;\n    bottom: 14px;\n    width: 254px;\n  }\n  º .tmpl-hh-banner__text-content {\n    max-width: 231px;\n  }\n  .tmpl-hh-banner__title {\n    font-size: 32px;\n  }\n  .tmpl-hh-banner__text {\n    padding-left: 35px;\n    font-size: 16px;\n  }\n}\n.tmpl-hh-video {\n  position: relative;\n  width: 100%;\n  height: 424px;\n  padding: 40px;\n}\n.tmpl-hh-video__video {\n  overflow: hidden;\n  width: 100%;\n  height: 100%;\n  border-radius: 8px;\n}\n.tmpl-hh-video__video_hidden {\n  height: 0;\n}\n.tmpl-hh-video__cover {\n  overflow: hidden;\n  height: 100%;\n  border-radius: 8px;\n  background: url(\"https://hhcdn.ru/ichameleon/350250.jpg\"), lightgray 50%/cover no-repeat;\n  background-position: center;\n  background-size: cover;\n  cursor: pointer;\n}\n.tmpl-hh-video__cover_hidden {\n  display: none;\n}\n.tmpl-hh-video__play-button {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 40px;\n  height: 40px;\n  border: none;\n  border-radius: 50%;\n  background-color: #fff;\n  cursor: pointer;\n  transform: translate(-50%, -50%);\n}\n.tmpl-hh-video__play-button::after {\n  position: absolute;\n  top: 50%;\n  left: 56%;\n  display: block;\n  width: 0;\n  height: 0;\n  border: 0 solid transparent;\n  border-top-width: 9px;\n  border-bottom-width: 9px;\n  border-left: 15px solid #012169;\n  content: \"\";\n  transform: translate(-50%, -50%);\n}\n.tmpl-hh-video__play-button_hidden {\n  display: none;\n}\n@media (max-width: 1019px) {\n  .tmpl-hh-video {\n    height: 379px;\n  }\n}\n@media (max-width: 699px) {\n  .tmpl-hh-video {\n    height: 244px;\n    padding: 30px 16px;\n  }\n}\n@media (max-width: 350px) {\n  .tmpl-hh-video {\n    height: 213px;\n  }\n}\n.tmpl-hh-footer {\n  position: relative;\n  padding: 16px 42px 10px;\n}\n.tmpl-hh-footer__paragraph {\n  font-size: 10px;\n  line-height: 1.2;\n  color: #555;\n}\n.tmpl-hh-footer::before, .tmpl-hh-footer::after {\n  position: absolute;\n  top: 0;\n  display: block;\n  width: 100%;\n  height: 10px;\n  content: \"\";\n  transform: skewX(-25deg);\n}\n.tmpl-hh-footer::before {\n  right: 35%;\n  background-color: #c32032;\n}\n.tmpl-hh-footer::after {\n  left: 66%;\n  background-color: #012169;\n}\n@media (max-width: 699px) {\n  .tmpl-hh-footer {\n    padding: 20px 16px 6px;\n  }\n  .tmpl-hh-footer::after {\n    left: 66.5%;\n    background-color: #012169;\n  }\n}\n</style>\n\n<div class=\"tmpl-hh-wrapper\">\n  <div class=\"tmpl-hh-header\">\n    <div class=\"tmpl-hh-header__background\"></div>\n    <div class=\"tmpl-hh-header__logo\">\n      <img alt=\"logo\" src=\"https://hhcdn.ru/ichameleon/350245.svg\">\n    </div>\n    <h2 class=\"tmpl-hh-header__heading\">Мы друг другу подходим!</h2>\n    <p class=\"tmpl-hh-header__label\">\n      Выбирай свою работу в AB InBev Efes\n    </p>\n    <div class=\"tmpl-hh-header__slider swiper\">\n      <div class=\"tmpl-hh-header__slider-wrapper swiper-wrapper\">\n          <div class=\"tmpl-hh-header__slider-slide swiper-slide\">\n            <img alt=\"slider image\" src=\"https://hhcdn.ru/ichameleon/350251.jpg\">\n          </div>\n          <div class=\"tmpl-hh-header__slider-slide swiper-slide\">\n            <img alt=\"slider image\" src=\"https://hhcdn.ru/ichameleon/400602.jpg\">\n          </div>\n          <div class=\"tmpl-hh-header__slider-slide swiper-slide\">\n            <img alt=\"slider image\" src=\"https://hhcdn.ru/ichameleon/350255.jpg\">\n          </div>\n          <div class=\"tmpl-hh-header__slider-slide swiper-slide\">\n            <img alt=\"slider image\" src=\"https://hhcdn.ru/ichameleon/400605.jpg\">\n          </div>\n          <div class=\"tmpl-hh-header__slider-slide swiper-slide\">\n            <img alt=\"slider image\" src=\"https://hhcdn.ru/ichameleon/350254.jpg\">\n          </div>\n          <div class=\"tmpl-hh-header__slider-slide swiper-slide\">\n            <img alt=\"slider image\" src=\"https://hhcdn.ru/ichameleon/400606.jpg\">\n          </div>\n          <div class=\"tmpl-hh-header__slider-slide swiper-slide\">\n            <img alt=\"slider image\" src=\"https://hhcdn.ru/ichameleon/350249.jpg\">\n          </div>\n          <div class=\"tmpl-hh-header__slider-slide swiper-slide\">\n            <img alt=\"slider image\" src=\"https://hhcdn.ru/ichameleon/350248.jpg\">\n          </div>\n          <div class=\"tmpl-hh-header__slider-slide swiper-slide\">\n            <img alt=\"slider image\" src=\"https://hhcdn.ru/ichameleon/350256.jpg\">\n          </div>\n          <div class=\"tmpl-hh-header__slider-slide swiper-slide\">\n            <img alt=\"slider image\" src=\"https://hhcdn.ru/ichameleon/400607.jpg\">\n          </div>\n      </div>\n  \n      <button class=\"slider-button slider-button_rotate slider-button_prev tmpl-hh-header__slider-nav-button tmpl-hh-header__slider-nav-button_prev\">\n        <svg width=\"7\" height=\"13\" viewBox=\"0 0 7 13\" fill=\"none\">\n          <path d=\"M1 0.85498L5.89492 6.06167C6.03503 6.2107 6.03503 6.49926 5.89492 6.64829L1 11.855\" stroke-linecap=\"round\"></path>\n        </svg>\n      </button>\n      <button class=\"slider-button slider-button_next tmpl-hh-header__slider-nav-button tmpl-hh-header__slider-nav-button_next\">\n        <svg width=\"7\" height=\"13\" viewBox=\"0 0 7 13\" fill=\"none\">\n          <path d=\"M1 0.85498L5.89492 6.06167C6.03503 6.2107 6.03503 6.49926 5.89492 6.64829L1 11.855\" stroke-linecap=\"round\"></path>\n        </svg>\n      </button>\n  \n      <div class=\"tmpl-hh-header__slider-pagination\"></div>\n    </div>\n  </div>\n  <div class=\"tmpl-hh-about\">\n    <div class=\"tmpl-hh-about__content\">\n      <p>\n        Компания AB InBev Efes является лидером пивоваренного рынка в России* и работодателем № 1 среди крупнейших FMCG-компаний по версии HH.ru**\n      </p>\n    </div>\n    <div class=\"tmpl-hh-about__stamp\">\n      <img src=\"https://hhcdn.ru/ichameleon/343521.png\" alt=\"decor stamp\">\n    </div>\n  </div>\n  <div class=\"tmpl-hh-content\">\n    <img alt=\"decor stamp\" class=\"tmpl-hh-content__stamp tmpl-hh-content__stamp_joy\" src=\"https://hhcdn.ru/ichameleon/343522.png\">\n    <img alt=\"decor stamp\" class=\"tmpl-hh-content__stamp tmpl-hh-content__stamp_moments\" src=\"https://hhcdn.ru/ichameleon/343524.png\">\n    <img alt=\"decor stamp\" class=\"tmpl-hh-content__stamp tmpl-hh-content__stamp_dream\" src=\"https://hhcdn.ru/ichameleon/343523.png\">\n  \n    <strong>Обязанности:</strong> <ul> <li>Работа по претензиям от клиентов и DC-DC;</li> <li>Снижение потерь готовой продукции, тары и материалов при хранении, обходы склада, выявление критичных мест образования боя;</li> <li>Анализ отклонений по FEFO и улучшение показателя;</li> <li>Своевременный анализ отклонений при инвентаризациях;</li> <li>Контроль уходимости продукции с короткими сроками;</li> <li>Контроль постановки продукции в систему SAP и соответствие физического наличия продукции с системой;</li> <li>Контроль размещения товарно-материальных ценностей с учетом наиболее рационального использования складских площадей, идентификации и быстрого поиска хранимых товарно-материальных ценностей;</li> <li>Участие в ежемесячных инвентаризациях;</li> <li>Проведение в системе SAP и EWM ежемесячных инвентаризаций;</li> <li>Настройка правил размещения, планирования и отбора продукции в EWM;</li> <li>Настройка групп товаров в EWM, включая АВС анализ;</li> <li>Обучение сотрудников по программе EWM;</li> <li>Выявление и анализ корневых ошибок по EWM;</li> <li>Настройка топологии склада (добавление новых зон, ячеек);</li> <li>Проведение циклических пересчетов склада на сходимость в EWM и SAP;</li> <li>Консолидация и ведение VPO отчетности;</li> <li>Контроль над выявлением корневых причин отклонений в показателях;</li> <li>Консолидация еженедельных и ежемесячных презентаций.</li> </ul> <strong>Требования:</strong> <ul> <li>Высшее образование;</li> <li>Желателен опыт работы в логистике;</li> <li>Аналитические навыки;</li> <li>Лидерские качества, целеустремленность, стрессоустойчивость;</li> <li>Умение работать в команде и организовывать процесс;</li> <li>Уверенное владение MS Office, важно знание MS Excel (ВПР, сводные таблицы);</li> <li>Желательно знание SAP;</li> <li>Желательно, но не обязательно знание английского языка.</li> </ul></div>\n  <div class=\"tmpl-hh-propose\">\n    <h3 class=\"tmpl-hh-propose__title\">\n      Мы предлагаем:\n    </h3>\n    <div class=\"tmpl-hh-propose__wrapper\">\n        <div class=\"tmpl-hh-propose__item\">\n          <p class=\"tmpl-hh-propose__item-text\">Работу в стабильной компании-лидере отрасли, которая производит известные бренды</p>\n          <div class=\"tmpl-hh-propose__item-icon\">\n            <svg>\n              <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#stable\"></use>\n            </svg>\n          </div>\n        </div>\n        <div class=\"tmpl-hh-propose__item\">\n          <p class=\"tmpl-hh-propose__item-text\">Конкурентную зарплату и премии, ежегодное повышение</p>\n          <div class=\"tmpl-hh-propose__item-icon\">\n            <svg>\n              <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#salary\"></use>\n            </svg>\n          </div>\n        </div>\n        <div class=\"tmpl-hh-propose__item tmpl-hh-propose__item_big\">\n          <p class=\"tmpl-hh-propose__item-text\">Талантливую команду, дружелюбную атмосферу и неограниченные возможности для развития и карьерного роста</p>\n          <div class=\"tmpl-hh-propose__item-icon\">\n            <svg>\n              <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#team\"></use>\n            </svg>\n          </div>\n        </div>\n        <div class=\"tmpl-hh-propose__item tmpl-hh-propose__item_small\">\n          <p class=\"tmpl-hh-propose__item-text\">Программы обучения</p>\n          <div class=\"tmpl-hh-propose__item-icon\">\n            <svg>\n              <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#education\"></use>\n            </svg>\n          </div>\n        </div>\n        <div class=\"tmpl-hh-propose__item\">\n          <p class=\"tmpl-hh-propose__item-text\">Программы благополучия сотрудников и членов их семей</p>\n          <div class=\"tmpl-hh-propose__item-icon\">\n            <svg>\n              <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#family\"></use>\n            </svg>\n          </div>\n        </div>\n        <div class=\"tmpl-hh-propose__item\">\n          <p class=\"tmpl-hh-propose__item-text\">Дополнительные отпуска и материальную помощь</p>\n          <div class=\"tmpl-hh-propose__item-icon\">\n            <svg>\n              <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#vacation\"></use>\n            </svg>\n          </div>\n        </div>\n        <div class=\"tmpl-hh-propose__item tmpl-hh-propose__item_small\">\n          <p class=\"tmpl-hh-propose__item-text\">Дотацию затрат на обеды</p>\n          <div class=\"tmpl-hh-propose__item-icon\">\n            <svg>\n              <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#subsidy\"></use>\n            </svg>\n          </div>\n        </div>\n        <div class=\"tmpl-hh-propose__item tmpl-hh-propose__item_big\">\n          <p class=\"tmpl-hh-propose__item-text\">ДМС, страхование жизни, страхование от несчастных случаев, возможность страхования родственников</p>\n          <div class=\"tmpl-hh-propose__item-icon\">\n            <svg>\n              <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#insurer\"></use>\n            </svg>\n          </div>\n        </div>\n        <div class=\"tmpl-hh-propose__item tmpl-hh-propose__item_increased-height\">\n          <p class=\"tmpl-hh-propose__item-text\">Возможность пройти бесплатное комплексное медицинское обследование</p>\n          <div class=\"tmpl-hh-propose__item-icon\">\n            <svg>\n              <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#medicine\"></use>\n            </svg>\n          </div>\n        </div>\n        <div class=\"tmpl-hh-propose__item tmpl-hh-propose__item_increased-height\">\n          <p class=\"tmpl-hh-propose__item-text\">Расширенную программу поддержки для обоих родителей в период беременности и рождения ребёнка</p>\n          <div class=\"tmpl-hh-propose__item-icon\">\n            <svg>\n              <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#pregnancy\"></use>\n            </svg>\n          </div>\n        </div>\n    </div>\n  </div>\n  <div class=\"tmpl-hh-banner\">\n    <div class=\"tmpl-hh-banner__wrapper\">\n      <div class=\"tmpl-hh-banner__decor tmpl-hh-banner__decor_small\">\n        <img src=\"https://hhcdn.ru/ichameleon/350246.png\" alt=\"decor image\">\n      </div>\n      <div class=\"tmpl-hh-banner__decor tmpl-hh-banner__decor_big\">\n        <img src=\"https://hhcdn.ru/ichameleon/350257.png\" alt=\"decor image\">\n      </div>\n      <div class=\"tmpl-hh-banner__text-content\">\n        <p class=\"tmpl-hh-banner__title\">Мечтаем о большем,</p>\n        <p class=\"tmpl-hh-banner__text\">наполняя будущее радостными моментами</p>\n      </div>\n    </div>\n  </div>\n  <div class=\"tmpl-hh-video\" data-tmpl-hh-video=\"\">\n    <div class=\"tmpl-hh-video__cover \" data-tmpl-hh-video-cover=\"\"></div>\n    <button class=\"tmpl-hh-video__play-button\" data-tmpl-hh-video-play-button=\"\" type=\"button\"></button>\n    <video class=\"tmpl-hh-video__video tmpl-hh-video__video_hidden\" controls=\"\" data-tmpl-hh-video-video=\"\" playsinline=\"\">\n      <source src=\"https://hhcdn.ru/file/17751268.mp4\" type=\"video/mp4\"></source>\n      Твой браузер не поддерживает тег video\n    </video>\n  </div>\n  <div class=\"tmpl-hh-footer\">\n    <p class=\"tmpl-hh-footer__paragraph\">*по данным ООО ЭЙ СИ НИЛЬСЕН, 2024 (сноска указана для содержания вакансии и видео)</p>\n    <p class=\"tmpl-hh-footer__paragraph\">**по версии hh.ru за 2022-2023 гг.</p>\n  </div>\n  <svg class=\"icons\" display=\"none\">\n    <symbol id=\"stable\" viewBox=\"0 0 40 40\">\n      <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M17.4281 6.00001C14.4382 6.00001 11.9957 8.39783 11.9957 11.3546C11.9957 13.4572 13.2315 15.2789 15.0203 16.1563C12.1008 17.1357 10 19.8459 10 23.051V29.0122C10 29.138 10.05 29.2586 10.1389 29.3475C10.2278 29.4364 10.3484 29.4864 10.4742 29.4864H16.8428C16.6741 28.8944 16.5817 28.2711 16.5817 27.6268C16.5817 23.8754 19.6468 20.8053 23.3958 20.8053C23.781 20.8053 24.1584 20.8393 24.5265 20.9016C23.8293 18.6721 22.0744 16.9058 19.8378 16.1554C21.6244 15.2776 22.8568 13.4564 22.8568 11.3546C22.8568 8.39782 20.418 6.00001 17.4281 6.00001ZM23.3958 21.7536C20.1621 21.7536 17.53 24.3894 17.53 27.6268C17.53 30.8642 20.1621 33.5 23.3958 33.5C26.6295 33.5 29.2588 30.8642 29.2588 27.6268C29.2588 24.3894 26.6295 21.7536 23.3958 21.7536ZM23.3893 24.1836C23.4756 24.1835 23.5603 24.207 23.6342 24.2516C23.7081 24.2962 23.7685 24.3601 23.8088 24.4364L24.6414 26.0182L26.4019 26.3238C26.487 26.3385 26.5665 26.3762 26.6318 26.4329C26.6971 26.4895 26.7457 26.563 26.7723 26.6453C26.7989 26.7275 26.8025 26.8156 26.7828 26.8998C26.763 26.984 26.7206 27.0612 26.6602 27.123L25.4147 28.4047L25.6684 30.1744C25.6808 30.26 25.6696 30.3473 25.6361 30.427C25.6025 30.5067 25.5478 30.5756 25.4779 30.6265C25.408 30.6773 25.3256 30.708 25.2395 30.7153C25.1535 30.7227 25.067 30.7063 24.9896 30.668L23.3865 29.8781L21.7835 30.6662C21.706 30.7045 21.6196 30.7208 21.5335 30.7135C21.4475 30.7062 21.3651 30.6754 21.2952 30.6246C21.2253 30.5738 21.1706 30.5048 21.137 30.4252C21.1035 30.3455 21.0923 30.2582 21.1047 30.1726L21.3603 28.4019L20.1156 27.1193C20.0555 27.0574 20.0133 26.9802 19.9938 26.896C19.9742 26.8119 19.978 26.724 20.0047 26.6419C20.0314 26.5597 20.08 26.4864 20.1452 26.4299C20.2105 26.3733 20.2899 26.3357 20.3749 26.321L22.1354 26.0173L22.9707 24.4355C23.0111 24.3595 23.0714 24.2958 23.1451 24.2514C23.2189 24.2071 23.3033 24.1836 23.3893 24.1836Z\"></path>\n    </symbol>\n  \n    <symbol id=\"salary\" viewBox=\"0 0 40 40\">\n      <path d=\"M17.5772 12.2963H19.0361V17.719C19.3114 17.6915 19.6142 17.664 19.917 17.664C20.2198 17.664 20.495 17.6915 20.7978 17.719V12.2963H22.2567C22.7247 12.2963 23.0275 11.7733 22.7797 11.3604L20.4124 7.56176C20.1647 7.17639 19.6142 7.17639 19.3664 7.56176L17.0267 11.3604C16.779 11.7733 17.0817 12.2963 17.5772 12.2963Z\"></path>\n      <path d=\"M12.9797 21.0497C13.4752 20.4166 14.0532 19.8386 14.7139 19.3431V15.7646H16.1728C16.6407 15.7646 16.9435 15.2416 16.6958 14.8287L14.3836 11.0301C14.1358 10.6447 13.5853 10.6447 13.3375 11.0301L10.9978 14.8287C10.7501 15.2416 11.0529 15.7646 11.5208 15.7646H12.9797V21.0497Z\"></path>\n      <path d=\"M28.7807 14.8287L26.441 11.0301C26.1933 10.6447 25.6427 10.6447 25.395 11.0301L23.0828 14.8287C22.835 15.2416 23.1378 15.7646 23.6058 15.7646H25.0647V19.3706C25.7253 19.8661 26.3034 20.4166 26.7988 21.0772V15.7646H28.2577C28.7257 15.7646 29.0285 15.2416 28.7807 14.8287Z\"></path>\n      <path d=\"M19.8884 19.3982C16.0347 19.3982 12.8691 22.5362 12.8691 26.3899C12.8691 30.2436 16.0347 33.4091 19.8884 33.4091C23.7421 33.4091 26.9076 30.2711 26.9076 26.3899C26.9076 22.5087 23.7421 19.3982 19.8884 19.3982ZM20.6316 30.0784V30.8767C20.6316 31.0419 20.494 31.1795 20.3288 31.1795H19.448C19.2828 31.1795 19.1452 31.0419 19.1452 30.8767V30.106C18.2368 29.9958 17.5211 29.2802 17.4385 28.3718C17.4385 28.2892 17.4661 28.2066 17.5211 28.1516C17.5762 28.0965 17.6587 28.0415 17.7413 28.0415H18.6222C18.7598 28.0415 18.8699 28.1241 18.8974 28.2617C18.9525 28.4819 19.1452 28.6471 19.3654 28.6471H20.1637C20.5765 28.6471 20.9344 28.3443 20.9619 27.9589C20.9894 27.7387 20.9069 27.5185 20.7692 27.3808C20.6316 27.2157 20.4114 27.1331 20.2187 27.1331H19.6406C18.457 27.1331 17.4385 26.2523 17.3284 25.1237C17.2183 23.9676 18.0166 22.9215 19.1452 22.7013V21.9031C19.1452 21.7379 19.2828 21.6003 19.448 21.6003H20.3288C20.494 21.6003 20.6316 21.7379 20.6316 21.9031V22.6738C21.54 22.7839 22.2557 23.4996 22.3382 24.408C22.3382 24.4906 22.3107 24.5731 22.2557 24.6282C22.2006 24.6832 22.118 24.7383 22.0354 24.7383H21.1546C21.017 24.7383 20.9069 24.6557 20.8793 24.5181C20.8243 24.2979 20.6316 24.1327 20.4114 24.1327H19.6131C19.2002 24.1327 18.8424 24.4355 18.8149 24.8209C18.7873 25.0411 18.8699 25.2613 19.0075 25.3989C19.1452 25.5641 19.3654 25.6467 19.5856 25.6467H20.2462C20.8793 25.6467 21.4849 25.9219 21.8978 26.3899C22.3382 26.8578 22.5309 27.4634 22.4759 28.0965C22.3382 29.0875 21.595 29.8582 20.6316 30.0784Z\"></path>\n    </symbol>\n  \n    <symbol id=\"schedule\" viewBox=\"0 0 40 40\">\n      <path d=\"M16.5303 27.4089H23.468C23.6932 27.4089 23.8977 27.317 24.0464 27.1683C24.1942 27.0204 24.2871 26.815 24.2871 26.5898V26.0776H23.9691H16.0309H15.7129V26.5898C15.7129 26.815 15.8049 27.0196 15.9536 27.1683C16.1014 27.3161 16.3068 27.4089 16.532 27.4089H16.5303ZM23.468 28.4119H16.5303C16.0292 28.4119 15.5737 28.2065 15.2437 27.8773C14.9136 27.5473 14.7091 27.0909 14.7091 26.5907V25.5765C14.7091 25.2998 14.9334 25.0755 15.2101 25.0755H15.535V21.1253C15.535 20.5761 15.7593 20.0776 16.1203 19.7166C16.4813 19.3556 16.9815 19.1313 17.5299 19.1313H22.4684C23.0168 19.1313 23.5161 19.3556 23.878 19.7166C24.2389 20.0776 24.4633 20.577 24.4633 21.1253V25.0755H24.7881C25.0649 25.0755 25.2892 25.2998 25.2892 25.5765V26.5907C25.2892 27.0918 25.0838 27.5473 24.7546 27.8773C24.4246 28.2074 23.9682 28.4119 23.468 28.4119ZM22.4684 20.1326H17.5299C17.2574 20.1326 17.009 20.2443 16.8294 20.424C16.6498 20.6036 16.538 20.852 16.538 21.1244V25.0746H23.4602V21.1244C23.4602 20.852 23.3485 20.6036 23.1689 20.424C22.9893 20.2443 22.7409 20.1326 22.4684 20.1326ZM24.6824 10.5787L27.0829 12.8649V8.47811H24.6824V10.5787ZM23.859 11.1751C23.8427 11.1614 23.8264 11.1468 23.8118 11.1305L20 7.50003L10 17.0247V31.9513H30V17.0247L27.2626 14.418C27.2454 14.4033 27.2299 14.3887 27.2144 14.3724L23.859 11.176V11.1751Z\"></path>\n    </symbol>\n  \n    <symbol id=\"team\" viewBox=\"0 0 40 40\">\n      <path d=\"M23.125 15.6249C23.125 13.9018 21.7231 12.4999 20 12.4999C18.2769 12.4999 16.875 13.9018 16.875 15.6249V16.8749C16.875 18.598 18.2769 19.9999 20 19.9999C21.7231 19.9999 23.125 18.598 23.125 16.8749V15.6249Z\"></path>\n      <path d=\"M13.749 26.875V29.375C13.749 29.7206 14.029 30 14.374 30H25.624C25.969 30 26.249 29.7206 26.249 29.375V26.875C26.249 23.7731 23.7253 21.25 20.624 21.25H19.374C16.2728 21.25 13.749 23.7731 13.749 26.875Z\"></path>\n      <path d=\"M12.5 17.5C14.2231 17.5 15.625 16.0981 15.625 14.375V13.125C15.625 11.4019 14.2231 10 12.5 10C10.7769 10 9.375 11.4019 9.375 13.125V14.375C9.375 16.0981 10.7769 17.5 12.5 17.5Z\"></path>\n      <path d=\"M12.5 26.8751C12.5 23.8813 14.4188 21.3313 17.0938 20.3938C16.075 19.3813 14.675 18.7501 13.125 18.7501H11.875C8.775 18.7501 6.25 21.2751 6.25 24.3751V26.8751C6.25 27.2188 6.53125 27.5001 6.875 27.5001H12.5V26.8751Z\"></path>\n      <path d=\"M27.5 17.5C29.2231 17.5 30.625 16.0981 30.625 14.375V13.125C30.625 11.4019 29.2231 10 27.5 10C25.7769 10 24.375 11.4019 24.375 13.125V14.375C24.375 16.0981 25.7769 17.5 27.5 17.5Z\"></path>\n      <path d=\"M28.125 18.7501H26.875C25.325 18.7501 23.925 19.3813 22.9062 20.3938C25.5813 21.3313 27.5 23.8813 27.5 26.8751V27.5001H33.125C33.4688 27.5001 33.75 27.2188 33.75 26.8751V24.3751C33.75 21.2751 31.225 18.7501 28.125 18.7501Z\"></path>\n    </symbol>\n  \n    <symbol id=\"insurer\" viewBox=\"0 0 40 40\">\n      <path d=\"M17.4 11.5714H22.6V13.3571H26.0667V11.5714C26.0667 9.60714 24.5067 8 22.6 8H17.4C15.4933 8 13.9333 9.60714 13.9333 11.5714V13.3571H17.4V11.5714ZM31.2667 15.1429H8.73333C7.78 15.1429 7 15.9464 7 16.9286V31.2143C7 32.1964 7.78 33 8.73333 33H31.2667C32.22 33 33 32.1964 33 31.2143V16.9286C33 15.9464 32.22 15.1429 31.2667 15.1429ZM20 31.2143C16.1711 31.2143 13.0667 28.0161 13.0667 24.0714C13.0667 20.1268 16.1711 16.9286 20 16.9286C23.8289 16.9286 26.9333 20.1268 26.9333 24.0714C26.9333 28.0161 23.8289 31.2143 20 31.2143ZM21.7333 18.7143H18.2667V22.2857H14.8V25.8571H18.2667V29.4286H21.7333V25.8571H25.2V22.2857H21.7333V18.7143Z\"></path>\n    </symbol>\n  \n    <symbol id=\"subsidy\" viewBox=\"0 0 40 40\">\n      <path d=\"M31.3539 9.52586C28.6962 7.28505 19.759 12.3399 22.3907 17.056C22.6512 17.525 22.5991 18.0983 22.2344 18.4631C21.609 19.1405 20.9316 19.818 20.1759 20.5736C19.733 20.1306 19.29 19.6877 18.8731 19.2708C18.5344 18.9321 18.4302 18.4109 18.6126 17.994C19.3161 16.3265 18.9513 14.2941 17.5443 12.9392L13.3753 8.90052C13.1669 8.71813 12.8542 8.69207 12.6458 8.87446C12.4113 9.08291 12.3852 9.44769 12.5936 9.6822L16.5281 13.773C16.7365 14.0075 16.7365 14.3723 16.476 14.5807L16.4239 14.6328C16.1894 14.8152 15.8767 14.7892 15.6682 14.5807L11.7599 10.3075C11.5514 10.0991 11.2387 10.073 11.0042 10.2554L10.9521 10.2815C10.7176 10.4899 10.6916 10.8287 10.9 11.0632L14.626 15.3885C14.8345 15.623 14.8084 15.9617 14.5739 16.1701L14.5478 16.1962C14.3133 16.4046 13.9746 16.3525 13.7662 16.118L10.1444 11.6885C9.96199 11.454 9.59721 11.4279 9.36271 11.6103L9.31059 11.6364C9.07609 11.8188 9.05003 12.1575 9.23243 12.392L12.776 16.9779C12.9584 17.2124 12.9063 17.5511 12.6979 17.7335L12.6458 17.7856C12.4113 17.994 12.0465 17.9419 11.838 17.6814L8.50286 13.1216C8.32047 12.861 7.95568 12.8089 7.69512 13.0174C7.48668 13.1998 7.43456 13.5124 7.5909 13.7469L10.9261 18.6715C11.9944 20.2609 13.8964 20.9123 15.6422 20.4954C16.1112 20.3912 16.6063 20.5736 16.8929 20.9644C17.2837 21.5116 17.6746 22.0588 18.0915 22.6581C16.9971 23.7785 15.7985 25.0552 14.5478 26.5404C11.0824 30.6833 11.7338 31.7255 12.307 32.1945C12.8803 32.6636 14.0267 33.1586 17.4922 29.0157C18.5083 27.7911 19.3943 26.6446 20.1759 25.5763C20.9576 26.6446 21.8175 27.765 22.8336 28.9636C26.2991 33.1326 27.4455 32.6636 28.0188 32.1685C28.592 31.6995 29.2695 30.6572 25.778 26.5143C24.5273 25.0292 23.3548 23.7524 22.2604 22.6581C22.9118 21.72 23.5111 20.8602 24.1104 20.0785C24.4231 19.6616 24.9702 19.5053 25.4913 19.6877C30.5723 21.4074 33.9856 11.7667 31.3539 9.52586Z\"></path>\n    </symbol>\n  \n    <symbol id=\"vacation\" viewBox=\"0 0 40 40\">\n      <path d=\"M17.2615 12.2086C18.5618 12.2086 19.6158 11.1545 19.6158 9.8543C19.6158 8.55406 18.5618 7.5 17.2615 7.5C15.9613 7.5 14.9072 8.55406 14.9072 9.8543C14.9072 11.1545 15.9613 12.2086 17.2615 12.2086Z\"></path>\n      <path d=\"M31.6336 28.0487C31.5724 28.1459 31.4877 28.2261 31.3874 28.282C31.287 28.3379 31.1743 28.3677 31.0594 28.3686H8.17263C8.03018 28.368 7.89157 28.3224 7.77661 28.2383C7.66165 28.1542 7.57622 28.0359 7.53254 27.9003C7.48886 27.7647 7.48916 27.6187 7.53341 27.4833C7.57765 27.3479 7.66357 27.23 7.77888 27.1464C9.03475 26.2574 10.3353 25.4333 11.6754 24.6772V18.4838C11.3563 18.6051 11.0657 18.7908 10.8215 19.0293C10.5774 19.2678 10.385 19.554 10.2562 19.8701C10.1934 20.0365 10.0673 20.1712 9.90544 20.2449C9.74362 20.3187 9.5592 20.3254 9.39242 20.2637C9.22564 20.202 9.09005 20.0768 9.01521 19.9155C8.94037 19.7541 8.93237 19.5698 8.99295 19.4026C9.29677 18.6506 9.81984 18.0075 10.4941 17.5569C9.89717 17.4637 9.29358 17.4198 8.68943 17.4256C8.60069 17.4279 8.51237 17.4126 8.42956 17.3806C8.34676 17.3486 8.27111 17.3005 8.20697 17.2392C8.14283 17.1778 8.09147 17.1043 8.05585 17.023C8.02023 16.9417 8.00106 16.8541 7.99943 16.7654C7.99781 16.6766 8.01377 16.5884 8.04639 16.5058C8.07901 16.4233 8.12765 16.348 8.1895 16.2843C8.25135 16.2206 8.3252 16.1698 8.40677 16.1348C8.48835 16.0998 8.57605 16.0813 8.66482 16.0803C9.31243 16.0677 9.95997 16.1089 10.6008 16.2034C10.3981 15.961 10.1501 15.7603 9.87068 15.6127C9.78956 15.5785 9.71599 15.5286 9.65421 15.4658C9.59243 15.4031 9.54364 15.3287 9.51065 15.2471C9.47766 15.1655 9.46111 15.0781 9.46196 14.9901C9.4628 14.902 9.48103 14.815 9.51559 14.734C9.55014 14.653 9.60035 14.5796 9.66333 14.5181C9.72631 14.4565 9.80082 14.408 9.88259 14.3754C9.96436 14.3427 10.0518 14.3265 10.1398 14.3277C10.2279 14.3288 10.3148 14.3474 10.3957 14.3823C11.1503 14.7734 11.7809 15.3671 12.2168 16.0967C12.668 15.0549 13.3898 13.7424 14.3496 13.2666C14.4287 13.228 14.5147 13.2053 14.6026 13.2001C14.6905 13.1948 14.7785 13.2071 14.8617 13.2361C14.9448 13.265 15.0214 13.3102 15.087 13.369C15.1525 13.4277 15.2058 13.4989 15.2437 13.5784C15.3227 13.7383 15.3351 13.9231 15.2782 14.0922C15.2214 14.2613 15.0998 14.401 14.9402 14.4807C14.3601 14.925 13.9143 15.5212 13.6523 16.2034C14.4863 15.9777 15.3411 15.8375 16.2035 15.785C16.381 15.7757 16.5553 15.8353 16.6898 15.9515C16.8244 16.0677 16.9088 16.2314 16.9253 16.4084C16.9375 16.5866 16.8789 16.7624 16.7621 16.8976C16.6454 17.0328 16.48 17.1164 16.3019 17.1303C15.5602 17.1834 14.8246 17.3014 14.1035 17.4831C14.7988 17.9003 15.3377 18.5343 15.6375 19.2877C15.669 19.3706 15.6835 19.4589 15.6803 19.5475C15.677 19.636 15.656 19.7231 15.6185 19.8034C15.5811 19.8837 15.5278 19.9557 15.462 20.015C15.3962 20.0744 15.3192 20.12 15.2355 20.1491C15.0679 20.2081 14.8838 20.1991 14.7228 20.1239C14.5617 20.0488 14.4366 19.9135 14.3742 19.7471C14.2523 19.4509 14.0684 19.1842 13.835 18.9649C13.6015 18.7456 13.3239 18.5788 13.0206 18.4756V23.9389C15.6677 22.4487 18.5596 21.4431 21.5601 20.9694C22.6447 20.8425 23.7438 20.9346 24.7922 21.2401V15.2928C24.4177 15.4203 24.0752 15.627 23.7878 15.8987C23.5004 16.1705 23.275 16.5011 23.1269 16.8678C23.0613 17.0331 22.9334 17.1661 22.7709 17.2382C22.6083 17.3103 22.4239 17.3157 22.2573 17.2534C22.1745 17.2232 22.0986 17.1768 22.0339 17.117C21.9691 17.0572 21.9169 16.9852 21.8803 16.905C21.8437 16.8249 21.8233 16.7383 21.8205 16.6502C21.8176 16.5621 21.8322 16.4744 21.8636 16.392C22.2145 15.5383 22.8297 14.8196 23.6191 14.3412C22.9133 14.2096 22.1958 14.1519 21.478 14.1689C21.3007 14.165 21.1314 14.0945 21.0037 13.9713C20.876 13.8482 20.7993 13.6816 20.789 13.5045C20.7869 13.4159 20.8025 13.3278 20.835 13.2453C20.8674 13.1628 20.916 13.0877 20.9779 13.0243C21.0398 12.9608 21.1138 12.9104 21.1954 12.876C21.2771 12.8415 21.3648 12.8237 21.4534 12.8236C22.2112 12.8084 22.9689 12.8606 23.7175 12.9795C23.4669 12.6573 23.151 12.3917 22.7905 12.2002C22.6263 12.1306 22.4964 11.9985 22.4295 11.8332C22.3626 11.6678 22.3641 11.4826 22.4337 11.3183C22.5033 11.1541 22.6353 11.0242 22.8007 10.9573C22.9661 10.8904 23.1513 10.8919 23.3155 10.9615C24.1563 11.4088 24.8552 12.0822 25.3335 12.9057C25.8175 11.7572 26.6132 10.2724 27.6632 9.75565C27.7423 9.71591 27.8285 9.69223 27.9168 9.68599C28.0051 9.67975 28.0938 9.69107 28.1777 9.71929C28.2616 9.74751 28.339 9.79208 28.4056 9.85041C28.4722 9.90875 28.5265 9.9797 28.5655 10.0592C28.6439 10.2192 28.656 10.4038 28.5991 10.5727C28.5423 10.7416 28.4212 10.8813 28.262 10.9615C27.5789 11.4836 27.0583 12.1892 26.7609 12.9959C27.7094 12.7311 28.6823 12.5635 29.6648 12.4955C29.8439 12.4849 30.02 12.5452 30.1551 12.6634C30.2902 12.7816 30.3733 12.9481 30.3866 13.1271C30.3986 13.3044 30.3396 13.4792 30.2227 13.613C30.1058 13.7469 29.9405 13.8288 29.7632 13.8408C28.901 13.8998 28.0466 14.0427 27.212 14.2673C28.0196 14.7117 28.6485 15.4218 28.9921 16.2771C29.0214 16.36 29.0341 16.448 29.0293 16.5358C29.0246 16.6236 29.0025 16.7097 28.9644 16.7889C28.9263 16.8682 28.8729 16.9392 28.8072 16.9978C28.7416 17.0563 28.665 17.1013 28.582 17.1302C28.4996 17.1613 28.412 17.1754 28.3241 17.1719C28.2362 17.1684 28.1499 17.1473 28.0703 17.1098C27.9908 17.0723 27.9195 17.0192 27.8609 16.9537C27.8022 16.8882 27.7573 16.8115 27.7288 16.7283C27.5856 16.3857 27.3688 16.0788 27.0938 15.8293C26.8188 15.5798 26.4923 15.3938 26.1374 15.2845V21.6338C26.1332 21.6755 26.1249 21.7167 26.1128 21.7568C28.4794 23.0436 30.4097 25.0053 31.6581 27.3924C31.7108 27.4946 31.7362 27.6088 31.7319 27.7237C31.7276 27.8387 31.6938 27.9506 31.6336 28.0487Z\"></path>\n      <path d=\"M25.0005 29.7115H8.17366C7.99573 29.7124 7.82538 29.7837 7.69987 29.9098C7.57436 30.0359 7.50391 30.2066 7.50391 30.3846C7.50391 30.5625 7.57436 30.7332 7.69987 30.8593C7.82538 30.9855 7.99573 31.0568 8.17366 31.0576H25.0005C25.0892 31.0581 25.1771 31.041 25.2591 31.0074C25.3412 30.9737 25.4158 30.9242 25.4786 30.8617C25.5415 30.7991 25.5913 30.7248 25.6254 30.6429C25.6594 30.561 25.6769 30.4732 25.6769 30.3846C25.6769 30.2959 25.6594 30.2081 25.6254 30.1262C25.5913 30.0443 25.5415 29.97 25.4786 29.9075C25.4158 29.8449 25.3412 29.7954 25.2591 29.7618C25.1771 29.7281 25.0892 29.7111 25.0005 29.7115Z\"></path>\n      <path d=\"M20.289 32.4038H8.17366C7.99573 32.4047 7.82538 32.476 7.69987 32.6021C7.57436 32.7283 7.50391 32.8989 7.50391 33.0769C7.50391 33.2548 7.57436 33.4255 7.69987 33.5516C7.82538 33.6778 7.99573 33.7491 8.17366 33.75H20.289C20.3777 33.7504 20.4656 33.7333 20.5476 33.6997C20.6296 33.666 20.7042 33.6165 20.7671 33.554C20.8299 33.4915 20.8798 33.4171 20.9138 33.3352C20.9479 33.2533 20.9654 33.1656 20.9654 33.0769C20.9654 32.9882 20.9479 32.9004 20.9138 32.8185C20.8798 32.7367 20.8299 32.6623 20.7671 32.5998C20.7042 32.5372 20.6296 32.4877 20.5476 32.4541C20.4656 32.4205 20.3777 32.4034 20.289 32.4038Z\"></path>\n    </symbol>\n  \n    <symbol id=\"family\" viewBox=\"0 0 40 40\">\n      <path d=\"M27.0831 15.2963H27.0774C24.9156 15.2963 23.1562 13.5484 23.1562 11.3981C23.1562 9.24783 24.9156 7.5 27.0831 7.5C29.2449 7.5 31.0042 9.24783 31.0042 11.3981C31.0042 13.5427 29.2449 15.2905 27.0831 15.2963Z\"></path>\n      <path d=\"M19.3725 24.1044C21.4538 24.1044 23.4144 25.6625 24.4838 28.175C25.0185 29.4342 24.685 30.8888 23.6559 31.7914C22.6612 32.6654 21.4366 33.2058 20.12 33.3553L20.051 33.361C19.8267 33.3668 19.6025 33.3725 19.3783 33.3725C19.1541 33.3725 18.9298 33.3668 18.7056 33.361L18.6366 33.3553C17.3142 33.2058 16.0896 32.6654 15.1007 31.7914C14.0715 30.8888 13.7381 29.4342 14.2728 28.175C15.3307 25.6625 17.2912 24.1044 19.3725 24.1044Z\"></path>\n      <path d=\"M19.3725 23.1385C17.8086 23.1385 16.5322 21.8736 16.5322 20.3155C16.5322 18.7574 17.8029 17.4926 19.3725 17.4926C20.9363 17.4926 22.2127 18.7574 22.2127 20.3155C22.2127 21.8736 20.9363 23.1385 19.3725 23.1385Z\"></path>\n      <path d=\"M11.6746 15.2963H11.6631C9.97275 15.2963 8.59863 13.9279 8.59863 12.2491C8.59863 10.5702 9.97275 9.20184 11.6688 9.20184C13.3592 9.20184 14.739 10.5702 14.739 12.2491C14.7333 13.9221 13.3649 15.2905 11.6746 15.2963Z\"></path>\n      <path d=\"M5.03371 22.4945C5.24644 20.2063 6.50557 18.2342 8.48338 17.0901C9.48953 16.5036 10.5589 16.2104 11.6571 16.2047H11.6743C13.0312 16.2047 14.3881 16.6819 15.5955 17.5845L15.9519 17.849L15.7277 18.2342C15.3597 18.8666 15.1642 19.5911 15.1642 20.3213C15.1642 21.3159 15.5265 22.2818 16.1819 23.0407L16.5499 23.4662L16.0784 23.7767C14.7733 24.6448 13.7096 25.9787 13.0024 27.6518C12.9852 27.6978 12.968 27.738 12.9507 27.784C12.4563 29.0547 12.6287 30.492 13.3647 31.6419L13.6924 32.1536L12.2205 31.5327C10.4957 30.8025 8.90884 29.8193 7.49447 28.6062C5.71215 27.0654 4.80948 24.8403 5.03371 22.4945Z\"></path>\n      <path d=\"M25.8062 27.7783C25.7889 27.7323 25.7717 27.6921 25.7544 27.6461C25.0473 25.9787 23.9836 24.6391 22.6785 23.7709L22.207 23.4605L22.575 23.035C23.2304 22.2761 23.5926 21.3102 23.5926 20.3155C23.5926 19.5853 23.3972 18.8609 23.0292 18.2285L22.805 17.8432L23.1614 17.5788C24.3688 16.6819 25.7199 16.2047 27.0768 16.2047H27.0883C28.1865 16.2047 29.2559 16.5036 30.2678 17.0901C32.2456 18.2342 33.5047 20.2063 33.7174 22.4945C33.9359 24.8403 33.039 27.0711 31.2509 28.6062C29.8423 29.8193 28.2497 30.8025 26.5249 31.5327L24.9035 32.2284L25.2657 31.7224C26.0937 30.584 26.3179 29.0949 25.8062 27.7783Z\"></path>\n    </symbol>\n  \n    <symbol id=\"education\" viewBox=\"0 0 40 40\">\n      <path d=\"M9.08648 10.2761C9.81845 10.0906 10.5169 10.0057 11.1906 10.0003C13.4986 9.98156 15.5217 10.8902 17.6449 11.8439C18.2541 12.1175 18.8717 12.3949 19.5065 12.6551V29.5591C17.1569 28.1094 14.2949 26.7338 9.19509 27.5121L9.08648 10.2761Z\"></path>\n      <path d=\"M30.9122 10.2765L30.801 27.5121C25.7058 26.7342 22.8421 28.108 20.4925 29.557V12.6541C21.1263 12.3942 21.7428 12.1174 22.3511 11.8442C24.4743 10.8906 26.4975 9.98193 28.8068 10.0007C29.4809 10.0061 30.1796 10.0909 30.9122 10.2765Z\"></path>\n      <path d=\"M32.9888 13.0295L31.88 13.556L31.7855 28.1421C31.7855 28.1698 31.7832 28.1979 31.779 28.2252C31.7352 28.5194 31.4814 28.7186 31.2122 28.6708C26.5581 27.8407 23.9748 28.7553 21.8022 29.9996H33L32.9888 13.0295Z\"></path>\n      <path d=\"M8.78451 28.6711C13.4416 27.8407 16.0229 28.7553 18.1951 30H7L7.00954 13.0302L8.11935 13.5581L8.21117 28.1425C8.21315 28.4406 8.43564 28.6805 8.70848 28.6783C8.73382 28.678 8.75949 28.6755 8.78451 28.6711Z\"></path>\n    </symbol>\n  \n    <symbol id=\"medicine\" viewBox=\"0 0 40 40\">\n      <path d=\"M30.3483 24.8727C30.2478 24.471 30.2478 23.9688 30.3483 23.5671L31.7543 18.144C32.156 16.5372 30.9508 15.0308 29.344 15.0308H9.76058C8.15374 15.0308 6.94861 16.5372 7.35032 18.144L8.75631 23.5671C8.85673 23.9688 8.85673 24.471 8.75631 24.8727L7.35032 30.2958C6.94861 31.9026 8.15374 33.409 9.76058 33.409H29.4444C31.0513 33.409 32.2564 31.9026 31.8547 30.2958L30.3483 24.8727ZM23.5192 25.5757H20.9081V28.1868H18.2969V25.5757H15.6858V22.9646H18.2969V20.3534H20.9081V22.9646H23.5192V25.5757Z\"></path>\n      <path d=\"M26.1309 10.8128L27.5369 12.3192L26.0305 13.8256H27.8382L29.6459 12.1183L30.9515 10.8128C31.2527 10.5115 31.2527 10.1098 30.9515 9.90893L28.5412 7.49867C28.2399 7.19738 27.8382 7.19738 27.6373 7.49867L25.6288 9.40679L21.21 13.8256H23.0177L26.1309 10.8128Z\"></path>\n    </symbol>\n  \n    <symbol id=\"pregnancy\" viewBox=\"0 0 40 40\">\n      <path d=\"M11.5729 10.6666C14.2831 10.6666 16.4808 12.8634 16.4808 15.574C16.4808 18.2836 14.2831 20.4804 11.5729 20.4804C8.86378 20.4804 6.66699 18.2836 6.66699 15.574C6.66699 12.8634 8.86378 10.6666 11.5729 10.6666Z\"></path>\n      <path d=\"M11.9778 23.8671C11.9788 23.8671 11.9788 23.8661 11.9797 23.8652L13.6085 22.2364L15.2372 20.6077C15.2372 20.6077 15.2382 20.6067 15.2391 20.6067L16.7959 19.0495C16.8436 19.0013 16.8992 18.9658 16.9502 18.9228C16.9932 18.8863 17.0371 18.8508 17.0815 18.8157C17.1143 18.7919 17.1446 18.7648 17.1783 18.7428C17.7407 18.3356 18.4303 18.092 19.1778 18.092H27.3782C29.2637 18.092 30.7915 19.6203 30.7915 21.5053C30.7915 22.4029 30.4427 23.2163 29.8756 23.8264C29.8681 23.8339 29.8639 23.8428 29.8565 23.8503L29.8317 23.875C29.8041 23.9035 29.7761 23.9307 29.7475 23.9582L28.9734 24.7334C28.9668 24.7399 28.9626 24.746 28.957 24.7516H30.2291H31.0397C32.3071 24.7516 33.3333 25.7787 33.3333 27.0452C33.3333 28.3116 32.3071 29.3387 31.0397 29.3387H30.2291H24.2296H23.419C23.4063 29.3387 23.3951 29.335 23.3825 29.335C23.2446 29.3322 23.1067 29.3205 22.9706 29.2929C22.8968 29.2784 22.8271 29.2508 22.7551 29.2289C22.685 29.2078 22.6125 29.1915 22.5433 29.1629C22.4583 29.1283 22.3807 29.0807 22.3012 29.0362C22.2512 29.0077 22.1969 28.9862 22.1488 28.953C21.8959 28.7843 21.6785 28.5678 21.5106 28.3149C21.4807 28.27 21.4615 28.2219 21.4349 28.176C21.3872 28.0919 21.3372 28.0101 21.2998 27.9194C21.2731 27.8553 21.2596 27.788 21.2385 27.7221C21.2147 27.6464 21.1867 27.5716 21.1703 27.4921C21.1455 27.3659 21.1357 27.2392 21.132 27.1115C21.132 27.0886 21.1254 27.0676 21.1254 27.0447C21.1254 27.0283 21.1301 27.0129 21.131 26.9956C21.1338 26.8624 21.1446 26.7282 21.1712 26.5964C21.1848 26.5244 21.2114 26.4584 21.2325 26.3893C21.2544 26.3154 21.2717 26.2406 21.3007 26.1681C21.3335 26.0877 21.3793 26.0157 21.4204 25.9409C21.4503 25.8862 21.4742 25.8287 21.5088 25.7754H18.3204C17.8043 25.7754 17.3171 25.6576 16.8786 25.4533L16.3564 25.9746L13.6655 28.6664C12.7698 29.5622 11.3182 29.5622 10.422 28.6664C9.52577 27.7707 9.52624 26.3191 10.422 25.4229L11.9778 23.8671Z\"></path>\n    </symbol>\n  </svg>\n  \n</div>\n\n\n<script type=\"text/javascript\">  \n//\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n(function polyfill() {\n  const relList = document.createElement(\"link\").relList;\n  if (relList && relList.supports && relList.supports(\"modulepreload\")) {\n    return;\n  }\n  for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n    processPreload(link);\n  }\n  new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      if (mutation.type !== \"childList\") {\n        continue;\n      }\n      for (const node of mutation.addedNodes) {\n        if (node.tagName === \"LINK\" && node.rel === \"modulepreload\")\n          processPreload(node);\n      }\n    }\n  }).observe(document, { childList: true, subtree: true });\n  function getFetchOpts(link) {\n    const fetchOpts = {};\n    if (link.integrity)\n      fetchOpts.integrity = link.integrity;\n    if (link.referrerPolicy)\n      fetchOpts.referrerPolicy = link.referrerPolicy;\n    if (link.crossOrigin === \"use-credentials\")\n      fetchOpts.credentials = \"include\";\n    else if (link.crossOrigin === \"anonymous\")\n      fetchOpts.credentials = \"omit\";\n    else\n      fetchOpts.credentials = \"same-origin\";\n    return fetchOpts;\n  }\n  function processPreload(link) {\n    if (link.ep)\n      return;\n    link.ep = true;\n    const fetchOpts = getFetchOpts(link);\n    fetch(link.href, fetchOpts);\n  }\n})();\nconst index = \"\";\nfunction isObject$1(obj) {\n  return obj !== null && typeof obj === \"object\" && \"constructor\" in obj && obj.constructor === Object;\n}\nfunction extend$1(target, src) {\n  if (target === void 0) {\n    target = {};\n  }\n  if (src === void 0) {\n    src = {};\n  }\n  Object.keys(src).forEach((key) => {\n    if (typeof target[key] === \"undefined\")\n      target[key] = src[key];\n    else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n      extend$1(target[key], src[key]);\n    }\n  });\n}\nconst ssrDocument = {\n  body: {},\n  addEventListener() {\n  },\n  removeEventListener() {\n  },\n  activeElement: {\n    blur() {\n    },\n    nodeName: \"\"\n  },\n  querySelector() {\n    return null;\n  },\n  querySelectorAll() {\n    return [];\n  },\n  getElementById() {\n    return null;\n  },\n  createEvent() {\n    return {\n      initEvent() {\n      }\n    };\n  },\n  createElement() {\n    return {\n      children: [],\n      childNodes: [],\n      style: {},\n      setAttribute() {\n      },\n      getElementsByTagName() {\n        return [];\n      }\n    };\n  },\n  createElementNS() {\n    return {};\n  },\n  importNode() {\n    return null;\n  },\n  location: {\n    hash: \"\",\n    host: \"\",\n    hostname: \"\",\n    href: \"\",\n    origin: \"\",\n    pathname: \"\",\n    protocol: \"\",\n    search: \"\"\n  }\n};\nfunction getDocument() {\n  const doc = typeof document !== \"undefined\" ? document : {};\n  extend$1(doc, ssrDocument);\n  return doc;\n}\nconst ssrWindow = {\n  document: ssrDocument,\n  navigator: {\n    userAgent: \"\"\n  },\n  location: {\n    hash: \"\",\n    host: \"\",\n    hostname: \"\",\n    href: \"\",\n    origin: \"\",\n    pathname: \"\",\n    protocol: \"\",\n    search: \"\"\n  },\n  history: {\n    replaceState() {\n    },\n    pushState() {\n    },\n    go() {\n    },\n    back() {\n    }\n  },\n  CustomEvent: function CustomEvent() {\n    return this;\n  },\n  addEventListener() {\n  },\n  removeEventListener() {\n  },\n  getComputedStyle() {\n    return {\n      getPropertyValue() {\n        return \"\";\n      }\n    };\n  },\n  Image() {\n  },\n  Date() {\n  },\n  screen: {},\n  setTimeout() {\n  },\n  clearTimeout() {\n  },\n  matchMedia() {\n    return {};\n  },\n  requestAnimationFrame(callback) {\n    if (typeof setTimeout === \"undefined\") {\n      callback();\n      return null;\n    }\n    return setTimeout(callback, 0);\n  },\n  cancelAnimationFrame(id) {\n    if (typeof setTimeout === \"undefined\") {\n      return;\n    }\n    clearTimeout(id);\n  }\n};\nfunction getWindow() {\n  const win = typeof window !== \"undefined\" ? window : {};\n  extend$1(win, ssrWindow);\n  return win;\n}\nfunction classesToTokens(classes2) {\n  if (classes2 === void 0) {\n    classes2 = \"\";\n  }\n  return classes2.trim().split(\" \").filter((c) => !!c.trim());\n}\nfunction deleteProps(obj) {\n  const object = obj;\n  Object.keys(object).forEach((key) => {\n    try {\n      object[key] = null;\n    } catch (e) {\n    }\n    try {\n      delete object[key];\n    } catch (e) {\n    }\n  });\n}\nfunction nextTick(callback, delay) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n  return setTimeout(callback, delay);\n}\nfunction now() {\n  return Date.now();\n}\nfunction getComputedStyle$1(el) {\n  const window2 = getWindow();\n  let style;\n  if (window2.getComputedStyle) {\n    style = window2.getComputedStyle(el, null);\n  }\n  if (!style && el.currentStyle) {\n    style = el.currentStyle;\n  }\n  if (!style) {\n    style = el.style;\n  }\n  return style;\n}\nfunction getTranslate(el, axis) {\n  if (axis === void 0) {\n    axis = \"x\";\n  }\n  const window2 = getWindow();\n  let matrix;\n  let curTransform;\n  let transformMatrix;\n  const curStyle = getComputedStyle$1(el);\n  if (window2.WebKitCSSMatrix) {\n    curTransform = curStyle.transform || curStyle.webkitTransform;\n    if (curTransform.split(\",\").length > 6) {\n      curTransform = curTransform.split(\", \").map((a) => a.replace(\",\", \".\")).join(\", \");\n    }\n    transformMatrix = new window2.WebKitCSSMatrix(curTransform === \"none\" ? \"\" : curTransform);\n  } else {\n    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\");\n    matrix = transformMatrix.toString().split(\",\");\n  }\n  if (axis === \"x\") {\n    if (window2.WebKitCSSMatrix)\n      curTransform = transformMatrix.m41;\n    else if (matrix.length === 16)\n      curTransform = parseFloat(matrix[12]);\n    else\n      curTransform = parseFloat(matrix[4]);\n  }\n  if (axis === \"y\") {\n    if (window2.WebKitCSSMatrix)\n      curTransform = transformMatrix.m42;\n    else if (matrix.length === 16)\n      curTransform = parseFloat(matrix[13]);\n    else\n      curTransform = parseFloat(matrix[5]);\n  }\n  return curTransform || 0;\n}\nfunction isObject(o) {\n  return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\";\n}\nfunction isNode(node) {\n  if (typeof window !== \"undefined\" && typeof window.HTMLElement !== \"undefined\") {\n    return node instanceof HTMLElement;\n  }\n  return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction extend() {\n  const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);\n  const noExtend = [\"__proto__\", \"constructor\", \"prototype\"];\n  for (let i = 1; i < arguments.length; i += 1) {\n    const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];\n    if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {\n      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);\n      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n        const nextKey = keysArray[nextIndex];\n        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n        if (desc !== void 0 && desc.enumerable) {\n          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            to[nextKey] = {};\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n  }\n  return to;\n}\nfunction setCSSProperty(el, varName, varValue) {\n  el.style.setProperty(varName, varValue);\n}\nfunction animateCSSModeScroll(_ref) {\n  let {\n    swiper,\n    targetPosition,\n    side\n  } = _ref;\n  const window2 = getWindow();\n  const startPosition = -swiper.translate;\n  let startTime = null;\n  let time;\n  const duration = swiper.params.speed;\n  swiper.wrapperEl.style.scrollSnapType = \"none\";\n  window2.cancelAnimationFrame(swiper.cssModeFrameID);\n  const dir = targetPosition > startPosition ? \"next\" : \"prev\";\n  const isOutOfBound = (current, target) => {\n    return dir === \"next\" && current >= target || dir === \"prev\" && current <= target;\n  };\n  const animate = () => {\n    time = (/* @__PURE__ */ new Date()).getTime();\n    if (startTime === null) {\n      startTime = time;\n    }\n    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      currentPosition = targetPosition;\n    }\n    swiper.wrapperEl.scrollTo({\n      [side]: currentPosition\n    });\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      swiper.wrapperEl.style.overflow = \"hidden\";\n      swiper.wrapperEl.style.scrollSnapType = \"\";\n      setTimeout(() => {\n        swiper.wrapperEl.style.overflow = \"\";\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition\n        });\n      });\n      window2.cancelAnimationFrame(swiper.cssModeFrameID);\n      return;\n    }\n    swiper.cssModeFrameID = window2.requestAnimationFrame(animate);\n  };\n  animate();\n}\nfunction elementChildren(element, selector) {\n  if (selector === void 0) {\n    selector = \"\";\n  }\n  return [...element.children].filter((el) => el.matches(selector));\n}\nfunction showWarning(text) {\n  try {\n    console.warn(text);\n    return;\n  } catch (err) {\n  }\n}\nfunction createElement(tag, classes2) {\n  if (classes2 === void 0) {\n    classes2 = [];\n  }\n  const el = document.createElement(tag);\n  el.classList.add(...Array.isArray(classes2) ? classes2 : classesToTokens(classes2));\n  return el;\n}\nfunction elementPrevAll(el, selector) {\n  const prevEls = [];\n  while (el.previousElementSibling) {\n    const prev = el.previousElementSibling;\n    if (selector) {\n      if (prev.matches(selector))\n        prevEls.push(prev);\n    } else\n      prevEls.push(prev);\n    el = prev;\n  }\n  return prevEls;\n}\nfunction elementNextAll(el, selector) {\n  const nextEls = [];\n  while (el.nextElementSibling) {\n    const next = el.nextElementSibling;\n    if (selector) {\n      if (next.matches(selector))\n        nextEls.push(next);\n    } else\n      nextEls.push(next);\n    el = next;\n  }\n  return nextEls;\n}\nfunction elementStyle(el, prop) {\n  const window2 = getWindow();\n  return window2.getComputedStyle(el, null).getPropertyValue(prop);\n}\nfunction elementIndex(el) {\n  let child = el;\n  let i;\n  if (child) {\n    i = 0;\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1)\n        i += 1;\n    }\n    return i;\n  }\n  return void 0;\n}\nfunction elementParents(el, selector) {\n  const parents = [];\n  let parent = el.parentElement;\n  while (parent) {\n    if (selector) {\n      if (parent.matches(selector))\n        parents.push(parent);\n    } else {\n      parents.push(parent);\n    }\n    parent = parent.parentElement;\n  }\n  return parents;\n}\nfunction elementOuterSize(el, size, includeMargins) {\n  const window2 = getWindow();\n  if (includeMargins) {\n    return el[size === \"width\" ? \"offsetWidth\" : \"offsetHeight\"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-right\" : \"margin-top\")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-left\" : \"margin-bottom\"));\n  }\n  return el.offsetWidth;\n}\nfunction makeElementsArray(el) {\n  return (Array.isArray(el) ? el : [el]).filter((e) => !!e);\n}\nlet support;\nfunction calcSupport() {\n  const window2 = getWindow();\n  const document2 = getDocument();\n  return {\n    smoothScroll: document2.documentElement && document2.documentElement.style && \"scrollBehavior\" in document2.documentElement.style,\n    touch: !!(\"ontouchstart\" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)\n  };\n}\nfunction getSupport() {\n  if (!support) {\n    support = calcSupport();\n  }\n  return support;\n}\nlet deviceCached;\nfunction calcDevice(_temp) {\n  let {\n    userAgent\n  } = _temp === void 0 ? {} : _temp;\n  const support2 = getSupport();\n  const window2 = getWindow();\n  const platform = window2.navigator.platform;\n  const ua = userAgent || window2.navigator.userAgent;\n  const device = {\n    ios: false,\n    android: false\n  };\n  const screenWidth = window2.screen.width;\n  const screenHeight = window2.screen.height;\n  const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n  let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n  const windows = platform === \"Win32\";\n  let macos = platform === \"MacIntel\";\n  const iPadScreens = [\"1024x1366\", \"1366x1024\", \"834x1194\", \"1194x834\", \"834x1112\", \"1112x834\", \"768x1024\", \"1024x768\", \"820x1180\", \"1180x820\", \"810x1080\", \"1080x810\"];\n  if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n    ipad = ua.match(/(Version)\\/([\\d.]+)/);\n    if (!ipad)\n      ipad = [0, 1, \"13_0_0\"];\n    macos = false;\n  }\n  if (android && !windows) {\n    device.os = \"android\";\n    device.android = true;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = \"ios\";\n    device.ios = true;\n  }\n  return device;\n}\nfunction getDevice(overrides) {\n  if (overrides === void 0) {\n    overrides = {};\n  }\n  if (!deviceCached) {\n    deviceCached = calcDevice(overrides);\n  }\n  return deviceCached;\n}\nlet browser;\nfunction calcBrowser() {\n  const window2 = getWindow();\n  const device = getDevice();\n  let needPerspectiveFix = false;\n  function isSafari() {\n    const ua = window2.navigator.userAgent.toLowerCase();\n    return ua.indexOf(\"safari\") >= 0 && ua.indexOf(\"chrome\") < 0 && ua.indexOf(\"android\") < 0;\n  }\n  if (isSafari()) {\n    const ua = String(window2.navigator.userAgent);\n    if (ua.includes(\"Version/\")) {\n      const [major, minor] = ua.split(\"Version/\")[1].split(\" \")[0].split(\".\").map((num) => Number(num));\n      needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n    }\n  }\n  const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent);\n  const isSafariBrowser = isSafari();\n  const need3dFix = isSafariBrowser || isWebView && device.ios;\n  return {\n    isSafari: needPerspectiveFix || isSafariBrowser,\n    needPerspectiveFix,\n    need3dFix,\n    isWebView\n  };\n}\nfunction getBrowser() {\n  if (!browser) {\n    browser = calcBrowser();\n  }\n  return browser;\n}\nfunction Resize(_ref) {\n  let {\n    swiper,\n    on,\n    emit\n  } = _ref;\n  const window2 = getWindow();\n  let observer = null;\n  let animationFrame = null;\n  const resizeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized)\n      return;\n    emit(\"beforeResize\");\n    emit(\"resize\");\n  };\n  const createObserver = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized)\n      return;\n    observer = new ResizeObserver((entries) => {\n      animationFrame = window2.requestAnimationFrame(() => {\n        const {\n          width,\n          height\n        } = swiper;\n        let newWidth = width;\n        let newHeight = height;\n        entries.forEach((_ref2) => {\n          let {\n            contentBoxSize,\n            contentRect,\n            target\n          } = _ref2;\n          if (target && target !== swiper.el)\n            return;\n          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n        });\n        if (newWidth !== width || newHeight !== height) {\n          resizeHandler();\n        }\n      });\n    });\n    observer.observe(swiper.el);\n  };\n  const removeObserver = () => {\n    if (animationFrame) {\n      window2.cancelAnimationFrame(animationFrame);\n    }\n    if (observer && observer.unobserve && swiper.el) {\n      observer.unobserve(swiper.el);\n      observer = null;\n    }\n  };\n  const orientationChangeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized)\n      return;\n    emit(\"orientationchange\");\n  };\n  on(\"init\", () => {\n    if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== \"undefined\") {\n      createObserver();\n      return;\n    }\n    window2.addEventListener(\"resize\", resizeHandler);\n    window2.addEventListener(\"orientationchange\", orientationChangeHandler);\n  });\n  on(\"destroy\", () => {\n    removeObserver();\n    window2.removeEventListener(\"resize\", resizeHandler);\n    window2.removeEventListener(\"orientationchange\", orientationChangeHandler);\n  });\n}\nfunction Observer(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const observers = [];\n  const window2 = getWindow();\n  const attach = function(target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;\n    const observer = new ObserverFunc((mutations) => {\n      if (swiper.__preventObserver__)\n        return;\n      if (mutations.length === 1) {\n        emit(\"observerUpdate\", mutations[0]);\n        return;\n      }\n      const observerUpdate = function observerUpdate2() {\n        emit(\"observerUpdate\", mutations[0]);\n      };\n      if (window2.requestAnimationFrame) {\n        window2.requestAnimationFrame(observerUpdate);\n      } else {\n        window2.setTimeout(observerUpdate, 0);\n      }\n    });\n    observer.observe(target, {\n      attributes: typeof options.attributes === \"undefined\" ? true : options.attributes,\n      childList: typeof options.childList === \"undefined\" ? true : options.childList,\n      characterData: typeof options.characterData === \"undefined\" ? true : options.characterData\n    });\n    observers.push(observer);\n  };\n  const init = () => {\n    if (!swiper.params.observer)\n      return;\n    if (swiper.params.observeParents) {\n      const containerParents = elementParents(swiper.hostEl);\n      for (let i = 0; i < containerParents.length; i += 1) {\n        attach(containerParents[i]);\n      }\n    }\n    attach(swiper.hostEl, {\n      childList: swiper.params.observeSlideChildren\n    });\n    attach(swiper.wrapperEl, {\n      attributes: false\n    });\n  };\n  const destroy = () => {\n    observers.forEach((observer) => {\n      observer.disconnect();\n    });\n    observers.splice(0, observers.length);\n  };\n  extendParams({\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false\n  });\n  on(\"init\", init);\n  on(\"destroy\", destroy);\n}\nvar eventsEmitter = {\n  on(events2, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (typeof handler !== \"function\")\n      return self;\n    const method = priority ? \"unshift\" : \"push\";\n    events2.split(\" \").forEach((event) => {\n      if (!self.eventsListeners[event])\n        self.eventsListeners[event] = [];\n      self.eventsListeners[event][method](handler);\n    });\n    return self;\n  },\n  once(events2, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (typeof handler !== \"function\")\n      return self;\n    function onceHandler() {\n      self.off(events2, onceHandler);\n      if (onceHandler.__emitterProxy) {\n        delete onceHandler.__emitterProxy;\n      }\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      handler.apply(self, args);\n    }\n    onceHandler.__emitterProxy = handler;\n    return self.on(events2, onceHandler, priority);\n  },\n  onAny(handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (typeof handler !== \"function\")\n      return self;\n    const method = priority ? \"unshift\" : \"push\";\n    if (self.eventsAnyListeners.indexOf(handler) < 0) {\n      self.eventsAnyListeners[method](handler);\n    }\n    return self;\n  },\n  offAny(handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (!self.eventsAnyListeners)\n      return self;\n    const index2 = self.eventsAnyListeners.indexOf(handler);\n    if (index2 >= 0) {\n      self.eventsAnyListeners.splice(index2, 1);\n    }\n    return self;\n  },\n  off(events2, handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (!self.eventsListeners)\n      return self;\n    events2.split(\" \").forEach((event) => {\n      if (typeof handler === \"undefined\") {\n        self.eventsListeners[event] = [];\n      } else if (self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler, index2) => {\n          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n            self.eventsListeners[event].splice(index2, 1);\n          }\n        });\n      }\n    });\n    return self;\n  },\n  emit() {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (!self.eventsListeners)\n      return self;\n    let events2;\n    let data;\n    let context;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n      events2 = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events2 = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n    data.unshift(context);\n    const eventsArray = Array.isArray(events2) ? events2 : events2.split(\" \");\n    eventsArray.forEach((event) => {\n      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n        self.eventsAnyListeners.forEach((eventHandler) => {\n          eventHandler.apply(context, [event, ...data]);\n        });\n      }\n      if (self.eventsListeners && self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler) => {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  }\n};\nfunction updateSize() {\n  const swiper = this;\n  let width;\n  let height;\n  const el = swiper.el;\n  if (typeof swiper.params.width !== \"undefined\" && swiper.params.width !== null) {\n    width = swiper.params.width;\n  } else {\n    width = el.clientWidth;\n  }\n  if (typeof swiper.params.height !== \"undefined\" && swiper.params.height !== null) {\n    height = swiper.params.height;\n  } else {\n    height = el.clientHeight;\n  }\n  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n    return;\n  }\n  width = width - parseInt(elementStyle(el, \"padding-left\") || 0, 10) - parseInt(elementStyle(el, \"padding-right\") || 0, 10);\n  height = height - parseInt(elementStyle(el, \"padding-top\") || 0, 10) - parseInt(elementStyle(el, \"padding-bottom\") || 0, 10);\n  if (Number.isNaN(width))\n    width = 0;\n  if (Number.isNaN(height))\n    height = 0;\n  Object.assign(swiper, {\n    width,\n    height,\n    size: swiper.isHorizontal() ? width : height\n  });\n}\nfunction updateSlides() {\n  const swiper = this;\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);\n  }\n  const params = swiper.params;\n  const {\n    wrapperEl,\n    slidesEl,\n    size: swiperSize,\n    rtlTranslate: rtl,\n    wrongRTL\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === \"function\") {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === \"function\") {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index2 = 0;\n  if (typeof swiperSize === \"undefined\") {\n    return;\n  }\n  if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiperSize;\n  } else if (typeof spaceBetween === \"string\") {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n  swiper.virtualSize = -spaceBetween;\n  slides.forEach((slideEl) => {\n    if (rtl) {\n      slideEl.style.marginLeft = \"\";\n    } else {\n      slideEl.style.marginRight = \"\";\n    }\n    slideEl.style.marginBottom = \"\";\n    slideEl.style.marginTop = \"\";\n  });\n  if (params.centeredSlides && params.cssMode) {\n    setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", \"\");\n    setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", \"\");\n  }\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n  if (gridEnabled) {\n    swiper.grid.initSlides(slides);\n  } else if (swiper.grid) {\n    swiper.grid.unsetSlides();\n  }\n  let slideSize;\n  const shouldResetSlideSize = params.slidesPerView === \"auto\" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {\n    return typeof params.breakpoints[key].slidesPerView !== \"undefined\";\n  }).length > 0;\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    let slide2;\n    if (slides[i])\n      slide2 = slides[i];\n    if (gridEnabled) {\n      swiper.grid.updateSlide(i, slide2, slides);\n    }\n    if (slides[i] && elementStyle(slide2, \"display\") === \"none\")\n      continue;\n    if (params.slidesPerView === \"auto\") {\n      if (shouldResetSlideSize) {\n        slides[i].style[swiper.getDirectionLabel(\"width\")] = ``;\n      }\n      const slideStyles = getComputedStyle(slide2);\n      const currentTransform = slide2.style.transform;\n      const currentWebKitTransform = slide2.style.webkitTransform;\n      if (currentTransform) {\n        slide2.style.transform = \"none\";\n      }\n      if (currentWebKitTransform) {\n        slide2.style.webkitTransform = \"none\";\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, \"width\", true) : elementOuterSize(slide2, \"height\", true);\n      } else {\n        const width = getDirectionPropertyValue(slideStyles, \"width\");\n        const paddingLeft = getDirectionPropertyValue(slideStyles, \"padding-left\");\n        const paddingRight = getDirectionPropertyValue(slideStyles, \"padding-right\");\n        const marginLeft = getDirectionPropertyValue(slideStyles, \"margin-left\");\n        const marginRight = getDirectionPropertyValue(slideStyles, \"margin-right\");\n        const boxSizing = slideStyles.getPropertyValue(\"box-sizing\");\n        if (boxSizing && boxSizing === \"border-box\") {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const {\n            clientWidth,\n            offsetWidth\n          } = slide2;\n          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n        }\n      }\n      if (currentTransform) {\n        slide2.style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide2.style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths)\n        slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths)\n        slideSize = Math.floor(slideSize);\n      if (slides[i]) {\n        slides[i].style[swiper.getDirectionLabel(\"width\")] = `${slideSize}px`;\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0)\n        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0)\n        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1e3)\n        slidePosition = 0;\n      if (params.roundLengths)\n        slidePosition = Math.floor(slidePosition);\n      if (index2 % params.slidesPerGroup === 0)\n        snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths)\n        slidePosition = Math.floor(slidePosition);\n      if ((index2 - Math.min(swiper.params.slidesPerGroupSkip, index2)) % swiper.params.slidesPerGroup === 0)\n        snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n    swiper.virtualSize += slideSize + spaceBetween;\n    prevSlideSize = slideSize;\n    index2 += 1;\n  }\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n  if (rtl && wrongRTL && (params.effect === \"slide\" || params.effect === \"coverflow\")) {\n    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n  }\n  if (params.setWrapperSize) {\n    wrapperEl.style[swiper.getDirectionLabel(\"width\")] = `${swiper.virtualSize + spaceBetween}px`;\n  }\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid);\n  }\n  if (!params.centeredSlides) {\n    const newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths)\n        slidesGridItem = Math.floor(slidesGridItem);\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (isVirtual && params.loop) {\n    const size = slidesSizesGrid[0] + spaceBetween;\n    if (params.slidesPerGroup > 1) {\n      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n      const groupSize = size * params.slidesPerGroup;\n      for (let i = 0; i < groups; i += 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n      }\n    }\n    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n      if (params.slidesPerGroup === 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n      }\n      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n      swiper.virtualSize += size;\n    }\n  }\n  if (snapGrid.length === 0)\n    snapGrid = [0];\n  if (spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? \"marginLeft\" : swiper.getDirectionLabel(\"marginRight\");\n    slides.filter((_, slideIndex) => {\n      if (!params.cssMode || params.loop)\n        return true;\n      if (slideIndex === slides.length - 1) {\n        return false;\n      }\n      return true;\n    }).forEach((slideEl) => {\n      slideEl.style[key] = `${spaceBetween}px`;\n    });\n  }\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map((snap) => {\n      if (snap <= 0)\n        return -offsetBefore;\n      if (snap > maxSnap)\n        return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid\n  });\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", `${-snapGrid[0]}px`);\n    setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);\n  }\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit(\"slidesLengthChange\");\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow)\n      swiper.checkOverflow();\n    swiper.emit(\"snapGridLengthChange\");\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit(\"slidesGridLengthChange\");\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  swiper.emit(\"slidesUpdated\");\n  if (!isVirtual && !params.cssMode && (params.effect === \"slide\" || params.effect === \"fade\")) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded)\n        swiper.el.classList.add(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.el.classList.remove(backFaceHiddenClass);\n    }\n  }\n}\nfunction updateAutoHeight(speed) {\n  const swiper = this;\n  const activeSlides = [];\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  let newHeight = 0;\n  let i;\n  if (typeof speed === \"number\") {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n  const getSlideByIndex = (index2) => {\n    if (isVirtual) {\n      return swiper.slides[swiper.getSlideIndexByData(index2)];\n    }\n    return swiper.slides[index2];\n  };\n  if (swiper.params.slidesPerView !== \"auto\" && swiper.params.slidesPerView > 1) {\n    if (swiper.params.centeredSlides) {\n      (swiper.visibleSlides || []).forEach((slide2) => {\n        activeSlides.push(slide2);\n      });\n    } else {\n      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n        const index2 = swiper.activeIndex + i;\n        if (index2 > swiper.slides.length && !isVirtual)\n          break;\n        activeSlides.push(getSlideByIndex(index2));\n      }\n    }\n  } else {\n    activeSlides.push(getSlideByIndex(swiper.activeIndex));\n  }\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== \"undefined\") {\n      const height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n  if (newHeight || newHeight === 0)\n    swiper.wrapperEl.style.height = `${newHeight}px`;\n}\nfunction updateSlidesOffset() {\n  const swiper = this;\n  const slides = swiper.slides;\n  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n  for (let i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n  }\n}\nfunction updateSlidesProgress(translate2) {\n  if (translate2 === void 0) {\n    translate2 = this && this.translate || 0;\n  }\n  const swiper = this;\n  const params = swiper.params;\n  const {\n    slides,\n    rtlTranslate: rtl,\n    snapGrid\n  } = swiper;\n  if (slides.length === 0)\n    return;\n  if (typeof slides[0].swiperSlideOffset === \"undefined\")\n    swiper.updateSlidesOffset();\n  let offsetCenter = -translate2;\n  if (rtl)\n    offsetCenter = translate2;\n  slides.forEach((slideEl) => {\n    slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass);\n  });\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n  let spaceBetween = params.spaceBetween;\n  if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiper.size;\n  } else if (typeof spaceBetween === \"string\") {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n  for (let i = 0; i < slides.length; i += 1) {\n    const slide2 = slides[i];\n    let slideOffset = slide2.swiperSlideOffset;\n    if (params.cssMode && params.centeredSlides) {\n      slideOffset -= slides[0].swiperSlideOffset;\n    }\n    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);\n    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);\n    const slideBefore = -(offsetCenter - slideOffset);\n    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n    const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];\n    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n    if (isVisible) {\n      swiper.visibleSlides.push(slide2);\n      swiper.visibleSlidesIndexes.push(i);\n      slides[i].classList.add(params.slideVisibleClass);\n    }\n    if (isFullyVisible) {\n      slides[i].classList.add(params.slideFullyVisibleClass);\n    }\n    slide2.progress = rtl ? -slideProgress : slideProgress;\n    slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n  }\n}\nfunction updateProgress(translate2) {\n  const swiper = this;\n  if (typeof translate2 === \"undefined\") {\n    const multiplier = swiper.rtlTranslate ? -1 : 1;\n    translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;\n  }\n  const params = swiper.params;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  let {\n    progress,\n    isBeginning,\n    isEnd,\n    progressLoop\n  } = swiper;\n  const wasBeginning = isBeginning;\n  const wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate2 - swiper.minTranslate()) / translatesDiff;\n    const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;\n    const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;\n    isBeginning = isBeginningRounded || progress <= 0;\n    isEnd = isEndRounded || progress >= 1;\n    if (isBeginningRounded)\n      progress = 0;\n    if (isEndRounded)\n      progress = 1;\n  }\n  if (params.loop) {\n    const firstSlideIndex = swiper.getSlideIndexByData(0);\n    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n    const translateAbs = Math.abs(translate2);\n    if (translateAbs >= firstSlideTranslate) {\n      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n    } else {\n      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n    }\n    if (progressLoop > 1)\n      progressLoop -= 1;\n  }\n  Object.assign(swiper, {\n    progress,\n    progressLoop,\n    isBeginning,\n    isEnd\n  });\n  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)\n    swiper.updateSlidesProgress(translate2);\n  if (isBeginning && !wasBeginning) {\n    swiper.emit(\"reachBeginning toEdge\");\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit(\"reachEnd toEdge\");\n  }\n  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n    swiper.emit(\"fromEdge\");\n  }\n  swiper.emit(\"progress\", progress);\n}\nconst toggleSlideClasses = (slideEl, condition, className) => {\n  if (condition && !slideEl.classList.contains(className)) {\n    slideEl.classList.add(className);\n  } else if (!condition && slideEl.classList.contains(className)) {\n    slideEl.classList.remove(className);\n  }\n};\nfunction updateSlidesClasses() {\n  const swiper = this;\n  const {\n    slides,\n    params,\n    slidesEl,\n    activeIndex\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n  const getFilteredSlide = (selector) => {\n    return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n  };\n  let activeSlide;\n  let prevSlide;\n  let nextSlide;\n  if (isVirtual) {\n    if (params.loop) {\n      let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n      if (slideIndex < 0)\n        slideIndex = swiper.virtual.slides.length + slideIndex;\n      if (slideIndex >= swiper.virtual.slides.length)\n        slideIndex -= swiper.virtual.slides.length;\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n    } else {\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n    }\n  } else {\n    if (gridEnabled) {\n      activeSlide = slides.filter((slideEl) => slideEl.column === activeIndex)[0];\n      nextSlide = slides.filter((slideEl) => slideEl.column === activeIndex + 1)[0];\n      prevSlide = slides.filter((slideEl) => slideEl.column === activeIndex - 1)[0];\n    } else {\n      activeSlide = slides[activeIndex];\n    }\n  }\n  if (activeSlide) {\n    if (!gridEnabled) {\n      nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n      if (params.loop && !nextSlide) {\n        nextSlide = slides[0];\n      }\n      prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n      if (params.loop && !prevSlide === 0) {\n        prevSlide = slides[slides.length - 1];\n      }\n    }\n  }\n  slides.forEach((slideEl) => {\n    toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);\n    toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);\n    toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);\n  });\n  swiper.emitSlidesClasses();\n}\nconst processLazyPreloader = (swiper, imageEl) => {\n  if (!swiper || swiper.destroyed || !swiper.params)\n    return;\n  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n  const slideEl = imageEl.closest(slideSelector());\n  if (slideEl) {\n    let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n    if (!lazyEl && swiper.isElement) {\n      if (slideEl.shadowRoot) {\n        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n      } else {\n        requestAnimationFrame(() => {\n          if (slideEl.shadowRoot) {\n            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n            if (lazyEl)\n              lazyEl.remove();\n          }\n        });\n      }\n    }\n    if (lazyEl)\n      lazyEl.remove();\n  }\n};\nconst unlazy = (swiper, index2) => {\n  if (!swiper.slides[index2])\n    return;\n  const imageEl = swiper.slides[index2].querySelector('[loading=\"lazy\"]');\n  if (imageEl)\n    imageEl.removeAttribute(\"loading\");\n};\nconst preload = (swiper) => {\n  if (!swiper || swiper.destroyed || !swiper.params)\n    return;\n  let amount = swiper.params.lazyPreloadPrevNext;\n  const len = swiper.slides.length;\n  if (!len || !amount || amount < 0)\n    return;\n  amount = Math.min(amount, len);\n  const slidesPerView = swiper.params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n  const activeIndex = swiper.activeIndex;\n  if (swiper.params.grid && swiper.params.grid.rows > 1) {\n    const activeColumn = activeIndex;\n    const preloadColumns = [activeColumn - amount];\n    preloadColumns.push(...Array.from({\n      length: amount\n    }).map((_, i) => {\n      return activeColumn + slidesPerView + i;\n    }));\n    swiper.slides.forEach((slideEl, i) => {\n      if (preloadColumns.includes(slideEl.column))\n        unlazy(swiper, i);\n    });\n    return;\n  }\n  const slideIndexLastInView = activeIndex + slidesPerView - 1;\n  if (swiper.params.rewind || swiper.params.loop) {\n    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n      const realIndex = (i % len + len) % len;\n      if (realIndex < activeIndex || realIndex > slideIndexLastInView)\n        unlazy(swiper, realIndex);\n    }\n  } else {\n    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {\n      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n        unlazy(swiper, i);\n      }\n    }\n  }\n};\nfunction getActiveIndexByTranslate(swiper) {\n  const {\n    slidesGrid,\n    params\n  } = swiper;\n  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  let activeIndex;\n  for (let i = 0; i < slidesGrid.length; i += 1) {\n    if (typeof slidesGrid[i + 1] !== \"undefined\") {\n      if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n        activeIndex = i;\n      } else if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1]) {\n        activeIndex = i + 1;\n      }\n    } else if (translate2 >= slidesGrid[i]) {\n      activeIndex = i;\n    }\n  }\n  if (params.normalizeSlideIndex) {\n    if (activeIndex < 0 || typeof activeIndex === \"undefined\")\n      activeIndex = 0;\n  }\n  return activeIndex;\n}\nfunction updateActiveIndex(newActiveIndex) {\n  const swiper = this;\n  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  const {\n    snapGrid,\n    params,\n    activeIndex: previousIndex,\n    realIndex: previousRealIndex,\n    snapIndex: previousSnapIndex\n  } = swiper;\n  let activeIndex = newActiveIndex;\n  let snapIndex;\n  const getVirtualRealIndex = (aIndex) => {\n    let realIndex2 = aIndex - swiper.virtual.slidesBefore;\n    if (realIndex2 < 0) {\n      realIndex2 = swiper.virtual.slides.length + realIndex2;\n    }\n    if (realIndex2 >= swiper.virtual.slides.length) {\n      realIndex2 -= swiper.virtual.slides.length;\n    }\n    return realIndex2;\n  };\n  if (typeof activeIndex === \"undefined\") {\n    activeIndex = getActiveIndexByTranslate(swiper);\n  }\n  if (snapGrid.indexOf(translate2) >= 0) {\n    snapIndex = snapGrid.indexOf(translate2);\n  } else {\n    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length)\n    snapIndex = snapGrid.length - 1;\n  if (activeIndex === previousIndex && !swiper.params.loop) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit(\"snapIndexChange\");\n    }\n    return;\n  }\n  if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n    swiper.realIndex = getVirtualRealIndex(activeIndex);\n    return;\n  }\n  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n  let realIndex;\n  if (swiper.virtual && params.virtual.enabled && params.loop) {\n    realIndex = getVirtualRealIndex(activeIndex);\n  } else if (gridEnabled) {\n    const firstSlideInColumn = swiper.slides.filter((slideEl) => slideEl.column === activeIndex)[0];\n    let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute(\"data-swiper-slide-index\"), 10);\n    if (Number.isNaN(activeSlideIndex)) {\n      activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);\n    }\n    realIndex = Math.floor(activeSlideIndex / params.grid.rows);\n  } else if (swiper.slides[activeIndex]) {\n    const slideIndex = swiper.slides[activeIndex].getAttribute(\"data-swiper-slide-index\");\n    if (slideIndex) {\n      realIndex = parseInt(slideIndex, 10);\n    } else {\n      realIndex = activeIndex;\n    }\n  } else {\n    realIndex = activeIndex;\n  }\n  Object.assign(swiper, {\n    previousSnapIndex,\n    snapIndex,\n    previousRealIndex,\n    realIndex,\n    previousIndex,\n    activeIndex\n  });\n  if (swiper.initialized) {\n    preload(swiper);\n  }\n  swiper.emit(\"activeIndexChange\");\n  swiper.emit(\"snapIndexChange\");\n  if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n    if (previousRealIndex !== realIndex) {\n      swiper.emit(\"realIndexChange\");\n    }\n    swiper.emit(\"slideChange\");\n  }\n}\nfunction updateClickedSlide(el, path) {\n  const swiper = this;\n  const params = swiper.params;\n  let slide2 = el.closest(`.${params.slideClass}, swiper-slide`);\n  if (!slide2 && swiper.isElement && path && path.length > 1 && path.includes(el)) {\n    [...path.slice(path.indexOf(el) + 1, path.length)].forEach((pathEl) => {\n      if (!slide2 && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {\n        slide2 = pathEl;\n      }\n    });\n  }\n  let slideFound = false;\n  let slideIndex;\n  if (slide2) {\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide2) {\n        slideFound = true;\n        slideIndex = i;\n        break;\n      }\n    }\n  }\n  if (slide2 && slideFound) {\n    swiper.clickedSlide = slide2;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt(slide2.getAttribute(\"data-swiper-slide-index\"), 10);\n    } else {\n      swiper.clickedIndex = slideIndex;\n    }\n  } else {\n    swiper.clickedSlide = void 0;\n    swiper.clickedIndex = void 0;\n    return;\n  }\n  if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {\n    swiper.slideToClickedSlide();\n  }\n}\nvar update = {\n  updateSize,\n  updateSlides,\n  updateAutoHeight,\n  updateSlidesOffset,\n  updateSlidesProgress,\n  updateProgress,\n  updateSlidesClasses,\n  updateActiveIndex,\n  updateClickedSlide\n};\nfunction getSwiperTranslate(axis) {\n  if (axis === void 0) {\n    axis = this.isHorizontal() ? \"x\" : \"y\";\n  }\n  const swiper = this;\n  const {\n    params,\n    rtlTranslate: rtl,\n    translate: translate2,\n    wrapperEl\n  } = swiper;\n  if (params.virtualTranslate) {\n    return rtl ? -translate2 : translate2;\n  }\n  if (params.cssMode) {\n    return translate2;\n  }\n  let currentTranslate = getTranslate(wrapperEl, axis);\n  currentTranslate += swiper.cssOverflowAdjustment();\n  if (rtl)\n    currentTranslate = -currentTranslate;\n  return currentTranslate || 0;\n}\nfunction setTranslate(translate2, byController) {\n  const swiper = this;\n  const {\n    rtlTranslate: rtl,\n    params,\n    wrapperEl,\n    progress\n  } = swiper;\n  let x = 0;\n  let y = 0;\n  const z = 0;\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate2 : translate2;\n  } else {\n    y = translate2;\n  }\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y;\n  if (params.cssMode) {\n    wrapperEl[swiper.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = swiper.isHorizontal() ? -x : -y;\n  } else if (!params.virtualTranslate) {\n    if (swiper.isHorizontal()) {\n      x -= swiper.cssOverflowAdjustment();\n    } else {\n      y -= swiper.cssOverflowAdjustment();\n    }\n    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n  }\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate2);\n  }\n  swiper.emit(\"setTranslate\", swiper.translate, byController);\n}\nfunction minTranslate() {\n  return -this.snapGrid[0];\n}\nfunction maxTranslate() {\n  return -this.snapGrid[this.snapGrid.length - 1];\n}\nfunction translateTo(translate2, speed, runCallbacks, translateBounds, internal) {\n  if (translate2 === void 0) {\n    translate2 = 0;\n  }\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  if (translateBounds === void 0) {\n    translateBounds = true;\n  }\n  const swiper = this;\n  const {\n    params,\n    wrapperEl\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n  const minTranslate2 = swiper.minTranslate();\n  const maxTranslate2 = swiper.maxTranslate();\n  let newTranslate;\n  if (translateBounds && translate2 > minTranslate2)\n    newTranslate = minTranslate2;\n  else if (translateBounds && translate2 < maxTranslate2)\n    newTranslate = maxTranslate2;\n  else\n    newTranslate = translate2;\n  swiper.updateProgress(newTranslate);\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    if (speed === 0) {\n      wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = -newTranslate;\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: -newTranslate,\n          side: isH ? \"left\" : \"top\"\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? \"left\" : \"top\"]: -newTranslate,\n        behavior: \"smooth\"\n      });\n    }\n    return true;\n  }\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit(\"beforeTransitionStart\", speed, internal);\n      swiper.emit(\"transitionEnd\");\n    }\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit(\"beforeTransitionStart\", speed, internal);\n      swiper.emit(\"transitionStart\");\n    }\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onTranslateToWrapperTransitionEnd) {\n        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e) {\n          if (!swiper || swiper.destroyed)\n            return;\n          if (e.target !== this)\n            return;\n          swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n          swiper.onTranslateToWrapperTransitionEnd = null;\n          delete swiper.onTranslateToWrapperTransitionEnd;\n          swiper.animating = false;\n          if (runCallbacks) {\n            swiper.emit(\"transitionEnd\");\n          }\n        };\n      }\n      swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n    }\n  }\n  return true;\n}\nvar translate = {\n  getTranslate: getSwiperTranslate,\n  setTranslate,\n  minTranslate,\n  maxTranslate,\n  translateTo\n};\nfunction setTransition(duration, byController) {\n  const swiper = this;\n  if (!swiper.params.cssMode) {\n    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n    swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : \"\";\n  }\n  swiper.emit(\"setTransition\", duration, byController);\n}\nfunction transitionEmit(_ref) {\n  let {\n    swiper,\n    runCallbacks,\n    direction,\n    step\n  } = _ref;\n  const {\n    activeIndex,\n    previousIndex\n  } = swiper;\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex)\n      dir = \"next\";\n    else if (activeIndex < previousIndex)\n      dir = \"prev\";\n    else\n      dir = \"reset\";\n  }\n  swiper.emit(`transition${step}`);\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === \"reset\") {\n      swiper.emit(`slideResetTransition${step}`);\n      return;\n    }\n    swiper.emit(`slideChangeTransition${step}`);\n    if (dir === \"next\") {\n      swiper.emit(`slideNextTransition${step}`);\n    } else {\n      swiper.emit(`slidePrevTransition${step}`);\n    }\n  }\n}\nfunction transitionStart(runCallbacks, direction) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  if (params.cssMode)\n    return;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n  transitionEmit({\n    swiper,\n    runCallbacks,\n    direction,\n    step: \"Start\"\n  });\n}\nfunction transitionEnd(runCallbacks, direction) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  swiper.animating = false;\n  if (params.cssMode)\n    return;\n  swiper.setTransition(0);\n  transitionEmit({\n    swiper,\n    runCallbacks,\n    direction,\n    step: \"End\"\n  });\n}\nvar transition = {\n  setTransition,\n  transitionStart,\n  transitionEnd\n};\nfunction slideTo(index2, speed, runCallbacks, internal, initial) {\n  if (index2 === void 0) {\n    index2 = 0;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  if (typeof index2 === \"string\") {\n    index2 = parseInt(index2, 10);\n  }\n  const swiper = this;\n  let slideIndex = index2;\n  if (slideIndex < 0)\n    slideIndex = 0;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl,\n    enabled\n  } = swiper;\n  if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n  if (typeof speed === \"undefined\") {\n    speed = swiper.params.speed;\n  }\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length)\n    snapIndex = snapGrid.length - 1;\n  const translate2 = -snapGrid[snapIndex];\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      const normalizedTranslate = -Math.floor(translate2 * 100);\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n      if (typeof slidesGrid[i + 1] !== \"undefined\") {\n        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  }\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && (rtl ? translate2 > swiper.translate && translate2 > swiper.minTranslate() : translate2 < swiper.translate && translate2 < swiper.minTranslate())) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) {\n        return false;\n      }\n    }\n  }\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit(\"beforeSlideChangeStart\");\n  }\n  swiper.updateProgress(translate2);\n  let direction;\n  if (slideIndex > activeIndex)\n    direction = \"next\";\n  else if (slideIndex < activeIndex)\n    direction = \"prev\";\n  else\n    direction = \"reset\";\n  if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex);\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== \"slide\") {\n      swiper.setTranslate(translate2);\n    }\n    if (direction !== \"reset\") {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    const t = rtl ? translate2 : -translate2;\n    if (speed === 0) {\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = \"none\";\n        swiper._immediateVirtual = true;\n      }\n      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n        swiper._cssModeVirtualInitialSet = true;\n        requestAnimationFrame(() => {\n          wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n        });\n      } else {\n        wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n      }\n      if (isVirtual) {\n        requestAnimationFrame(() => {\n          swiper.wrapperEl.style.scrollSnapType = \"\";\n          swiper._immediateVirtual = false;\n        });\n      }\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: t,\n          side: isH ? \"left\" : \"top\"\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? \"left\" : \"top\"]: t,\n        behavior: \"smooth\"\n      });\n    }\n    return true;\n  }\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate2);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit(\"beforeTransitionStart\", speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e) {\n        if (!swiper || swiper.destroyed)\n          return;\n        if (e.target !== this)\n          return;\n        swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n    swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n  }\n  return true;\n}\nfunction slideToLoop(index2, speed, runCallbacks, internal) {\n  if (index2 === void 0) {\n    index2 = 0;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  if (typeof index2 === \"string\") {\n    const indexAsNumber = parseInt(index2, 10);\n    index2 = indexAsNumber;\n  }\n  const swiper = this;\n  if (swiper.destroyed)\n    return;\n  if (typeof speed === \"undefined\") {\n    speed = swiper.params.speed;\n  }\n  const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;\n  let newIndex = index2;\n  if (swiper.params.loop) {\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      newIndex = newIndex + swiper.virtual.slidesBefore;\n    } else {\n      let targetSlideIndex;\n      if (gridEnabled) {\n        const slideIndex = newIndex * swiper.params.grid.rows;\n        targetSlideIndex = swiper.slides.filter((slideEl) => slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === slideIndex)[0].column;\n      } else {\n        targetSlideIndex = swiper.getSlideIndexByData(newIndex);\n      }\n      const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;\n      const {\n        centeredSlides\n      } = swiper.params;\n      let slidesPerView = swiper.params.slidesPerView;\n      if (slidesPerView === \"auto\") {\n        slidesPerView = swiper.slidesPerViewDynamic();\n      } else {\n        slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));\n        if (centeredSlides && slidesPerView % 2 === 0) {\n          slidesPerView = slidesPerView + 1;\n        }\n      }\n      let needLoopFix = cols - targetSlideIndex < slidesPerView;\n      if (centeredSlides) {\n        needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);\n      }\n      if (internal && centeredSlides && swiper.params.slidesPerView !== \"auto\" && !gridEnabled) {\n        needLoopFix = false;\n      }\n      if (needLoopFix) {\n        const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? \"prev\" : \"next\" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? \"next\" : \"prev\";\n        swiper.loopFix({\n          direction,\n          slideTo: true,\n          activeSlideIndex: direction === \"next\" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,\n          slideRealIndex: direction === \"next\" ? swiper.realIndex : void 0\n        });\n      }\n      if (gridEnabled) {\n        const slideIndex = newIndex * swiper.params.grid.rows;\n        newIndex = swiper.slides.filter((slideEl) => slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === slideIndex)[0].column;\n      } else {\n        newIndex = swiper.getSlideIndexByData(newIndex);\n      }\n    }\n  }\n  requestAnimationFrame(() => {\n    swiper.slideTo(newIndex, speed, runCallbacks, internal);\n  });\n  return swiper;\n}\nfunction slideNext(speed, runCallbacks, internal) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  const {\n    enabled,\n    params,\n    animating\n  } = swiper;\n  if (!enabled || swiper.destroyed)\n    return swiper;\n  if (typeof speed === \"undefined\") {\n    speed = swiper.params.speed;\n  }\n  let perGroup = params.slidesPerGroup;\n  if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n    perGroup = Math.max(swiper.slidesPerViewDynamic(\"current\", true), 1);\n  }\n  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding)\n      return false;\n    swiper.loopFix({\n      direction: \"next\"\n    });\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n    if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {\n      requestAnimationFrame(() => {\n        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n      });\n      return true;\n    }\n  }\n  if (params.rewind && swiper.isEnd) {\n    return swiper.slideTo(0, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\nfunction slidePrev(speed, runCallbacks, internal) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    rtlTranslate,\n    enabled,\n    animating\n  } = swiper;\n  if (!enabled || swiper.destroyed)\n    return swiper;\n  if (typeof speed === \"undefined\") {\n    speed = swiper.params.speed;\n  }\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding)\n      return false;\n    swiper.loopFix({\n      direction: \"prev\"\n    });\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n  }\n  const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;\n  function normalize(val) {\n    if (val < 0)\n      return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n  const normalizedTranslate = normalize(translate2);\n  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));\n  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n  if (typeof prevSnap === \"undefined\" && params.cssMode) {\n    let prevSnapIndex;\n    snapGrid.forEach((snap, snapIndex) => {\n      if (normalizedTranslate >= snap) {\n        prevSnapIndex = snapIndex;\n      }\n    });\n    if (typeof prevSnapIndex !== \"undefined\") {\n      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n    }\n  }\n  let prevIndex = 0;\n  if (typeof prevSnap !== \"undefined\") {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0)\n      prevIndex = swiper.activeIndex - 1;\n    if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n      prevIndex = prevIndex - swiper.slidesPerViewDynamic(\"previous\", true) + 1;\n      prevIndex = Math.max(prevIndex, 0);\n    }\n  }\n  if (params.rewind && swiper.isBeginning) {\n    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n  } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {\n    requestAnimationFrame(() => {\n      swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n    });\n    return true;\n  }\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\nfunction slideReset(speed, runCallbacks, internal) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  if (swiper.destroyed)\n    return;\n  if (typeof speed === \"undefined\") {\n    speed = swiper.params.speed;\n  }\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\nfunction slideToClosest(speed, runCallbacks, internal, threshold) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  if (threshold === void 0) {\n    threshold = 0.5;\n  }\n  const swiper = this;\n  if (swiper.destroyed)\n    return;\n  if (typeof speed === \"undefined\") {\n    speed = swiper.params.speed;\n  }\n  let index2 = swiper.activeIndex;\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, index2);\n  const snapIndex = skip + Math.floor((index2 - skip) / swiper.params.slidesPerGroup);\n  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  if (translate2 >= swiper.snapGrid[snapIndex]) {\n    const currentSnap = swiper.snapGrid[snapIndex];\n    const nextSnap = swiper.snapGrid[snapIndex + 1];\n    if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {\n      index2 += swiper.params.slidesPerGroup;\n    }\n  } else {\n    const prevSnap = swiper.snapGrid[snapIndex - 1];\n    const currentSnap = swiper.snapGrid[snapIndex];\n    if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {\n      index2 -= swiper.params.slidesPerGroup;\n    }\n  }\n  index2 = Math.max(index2, 0);\n  index2 = Math.min(index2, swiper.slidesGrid.length - 1);\n  return swiper.slideTo(index2, speed, runCallbacks, internal);\n}\nfunction slideToClickedSlide() {\n  const swiper = this;\n  if (swiper.destroyed)\n    return;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  let slideToIndex = swiper.clickedIndex;\n  let realIndex;\n  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n  if (params.loop) {\n    if (swiper.animating)\n      return;\n    realIndex = parseInt(swiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n    if (params.centeredSlides) {\n      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n        swiper.loopFix();\n        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n        nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n      nextTick(() => {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\nvar slide = {\n  slideTo,\n  slideToLoop,\n  slideNext,\n  slidePrev,\n  slideReset,\n  slideToClosest,\n  slideToClickedSlide\n};\nfunction loopCreate(slideRealIndex) {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)\n    return;\n  const initSlides = () => {\n    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    slides.forEach((el, index2) => {\n      el.setAttribute(\"data-swiper-slide-index\", index2);\n    });\n  };\n  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n  const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);\n  const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;\n  const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;\n  const addBlankSlides = (amountOfSlides) => {\n    for (let i = 0; i < amountOfSlides; i += 1) {\n      const slideEl = swiper.isElement ? createElement(\"swiper-slide\", [params.slideBlankClass]) : createElement(\"div\", [params.slideClass, params.slideBlankClass]);\n      swiper.slidesEl.append(slideEl);\n    }\n  };\n  if (shouldFillGroup) {\n    if (params.loopAddBlankSlides) {\n      const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;\n      addBlankSlides(slidesToAdd);\n      swiper.recalcSlides();\n      swiper.updateSlides();\n    } else {\n      showWarning(\"Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)\");\n    }\n    initSlides();\n  } else if (shouldFillGrid) {\n    if (params.loopAddBlankSlides) {\n      const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;\n      addBlankSlides(slidesToAdd);\n      swiper.recalcSlides();\n      swiper.updateSlides();\n    } else {\n      showWarning(\"Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)\");\n    }\n    initSlides();\n  } else {\n    initSlides();\n  }\n  swiper.loopFix({\n    slideRealIndex,\n    direction: params.centeredSlides ? void 0 : \"next\"\n  });\n}\nfunction loopFix(_temp) {\n  let {\n    slideRealIndex,\n    slideTo: slideTo2 = true,\n    direction,\n    setTranslate: setTranslate2,\n    activeSlideIndex,\n    byController,\n    byMousewheel\n  } = _temp === void 0 ? {} : _temp;\n  const swiper = this;\n  if (!swiper.params.loop)\n    return;\n  swiper.emit(\"beforeLoopFix\");\n  const {\n    slides,\n    allowSlidePrev,\n    allowSlideNext,\n    slidesEl,\n    params\n  } = swiper;\n  const {\n    centeredSlides\n  } = params;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n  if (swiper.virtual && params.virtual.enabled) {\n    if (slideTo2) {\n      if (!params.centeredSlides && swiper.snapIndex === 0) {\n        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n      }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    swiper.emit(\"loopFix\");\n    return;\n  }\n  let slidesPerView = params.slidesPerView;\n  if (slidesPerView === \"auto\") {\n    slidesPerView = swiper.slidesPerViewDynamic();\n  } else {\n    slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));\n    if (centeredSlides && slidesPerView % 2 === 0) {\n      slidesPerView = slidesPerView + 1;\n    }\n  }\n  const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;\n  let loopedSlides = slidesPerGroup;\n  if (loopedSlides % slidesPerGroup !== 0) {\n    loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;\n  }\n  loopedSlides += params.loopAdditionalSlides;\n  swiper.loopedSlides = loopedSlides;\n  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n  if (slides.length < slidesPerView + loopedSlides) {\n    showWarning(\"Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters\");\n  } else if (gridEnabled && params.grid.fill === \"row\") {\n    showWarning(\"Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`\");\n  }\n  const prependSlidesIndexes = [];\n  const appendSlidesIndexes = [];\n  let activeIndex = swiper.activeIndex;\n  if (typeof activeSlideIndex === \"undefined\") {\n    activeSlideIndex = swiper.getSlideIndex(slides.filter((el) => el.classList.contains(params.slideActiveClass))[0]);\n  } else {\n    activeIndex = activeSlideIndex;\n  }\n  const isNext = direction === \"next\" || !direction;\n  const isPrev = direction === \"prev\" || !direction;\n  let slidesPrepended = 0;\n  let slidesAppended = 0;\n  const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;\n  const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;\n  const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate2 === \"undefined\" ? -slidesPerView / 2 + 0.5 : 0);\n  if (activeColIndexWithShift < loopedSlides) {\n    slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);\n    for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {\n      const index2 = i - Math.floor(i / cols) * cols;\n      if (gridEnabled) {\n        const colIndexToPrepend = cols - index2 - 1;\n        for (let i2 = slides.length - 1; i2 >= 0; i2 -= 1) {\n          if (slides[i2].column === colIndexToPrepend)\n            prependSlidesIndexes.push(i2);\n        }\n      } else {\n        prependSlidesIndexes.push(cols - index2 - 1);\n      }\n    }\n  } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {\n    slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);\n    for (let i = 0; i < slidesAppended; i += 1) {\n      const index2 = i - Math.floor(i / cols) * cols;\n      if (gridEnabled) {\n        slides.forEach((slide2, slideIndex) => {\n          if (slide2.column === index2)\n            appendSlidesIndexes.push(slideIndex);\n        });\n      } else {\n        appendSlidesIndexes.push(index2);\n      }\n    }\n  }\n  swiper.__preventObserver__ = true;\n  requestAnimationFrame(() => {\n    swiper.__preventObserver__ = false;\n  });\n  if (isPrev) {\n    prependSlidesIndexes.forEach((index2) => {\n      slides[index2].swiperLoopMoveDOM = true;\n      slidesEl.prepend(slides[index2]);\n      slides[index2].swiperLoopMoveDOM = false;\n    });\n  }\n  if (isNext) {\n    appendSlidesIndexes.forEach((index2) => {\n      slides[index2].swiperLoopMoveDOM = true;\n      slidesEl.append(slides[index2]);\n      slides[index2].swiperLoopMoveDOM = false;\n    });\n  }\n  swiper.recalcSlides();\n  if (params.slidesPerView === \"auto\") {\n    swiper.updateSlides();\n  } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {\n    swiper.slides.forEach((slide2, slideIndex) => {\n      swiper.grid.updateSlide(slideIndex, slide2, swiper.slides);\n    });\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  if (slideTo2) {\n    if (prependSlidesIndexes.length > 0 && isPrev) {\n      if (typeof slideRealIndex === \"undefined\") {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);\n          if (setTranslate2) {\n            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n          }\n        }\n      } else {\n        if (setTranslate2) {\n          const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;\n          swiper.slideTo(swiper.activeIndex + shift, 0, false, true);\n          swiper.touchEventsData.currentTranslate = swiper.translate;\n        }\n      }\n    } else if (appendSlidesIndexes.length > 0 && isNext) {\n      if (typeof slideRealIndex === \"undefined\") {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n          if (setTranslate2) {\n            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n          }\n        }\n      } else {\n        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;\n        swiper.slideTo(swiper.activeIndex - shift, 0, false, true);\n      }\n    }\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.controller && swiper.controller.control && !byController) {\n    const loopParams = {\n      slideRealIndex,\n      direction,\n      setTranslate: setTranslate2,\n      activeSlideIndex,\n      byController: true\n    };\n    if (Array.isArray(swiper.controller.control)) {\n      swiper.controller.control.forEach((c) => {\n        if (!c.destroyed && c.params.loop)\n          c.loopFix({\n            ...loopParams,\n            slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo2 : false\n          });\n      });\n    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n      swiper.controller.control.loopFix({\n        ...loopParams,\n        slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false\n      });\n    }\n  }\n  swiper.emit(\"loopFix\");\n}\nfunction loopDestroy() {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)\n    return;\n  swiper.recalcSlides();\n  const newSlidesOrder = [];\n  swiper.slides.forEach((slideEl) => {\n    const index2 = typeof slideEl.swiperSlideIndex === \"undefined\" ? slideEl.getAttribute(\"data-swiper-slide-index\") * 1 : slideEl.swiperSlideIndex;\n    newSlidesOrder[index2] = slideEl;\n  });\n  swiper.slides.forEach((slideEl) => {\n    slideEl.removeAttribute(\"data-swiper-slide-index\");\n  });\n  newSlidesOrder.forEach((slideEl) => {\n    slidesEl.append(slideEl);\n  });\n  swiper.recalcSlides();\n  swiper.slideTo(swiper.realIndex, 0);\n}\nvar loop = {\n  loopCreate,\n  loopFix,\n  loopDestroy\n};\nfunction setGrabCursor(moving) {\n  const swiper = this;\n  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)\n    return;\n  const el = swiper.params.touchEventsTarget === \"container\" ? swiper.el : swiper.wrapperEl;\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  el.style.cursor = \"move\";\n  el.style.cursor = moving ? \"grabbing\" : \"grab\";\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\nfunction unsetGrabCursor() {\n  const swiper = this;\n  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n    return;\n  }\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  swiper[swiper.params.touchEventsTarget === \"container\" ? \"el\" : \"wrapperEl\"].style.cursor = \"\";\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\nvar grabCursor = {\n  setGrabCursor,\n  unsetGrabCursor\n};\nfunction closestElement(selector, base) {\n  if (base === void 0) {\n    base = this;\n  }\n  function __closestFrom(el) {\n    if (!el || el === getDocument() || el === getWindow())\n      return null;\n    if (el.assignedSlot)\n      el = el.assignedSlot;\n    const found = el.closest(selector);\n    if (!found && !el.getRootNode) {\n      return null;\n    }\n    return found || __closestFrom(el.getRootNode().host);\n  }\n  return __closestFrom(base);\n}\nfunction preventEdgeSwipe(swiper, event, startX) {\n  const window2 = getWindow();\n  const {\n    params\n  } = swiper;\n  const edgeSwipeDetection = params.edgeSwipeDetection;\n  const edgeSwipeThreshold = params.edgeSwipeThreshold;\n  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {\n    if (edgeSwipeDetection === \"prevent\") {\n      event.preventDefault();\n      return true;\n    }\n    return false;\n  }\n  return true;\n}\nfunction onTouchStart(event) {\n  const swiper = this;\n  const document2 = getDocument();\n  let e = event;\n  if (e.originalEvent)\n    e = e.originalEvent;\n  const data = swiper.touchEventsData;\n  if (e.type === \"pointerdown\") {\n    if (data.pointerId !== null && data.pointerId !== e.pointerId) {\n      return;\n    }\n    data.pointerId = e.pointerId;\n  } else if (e.type === \"touchstart\" && e.targetTouches.length === 1) {\n    data.touchId = e.targetTouches[0].identifier;\n  }\n  if (e.type === \"touchstart\") {\n    preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);\n    return;\n  }\n  const {\n    params,\n    touches,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return;\n  if (!params.simulateTouch && e.pointerType === \"mouse\")\n    return;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n  if (!swiper.animating && params.cssMode && params.loop) {\n    swiper.loopFix();\n  }\n  let targetEl = e.target;\n  if (params.touchEventsTarget === \"wrapper\") {\n    if (!swiper.wrapperEl.contains(targetEl))\n      return;\n  }\n  if (\"which\" in e && e.which === 3)\n    return;\n  if (\"button\" in e && e.button > 0)\n    return;\n  if (data.isTouched && data.isMoved)\n    return;\n  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== \"\";\n  const eventPath = e.composedPath ? e.composedPath() : e.path;\n  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n    targetEl = eventPath[0];\n  }\n  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n  const isTargetShadow = !!(e.target && e.target.shadowRoot);\n  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n    swiper.allowClick = true;\n    return;\n  }\n  if (params.swipeHandler) {\n    if (!targetEl.closest(params.swipeHandler))\n      return;\n  }\n  touches.currentX = e.pageX;\n  touches.currentY = e.pageY;\n  const startX = touches.currentX;\n  const startY = touches.currentY;\n  if (!preventEdgeSwipe(swiper, e, startX)) {\n    return;\n  }\n  Object.assign(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: void 0,\n    startMoving: void 0\n  });\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = now();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = void 0;\n  if (params.threshold > 0)\n    data.allowThresholdMove = false;\n  let preventDefault = true;\n  if (targetEl.matches(data.focusableElements)) {\n    preventDefault = false;\n    if (targetEl.nodeName === \"SELECT\") {\n      data.isTouched = false;\n    }\n  }\n  if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl) {\n    document2.activeElement.blur();\n  }\n  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n    e.preventDefault();\n  }\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n    swiper.freeMode.onTouchStart();\n  }\n  swiper.emit(\"touchStart\", e);\n}\nfunction onTouchMove(event) {\n  const document2 = getDocument();\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return;\n  if (!params.simulateTouch && event.pointerType === \"mouse\")\n    return;\n  let e = event;\n  if (e.originalEvent)\n    e = e.originalEvent;\n  if (e.type === \"pointermove\") {\n    if (data.touchId !== null)\n      return;\n    const id = e.pointerId;\n    if (id !== data.pointerId)\n      return;\n  }\n  let targetTouch;\n  if (e.type === \"touchmove\") {\n    targetTouch = [...e.changedTouches].filter((t) => t.identifier === data.touchId)[0];\n    if (!targetTouch || targetTouch.identifier !== data.touchId)\n      return;\n  } else {\n    targetTouch = e;\n  }\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit(\"touchMoveOpposite\", e);\n    }\n    return;\n  }\n  const pageX = targetTouch.pageX;\n  const pageY = targetTouch.pageY;\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    if (!e.target.matches(data.focusableElements)) {\n      swiper.allowClick = false;\n    }\n    if (data.isTouched) {\n      Object.assign(touches, {\n        startX: pageX,\n        startY: pageY,\n        currentX: pageX,\n        currentY: pageY\n      });\n      data.touchStartTime = now();\n    }\n    return;\n  }\n  if (params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n      return;\n    }\n  }\n  if (document2.activeElement) {\n    if (e.target === document2.activeElement && e.target.matches(data.focusableElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit(\"touchMove\", e);\n  }\n  touches.previousX = touches.currentX;\n  touches.previousY = touches.currentY;\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n  const diffX = touches.currentX - touches.startX;\n  const diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)\n    return;\n  if (typeof data.isScrolling === \"undefined\") {\n    let touchAngle;\n    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n      data.isScrolling = false;\n    } else {\n      if (diffX * diffX + diffY * diffY >= 25) {\n        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit(\"touchMoveOpposite\", e);\n  }\n  if (typeof data.startMoving === \"undefined\") {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (data.isScrolling) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  if (!params.cssMode && e.cancelable) {\n    e.preventDefault();\n  }\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n  let diff = swiper.isHorizontal() ? diffX : diffY;\n  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n  if (params.oneWayMovement) {\n    diff = Math.abs(diff) * (rtl ? 1 : -1);\n    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n  }\n  touches.diff = diff;\n  diff *= params.touchRatio;\n  if (rtl) {\n    diff = -diff;\n    touchesDiff = -touchesDiff;\n  }\n  const prevTouchesDirection = swiper.touchesDirection;\n  swiper.swipeDirection = diff > 0 ? \"prev\" : \"next\";\n  swiper.touchesDirection = touchesDiff > 0 ? \"prev\" : \"next\";\n  const isLoop = swiper.params.loop && !params.cssMode;\n  const allowLoopFix = swiper.touchesDirection === \"next\" && swiper.allowSlideNext || swiper.touchesDirection === \"prev\" && swiper.allowSlidePrev;\n  if (!data.isMoved) {\n    if (isLoop && allowLoopFix) {\n      swiper.loopFix({\n        direction: swiper.swipeDirection\n      });\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      const evt = new window.CustomEvent(\"transitionend\", {\n        bubbles: true,\n        cancelable: true\n      });\n      swiper.wrapperEl.dispatchEvent(evt);\n    }\n    data.allowMomentumBounce = false;\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit(\"sliderFirstMove\", e);\n  }\n  let loopFixed;\n  (/* @__PURE__ */ new Date()).getTime();\n  if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {\n    Object.assign(touches, {\n      startX: pageX,\n      startY: pageY,\n      currentX: pageX,\n      currentY: pageY,\n      startTranslate: data.currentTranslate\n    });\n    data.loopSwapReset = true;\n    data.startTranslate = data.currentTranslate;\n    return;\n  }\n  swiper.emit(\"sliderMove\", e);\n  data.isMoved = true;\n  data.currentTranslate = diff + data.startTranslate;\n  let disableParentSwiper = true;\n  let resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if (diff > 0) {\n    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) {\n      swiper.loopFix({\n        direction: \"prev\",\n        setTranslate: true,\n        activeSlideIndex: 0\n      });\n    }\n    if (data.currentTranslate > swiper.minTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n      }\n    }\n  } else if (diff < 0) {\n    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) {\n      swiper.loopFix({\n        direction: \"next\",\n        setTranslate: true,\n        activeSlideIndex: swiper.slides.length - (params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n      });\n    }\n    if (data.currentTranslate < swiper.maxTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n      }\n    }\n  }\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n  if (!swiper.allowSlideNext && swiper.swipeDirection === \"next\" && data.currentTranslate < data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && swiper.swipeDirection === \"prev\" && data.currentTranslate > data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n  if (!params.followFinger || params.cssMode)\n    return;\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n    swiper.freeMode.onTouchMove();\n  }\n  swiper.updateProgress(data.currentTranslate);\n  swiper.setTranslate(data.currentTranslate);\n}\nfunction onTouchEnd(event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  let e = event;\n  if (e.originalEvent)\n    e = e.originalEvent;\n  let targetTouch;\n  const isTouchEvent = e.type === \"touchend\" || e.type === \"touchcancel\";\n  if (!isTouchEvent) {\n    if (data.touchId !== null)\n      return;\n    if (e.pointerId !== data.pointerId)\n      return;\n    targetTouch = e;\n  } else {\n    targetTouch = [...e.changedTouches].filter((t) => t.identifier === data.touchId)[0];\n    if (!targetTouch || targetTouch.identifier !== data.touchId)\n      return;\n  }\n  if ([\"pointercancel\", \"pointerout\", \"pointerleave\", \"contextmenu\"].includes(e.type)) {\n    const proceed = [\"pointercancel\", \"contextmenu\"].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);\n    if (!proceed) {\n      return;\n    }\n  }\n  data.pointerId = null;\n  data.touchId = null;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    slidesGrid,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return;\n  if (!params.simulateTouch && e.pointerType === \"mouse\")\n    return;\n  if (data.allowTouchCallbacks) {\n    swiper.emit(\"touchEnd\", e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  }\n  const touchEndTime = now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n  if (swiper.allowClick) {\n    const pathTree = e.path || e.composedPath && e.composedPath();\n    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);\n    swiper.emit(\"tap click\", e);\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit(\"doubleTap doubleClick\", e);\n    }\n  }\n  data.lastClickTime = now();\n  nextTick(() => {\n    if (!swiper.destroyed)\n      swiper.allowClick = true;\n  });\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n  if (params.cssMode) {\n    return;\n  }\n  if (params.freeMode && params.freeMode.enabled) {\n    swiper.freeMode.onTouchEnd({\n      currentPos\n    });\n    return;\n  }\n  const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (typeof slidesGrid[i + increment2] !== \"undefined\") {\n      if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment2] - slidesGrid[i];\n      }\n    } else if (swipeToLast || currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n  let rewindFirstIndex = null;\n  let rewindLastIndex = null;\n  if (params.rewind) {\n    if (swiper.isBeginning) {\n      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    } else if (swiper.isEnd) {\n      rewindFirstIndex = 0;\n    }\n  }\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n  if (timeDiff > params.longSwipesMs) {\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === \"next\") {\n      if (ratio >= params.longSwipesRatio)\n        swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n      else\n        swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === \"prev\") {\n      if (ratio > 1 - params.longSwipesRatio) {\n        swiper.slideTo(stopIndex + increment);\n      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n        swiper.slideTo(rewindLastIndex);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  } else {\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === \"next\") {\n        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n      }\n      if (swiper.swipeDirection === \"prev\") {\n        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\nfunction onResize() {\n  const swiper = this;\n  const {\n    params,\n    el\n  } = swiper;\n  if (el && el.offsetWidth === 0)\n    return;\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n  const {\n    allowSlideNext,\n    allowSlidePrev,\n    snapGrid\n  } = swiper;\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n  swiper.updateSize();\n  swiper.updateSlides();\n  swiper.updateSlidesClasses();\n  const isVirtualLoop = isVirtual && params.loop;\n  if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n    swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n  } else {\n    if (swiper.params.loop && !isVirtual) {\n      swiper.slideToLoop(swiper.realIndex, 0, false, true);\n    } else {\n      swiper.slideTo(swiper.activeIndex, 0, false, true);\n    }\n  }\n  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n    clearTimeout(swiper.autoplay.resizeTimeout);\n    swiper.autoplay.resizeTimeout = setTimeout(() => {\n      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        swiper.autoplay.resume();\n      }\n    }, 500);\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\nfunction onClick(e) {\n  const swiper = this;\n  if (!swiper.enabled)\n    return;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks)\n      e.preventDefault();\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\nfunction onScroll() {\n  const swiper = this;\n  const {\n    wrapperEl,\n    rtlTranslate,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return;\n  swiper.previousTranslate = swiper.translate;\n  if (swiper.isHorizontal()) {\n    swiper.translate = -wrapperEl.scrollLeft;\n  } else {\n    swiper.translate = -wrapperEl.scrollTop;\n  }\n  if (swiper.translate === 0)\n    swiper.translate = 0;\n  swiper.updateActiveIndex();\n  swiper.updateSlidesClasses();\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== swiper.progress) {\n    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n  }\n  swiper.emit(\"setTranslate\", swiper.translate, false);\n}\nfunction onLoad(e) {\n  const swiper = this;\n  processLazyPreloader(swiper, e.target);\n  if (swiper.params.cssMode || swiper.params.slidesPerView !== \"auto\" && !swiper.params.autoHeight) {\n    return;\n  }\n  swiper.update();\n}\nfunction onDocumentTouchStart() {\n  const swiper = this;\n  if (swiper.documentTouchHandlerProceeded)\n    return;\n  swiper.documentTouchHandlerProceeded = true;\n  if (swiper.params.touchReleaseOnEdges) {\n    swiper.el.style.touchAction = \"auto\";\n  }\n}\nconst events = (swiper, method) => {\n  const document2 = getDocument();\n  const {\n    params,\n    el,\n    wrapperEl,\n    device\n  } = swiper;\n  const capture = !!params.nested;\n  const domMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n  const swiperMethod = method;\n  document2[domMethod](\"touchstart\", swiper.onDocumentTouchStart, {\n    passive: false,\n    capture\n  });\n  el[domMethod](\"touchstart\", swiper.onTouchStart, {\n    passive: false\n  });\n  el[domMethod](\"pointerdown\", swiper.onTouchStart, {\n    passive: false\n  });\n  document2[domMethod](\"touchmove\", swiper.onTouchMove, {\n    passive: false,\n    capture\n  });\n  document2[domMethod](\"pointermove\", swiper.onTouchMove, {\n    passive: false,\n    capture\n  });\n  document2[domMethod](\"touchend\", swiper.onTouchEnd, {\n    passive: true\n  });\n  document2[domMethod](\"pointerup\", swiper.onTouchEnd, {\n    passive: true\n  });\n  document2[domMethod](\"pointercancel\", swiper.onTouchEnd, {\n    passive: true\n  });\n  document2[domMethod](\"touchcancel\", swiper.onTouchEnd, {\n    passive: true\n  });\n  document2[domMethod](\"pointerout\", swiper.onTouchEnd, {\n    passive: true\n  });\n  document2[domMethod](\"pointerleave\", swiper.onTouchEnd, {\n    passive: true\n  });\n  document2[domMethod](\"contextmenu\", swiper.onTouchEnd, {\n    passive: true\n  });\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el[domMethod](\"click\", swiper.onClick, true);\n  }\n  if (params.cssMode) {\n    wrapperEl[domMethod](\"scroll\", swiper.onScroll);\n  }\n  if (params.updateOnWindowResize) {\n    swiper[swiperMethod](device.ios || device.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", onResize, true);\n  } else {\n    swiper[swiperMethod](\"observerUpdate\", onResize, true);\n  }\n  el[domMethod](\"load\", swiper.onLoad, {\n    capture: true\n  });\n};\nfunction attachEvents() {\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  swiper.onTouchStart = onTouchStart.bind(swiper);\n  swiper.onTouchMove = onTouchMove.bind(swiper);\n  swiper.onTouchEnd = onTouchEnd.bind(swiper);\n  swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);\n  if (params.cssMode) {\n    swiper.onScroll = onScroll.bind(swiper);\n  }\n  swiper.onClick = onClick.bind(swiper);\n  swiper.onLoad = onLoad.bind(swiper);\n  events(swiper, \"on\");\n}\nfunction detachEvents() {\n  const swiper = this;\n  events(swiper, \"off\");\n}\nvar events$1 = {\n  attachEvents,\n  detachEvents\n};\nconst isGridEnabled = (swiper, params) => {\n  return swiper.grid && params.grid && params.grid.rows > 1;\n};\nfunction setBreakpoint() {\n  const swiper = this;\n  const {\n    realIndex,\n    initialized,\n    params,\n    el\n  } = swiper;\n  const breakpoints2 = params.breakpoints;\n  if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)\n    return;\n  const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);\n  if (!breakpoint || swiper.currentBreakpoint === breakpoint)\n    return;\n  const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;\n  const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n  const wasMultiRow = isGridEnabled(swiper, params);\n  const isMultiRow = isGridEnabled(swiper, breakpointParams);\n  const wasGrabCursor = swiper.params.grabCursor;\n  const isGrabCursor = breakpointParams.grabCursor;\n  const wasEnabled = params.enabled;\n  if (wasMultiRow && !isMultiRow) {\n    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n    swiper.emitContainerClasses();\n  } else if (!wasMultiRow && isMultiRow) {\n    el.classList.add(`${params.containerModifierClass}grid`);\n    if (breakpointParams.grid.fill && breakpointParams.grid.fill === \"column\" || !breakpointParams.grid.fill && params.grid.fill === \"column\") {\n      el.classList.add(`${params.containerModifierClass}grid-column`);\n    }\n    swiper.emitContainerClasses();\n  }\n  if (wasGrabCursor && !isGrabCursor) {\n    swiper.unsetGrabCursor();\n  } else if (!wasGrabCursor && isGrabCursor) {\n    swiper.setGrabCursor();\n  }\n  [\"navigation\", \"pagination\", \"scrollbar\"].forEach((prop) => {\n    if (typeof breakpointParams[prop] === \"undefined\")\n      return;\n    const wasModuleEnabled = params[prop] && params[prop].enabled;\n    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n    if (wasModuleEnabled && !isModuleEnabled) {\n      swiper[prop].disable();\n    }\n    if (!wasModuleEnabled && isModuleEnabled) {\n      swiper[prop].enable();\n    }\n  });\n  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n  const wasLoop = params.loop;\n  if (directionChanged && initialized) {\n    swiper.changeDirection();\n  }\n  extend(swiper.params, breakpointParams);\n  const isEnabled = swiper.params.enabled;\n  const hasLoop = swiper.params.loop;\n  Object.assign(swiper, {\n    allowTouchMove: swiper.params.allowTouchMove,\n    allowSlideNext: swiper.params.allowSlideNext,\n    allowSlidePrev: swiper.params.allowSlidePrev\n  });\n  if (wasEnabled && !isEnabled) {\n    swiper.disable();\n  } else if (!wasEnabled && isEnabled) {\n    swiper.enable();\n  }\n  swiper.currentBreakpoint = breakpoint;\n  swiper.emit(\"_beforeBreakpoint\", breakpointParams);\n  if (initialized) {\n    if (needsReLoop) {\n      swiper.loopDestroy();\n      swiper.loopCreate(realIndex);\n      swiper.updateSlides();\n    } else if (!wasLoop && hasLoop) {\n      swiper.loopCreate(realIndex);\n      swiper.updateSlides();\n    } else if (wasLoop && !hasLoop) {\n      swiper.loopDestroy();\n    }\n  }\n  swiper.emit(\"breakpoint\", breakpointParams);\n}\nfunction getBreakpoint(breakpoints2, base, containerEl) {\n  if (base === void 0) {\n    base = \"window\";\n  }\n  if (!breakpoints2 || base === \"container\" && !containerEl)\n    return void 0;\n  let breakpoint = false;\n  const window2 = getWindow();\n  const currentHeight = base === \"window\" ? window2.innerHeight : containerEl.clientHeight;\n  const points = Object.keys(breakpoints2).map((point) => {\n    if (typeof point === \"string\" && point.indexOf(\"@\") === 0) {\n      const minRatio = parseFloat(point.substr(1));\n      const value = currentHeight * minRatio;\n      return {\n        value,\n        point\n      };\n    }\n    return {\n      value: point,\n      point\n    };\n  });\n  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n  for (let i = 0; i < points.length; i += 1) {\n    const {\n      point,\n      value\n    } = points[i];\n    if (base === \"window\") {\n      if (window2.matchMedia(`(min-width: ${value}px)`).matches) {\n        breakpoint = point;\n      }\n    } else if (value <= containerEl.clientWidth) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || \"max\";\n}\nvar breakpoints = {\n  setBreakpoint,\n  getBreakpoint\n};\nfunction prepareClasses(entries, prefix) {\n  const resultClasses = [];\n  entries.forEach((item) => {\n    if (typeof item === \"object\") {\n      Object.keys(item).forEach((classNames) => {\n        if (item[classNames]) {\n          resultClasses.push(prefix + classNames);\n        }\n      });\n    } else if (typeof item === \"string\") {\n      resultClasses.push(prefix + item);\n    }\n  });\n  return resultClasses;\n}\nfunction addClasses() {\n  const swiper = this;\n  const {\n    classNames,\n    params,\n    rtl,\n    el,\n    device\n  } = swiper;\n  const suffixes = prepareClasses([\"initialized\", params.direction, {\n    \"free-mode\": swiper.params.freeMode && params.freeMode.enabled\n  }, {\n    \"autoheight\": params.autoHeight\n  }, {\n    \"rtl\": rtl\n  }, {\n    \"grid\": params.grid && params.grid.rows > 1\n  }, {\n    \"grid-column\": params.grid && params.grid.rows > 1 && params.grid.fill === \"column\"\n  }, {\n    \"android\": device.android\n  }, {\n    \"ios\": device.ios\n  }, {\n    \"css-mode\": params.cssMode\n  }, {\n    \"centered\": params.cssMode && params.centeredSlides\n  }, {\n    \"watch-progress\": params.watchSlidesProgress\n  }], params.containerModifierClass);\n  classNames.push(...suffixes);\n  el.classList.add(...classNames);\n  swiper.emitContainerClasses();\n}\nfunction removeClasses() {\n  const swiper = this;\n  const {\n    el,\n    classNames\n  } = swiper;\n  el.classList.remove(...classNames);\n  swiper.emitContainerClasses();\n}\nvar classes = {\n  addClasses,\n  removeClasses\n};\nfunction checkOverflow() {\n  const swiper = this;\n  const {\n    isLocked: wasLocked,\n    params\n  } = swiper;\n  const {\n    slidesOffsetBefore\n  } = params;\n  if (slidesOffsetBefore) {\n    const lastSlideIndex = swiper.slides.length - 1;\n    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n    swiper.isLocked = swiper.size > lastSlideRightEdge;\n  } else {\n    swiper.isLocked = swiper.snapGrid.length === 1;\n  }\n  if (params.allowSlideNext === true) {\n    swiper.allowSlideNext = !swiper.isLocked;\n  }\n  if (params.allowSlidePrev === true) {\n    swiper.allowSlidePrev = !swiper.isLocked;\n  }\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n  }\n  if (wasLocked !== swiper.isLocked) {\n    swiper.emit(swiper.isLocked ? \"lock\" : \"unlock\");\n  }\n}\nvar checkOverflow$1 = {\n  checkOverflow\n};\nvar defaults = {\n  init: true,\n  direction: \"horizontal\",\n  oneWayMovement: false,\n  swiperElementNodeName: \"SWIPER-CONTAINER\",\n  touchEventsTarget: \"wrapper\",\n  initialSlide: 0,\n  speed: 300,\n  cssMode: false,\n  updateOnWindowResize: true,\n  resizeObserver: true,\n  nested: false,\n  createElements: false,\n  eventsPrefix: \"swiper\",\n  enabled: true,\n  focusableElements: \"input, select, option, textarea, button, video, label\",\n  // Overrides\n  width: null,\n  height: null,\n  //\n  preventInteractionOnTransition: false,\n  // ssr\n  userAgent: null,\n  url: null,\n  // To support iOS's swipe-to-go-back gesture (when being used in-app).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n  // Autoheight\n  autoHeight: false,\n  // Set wrapper width\n  setWrapperSize: false,\n  // Virtual Translate\n  virtualTranslate: false,\n  // Effects\n  effect: \"slide\",\n  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n  // Breakpoints\n  breakpoints: void 0,\n  breakpointsBase: \"window\",\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerGroup: 1,\n  slidesPerGroupSkip: 0,\n  slidesPerGroupAuto: false,\n  centeredSlides: false,\n  centeredSlidesBounds: false,\n  slidesOffsetBefore: 0,\n  // in px\n  slidesOffsetAfter: 0,\n  // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: true,\n  // Round length\n  roundLengths: false,\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 5,\n  touchMoveStopPropagation: false,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n  // Progress\n  watchSlidesProgress: false,\n  // Cursor\n  grabCursor: false,\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n  // loop\n  loop: false,\n  loopAddBlankSlides: true,\n  loopAdditionalSlides: 0,\n  loopPreventsSliding: true,\n  // rewind\n  rewind: false,\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null,\n  // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: \"swiper-no-swiping\",\n  noSwipingSelector: null,\n  // Passive Listeners\n  passiveListeners: true,\n  maxBackfaceHiddenSlides: 10,\n  // NS\n  containerModifierClass: \"swiper-\",\n  // NEW\n  slideClass: \"swiper-slide\",\n  slideBlankClass: \"swiper-slide-blank\",\n  slideActiveClass: \"swiper-slide-active\",\n  slideVisibleClass: \"swiper-slide-visible\",\n  slideFullyVisibleClass: \"swiper-slide-fully-visible\",\n  slideNextClass: \"swiper-slide-next\",\n  slidePrevClass: \"swiper-slide-prev\",\n  wrapperClass: \"swiper-wrapper\",\n  lazyPreloaderClass: \"swiper-lazy-preloader\",\n  lazyPreloadPrevNext: 0,\n  // Callbacks\n  runCallbacksOnInit: true,\n  // Internals\n  _emitClasses: false\n};\nfunction moduleExtendParams(params, allModulesParams) {\n  return function extendParams(obj) {\n    if (obj === void 0) {\n      obj = {};\n    }\n    const moduleParamName = Object.keys(obj)[0];\n    const moduleParams = obj[moduleParamName];\n    if (typeof moduleParams !== \"object\" || moduleParams === null) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if (params[moduleParamName] === true) {\n      params[moduleParamName] = {\n        enabled: true\n      };\n    }\n    if (moduleParamName === \"navigation\" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {\n      params[moduleParamName].auto = true;\n    }\n    if ([\"pagination\", \"scrollbar\"].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {\n      params[moduleParamName].auto = true;\n    }\n    if (!(moduleParamName in params && \"enabled\" in moduleParams)) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if (typeof params[moduleParamName] === \"object\" && !(\"enabled\" in params[moduleParamName])) {\n      params[moduleParamName].enabled = true;\n    }\n    if (!params[moduleParamName])\n      params[moduleParamName] = {\n        enabled: false\n      };\n    extend(allModulesParams, obj);\n  };\n}\nconst prototypes = {\n  eventsEmitter,\n  update,\n  translate,\n  transition,\n  slide,\n  loop,\n  grabCursor,\n  events: events$1,\n  breakpoints,\n  checkOverflow: checkOverflow$1,\n  classes\n};\nconst extendedDefaults = {};\nclass Swiper {\n  constructor() {\n    let el;\n    let params;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === \"Object\") {\n      params = args[0];\n    } else {\n      [el, params] = args;\n    }\n    if (!params)\n      params = {};\n    params = extend({}, params);\n    if (el && !params.el)\n      params.el = el;\n    const document2 = getDocument();\n    if (params.el && typeof params.el === \"string\" && document2.querySelectorAll(params.el).length > 1) {\n      const swipers = [];\n      document2.querySelectorAll(params.el).forEach((containerEl) => {\n        const newParams = extend({}, params, {\n          el: containerEl\n        });\n        swipers.push(new Swiper(newParams));\n      });\n      return swipers;\n    }\n    const swiper = this;\n    swiper.__swiper__ = true;\n    swiper.support = getSupport();\n    swiper.device = getDevice({\n      userAgent: params.userAgent\n    });\n    swiper.browser = getBrowser();\n    swiper.eventsListeners = {};\n    swiper.eventsAnyListeners = [];\n    swiper.modules = [...swiper.__modules__];\n    if (params.modules && Array.isArray(params.modules)) {\n      swiper.modules.push(...params.modules);\n    }\n    const allModulesParams = {};\n    swiper.modules.forEach((mod) => {\n      mod({\n        params,\n        swiper,\n        extendParams: moduleExtendParams(params, allModulesParams),\n        on: swiper.on.bind(swiper),\n        once: swiper.once.bind(swiper),\n        off: swiper.off.bind(swiper),\n        emit: swiper.emit.bind(swiper)\n      });\n    });\n    const swiperParams = extend({}, defaults, allModulesParams);\n    swiper.params = extend({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = extend({}, swiper.params);\n    swiper.passedParams = extend({}, params);\n    if (swiper.params && swiper.params.on) {\n      Object.keys(swiper.params.on).forEach((eventName) => {\n        swiper.on(eventName, swiper.params.on[eventName]);\n      });\n    }\n    if (swiper.params && swiper.params.onAny) {\n      swiper.onAny(swiper.params.onAny);\n    }\n    Object.assign(swiper, {\n      enabled: swiper.params.enabled,\n      el,\n      // Classes\n      classNames: [],\n      // Slides\n      slides: [],\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n      // isDirection\n      isHorizontal() {\n        return swiper.params.direction === \"horizontal\";\n      },\n      isVertical() {\n        return swiper.params.direction === \"vertical\";\n      },\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n      //\n      isBeginning: true,\n      isEnd: false,\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n      cssOverflowAdjustment() {\n        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n      },\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n      // Touch Events\n      touchEventsData: {\n        isTouched: void 0,\n        isMoved: void 0,\n        allowTouchCallbacks: void 0,\n        touchStartTime: void 0,\n        isScrolling: void 0,\n        currentTranslate: void 0,\n        startTranslate: void 0,\n        allowThresholdMove: void 0,\n        // Form elements to match\n        focusableElements: swiper.params.focusableElements,\n        // Last click time\n        lastClickTime: 0,\n        clickTimeout: void 0,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: void 0,\n        startMoving: void 0,\n        pointerId: null,\n        touchId: null\n      },\n      // Clicks\n      allowClick: true,\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0\n      },\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0\n    });\n    swiper.emit(\"_swiper\");\n    if (swiper.params.init) {\n      swiper.init();\n    }\n    return swiper;\n  }\n  getDirectionLabel(property) {\n    if (this.isHorizontal()) {\n      return property;\n    }\n    return {\n      \"width\": \"height\",\n      \"margin-top\": \"margin-left\",\n      \"margin-bottom \": \"margin-right\",\n      \"margin-left\": \"margin-top\",\n      \"margin-right\": \"margin-bottom\",\n      \"padding-left\": \"padding-top\",\n      \"padding-right\": \"padding-bottom\",\n      \"marginRight\": \"marginBottom\"\n    }[property];\n  }\n  getSlideIndex(slideEl) {\n    const {\n      slidesEl,\n      params\n    } = this;\n    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    const firstSlideIndex = elementIndex(slides[0]);\n    return elementIndex(slideEl) - firstSlideIndex;\n  }\n  getSlideIndexByData(index2) {\n    return this.getSlideIndex(this.slides.filter((slideEl) => slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === index2)[0]);\n  }\n  recalcSlides() {\n    const swiper = this;\n    const {\n      slidesEl,\n      params\n    } = swiper;\n    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n  }\n  enable() {\n    const swiper = this;\n    if (swiper.enabled)\n      return;\n    swiper.enabled = true;\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n    swiper.emit(\"enable\");\n  }\n  disable() {\n    const swiper = this;\n    if (!swiper.enabled)\n      return;\n    swiper.enabled = false;\n    if (swiper.params.grabCursor) {\n      swiper.unsetGrabCursor();\n    }\n    swiper.emit(\"disable\");\n  }\n  setProgress(progress, speed) {\n    const swiper = this;\n    progress = Math.min(Math.max(progress, 0), 1);\n    const min = swiper.minTranslate();\n    const max = swiper.maxTranslate();\n    const current = (max - min) * progress + min;\n    swiper.translateTo(current, typeof speed === \"undefined\" ? 0 : speed);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  emitContainerClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el)\n      return;\n    const cls = swiper.el.className.split(\" \").filter((className) => {\n      return className.indexOf(\"swiper\") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n    });\n    swiper.emit(\"_containerClasses\", cls.join(\" \"));\n  }\n  getSlideClasses(slideEl) {\n    const swiper = this;\n    if (swiper.destroyed)\n      return \"\";\n    return slideEl.className.split(\" \").filter((className) => {\n      return className.indexOf(\"swiper-slide\") === 0 || className.indexOf(swiper.params.slideClass) === 0;\n    }).join(\" \");\n  }\n  emitSlidesClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el)\n      return;\n    const updates = [];\n    swiper.slides.forEach((slideEl) => {\n      const classNames = swiper.getSlideClasses(slideEl);\n      updates.push({\n        slideEl,\n        classNames\n      });\n      swiper.emit(\"_slideClass\", slideEl, classNames);\n    });\n    swiper.emit(\"_slideClasses\", updates);\n  }\n  slidesPerViewDynamic(view, exact) {\n    if (view === void 0) {\n      view = \"current\";\n    }\n    if (exact === void 0) {\n      exact = false;\n    }\n    const swiper = this;\n    const {\n      params,\n      slides,\n      slidesGrid,\n      slidesSizesGrid,\n      size: swiperSize,\n      activeIndex\n    } = swiper;\n    let spv = 1;\n    if (typeof params.slidesPerView === \"number\")\n      return params.slidesPerView;\n    if (params.centeredSlides) {\n      let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;\n      let breakLoop;\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += Math.ceil(slides[i].swiperSlideSize);\n          spv += 1;\n          if (slideSize > swiperSize)\n            breakLoop = true;\n        }\n      }\n      for (let i = activeIndex - 1; i >= 0; i -= 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize)\n            breakLoop = true;\n        }\n      }\n    } else {\n      if (view === \"current\") {\n        for (let i = activeIndex + 1; i < slides.length; i += 1) {\n          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      } else {\n        for (let i = activeIndex - 1; i >= 0; i -= 1) {\n          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      }\n    }\n    return spv;\n  }\n  update() {\n    const swiper = this;\n    if (!swiper || swiper.destroyed)\n      return;\n    const {\n      snapGrid,\n      params\n    } = swiper;\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach((imageEl) => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      }\n    });\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n    function setTranslate2() {\n      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    let translated;\n    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n      setTranslate2();\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n        translated = swiper.slideTo(slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate2();\n      }\n    }\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n    swiper.emit(\"update\");\n  }\n  changeDirection(newDirection, needUpdate) {\n    if (needUpdate === void 0) {\n      needUpdate = true;\n    }\n    const swiper = this;\n    const currentDirection = swiper.params.direction;\n    if (!newDirection) {\n      newDirection = currentDirection === \"horizontal\" ? \"vertical\" : \"horizontal\";\n    }\n    if (newDirection === currentDirection || newDirection !== \"horizontal\" && newDirection !== \"vertical\") {\n      return swiper;\n    }\n    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n    swiper.emitContainerClasses();\n    swiper.params.direction = newDirection;\n    swiper.slides.forEach((slideEl) => {\n      if (newDirection === \"vertical\") {\n        slideEl.style.width = \"\";\n      } else {\n        slideEl.style.height = \"\";\n      }\n    });\n    swiper.emit(\"changeDirection\");\n    if (needUpdate)\n      swiper.update();\n    return swiper;\n  }\n  changeLanguageDirection(direction) {\n    const swiper = this;\n    if (swiper.rtl && direction === \"rtl\" || !swiper.rtl && direction === \"ltr\")\n      return;\n    swiper.rtl = direction === \"rtl\";\n    swiper.rtlTranslate = swiper.params.direction === \"horizontal\" && swiper.rtl;\n    if (swiper.rtl) {\n      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = \"rtl\";\n    } else {\n      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = \"ltr\";\n    }\n    swiper.update();\n  }\n  mount(element) {\n    const swiper = this;\n    if (swiper.mounted)\n      return true;\n    let el = element || swiper.params.el;\n    if (typeof el === \"string\") {\n      el = document.querySelector(el);\n    }\n    if (!el) {\n      return false;\n    }\n    el.swiper = swiper;\n    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {\n      swiper.isElement = true;\n    }\n    const getWrapperSelector = () => {\n      return `.${(swiper.params.wrapperClass || \"\").trim().split(\" \").join(\".\")}`;\n    };\n    const getWrapper = () => {\n      if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n        const res = el.shadowRoot.querySelector(getWrapperSelector());\n        return res;\n      }\n      return elementChildren(el, getWrapperSelector())[0];\n    };\n    let wrapperEl = getWrapper();\n    if (!wrapperEl && swiper.params.createElements) {\n      wrapperEl = createElement(\"div\", swiper.params.wrapperClass);\n      el.append(wrapperEl);\n      elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl) => {\n        wrapperEl.append(slideEl);\n      });\n    }\n    Object.assign(swiper, {\n      el,\n      wrapperEl,\n      slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,\n      hostEl: swiper.isElement ? el.parentNode.host : el,\n      mounted: true,\n      // RTL\n      rtl: el.dir.toLowerCase() === \"rtl\" || elementStyle(el, \"direction\") === \"rtl\",\n      rtlTranslate: swiper.params.direction === \"horizontal\" && (el.dir.toLowerCase() === \"rtl\" || elementStyle(el, \"direction\") === \"rtl\"),\n      wrongRTL: elementStyle(wrapperEl, \"display\") === \"-webkit-box\"\n    });\n    return true;\n  }\n  init(el) {\n    const swiper = this;\n    if (swiper.initialized)\n      return swiper;\n    const mounted = swiper.mount(el);\n    if (mounted === false)\n      return swiper;\n    swiper.emit(\"beforeInit\");\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    swiper.addClasses();\n    swiper.updateSize();\n    swiper.updateSlides();\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    }\n    if (swiper.params.grabCursor && swiper.enabled) {\n      swiper.setGrabCursor();\n    }\n    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n    }\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    }\n    swiper.attachEvents();\n    const lazyElements = [...swiper.el.querySelectorAll('[loading=\"lazy\"]')];\n    if (swiper.isElement) {\n      lazyElements.push(...swiper.hostEl.querySelectorAll('[loading=\"lazy\"]'));\n    }\n    lazyElements.forEach((imageEl) => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      } else {\n        imageEl.addEventListener(\"load\", (e) => {\n          processLazyPreloader(swiper, e.target);\n        });\n      }\n    });\n    preload(swiper);\n    swiper.initialized = true;\n    preload(swiper);\n    swiper.emit(\"init\");\n    swiper.emit(\"afterInit\");\n    return swiper;\n  }\n  destroy(deleteInstance, cleanStyles) {\n    if (deleteInstance === void 0) {\n      deleteInstance = true;\n    }\n    if (cleanStyles === void 0) {\n      cleanStyles = true;\n    }\n    const swiper = this;\n    const {\n      params,\n      el,\n      wrapperEl,\n      slides\n    } = swiper;\n    if (typeof swiper.params === \"undefined\" || swiper.destroyed) {\n      return null;\n    }\n    swiper.emit(\"beforeDestroy\");\n    swiper.initialized = false;\n    swiper.detachEvents();\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n    if (cleanStyles) {\n      swiper.removeClasses();\n      el.removeAttribute(\"style\");\n      wrapperEl.removeAttribute(\"style\");\n      if (slides && slides.length) {\n        slides.forEach((slideEl) => {\n          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n          slideEl.removeAttribute(\"style\");\n          slideEl.removeAttribute(\"data-swiper-slide-index\");\n        });\n      }\n    }\n    swiper.emit(\"destroy\");\n    Object.keys(swiper.eventsListeners).forEach((eventName) => {\n      swiper.off(eventName);\n    });\n    if (deleteInstance !== false) {\n      swiper.el.swiper = null;\n      deleteProps(swiper);\n    }\n    swiper.destroyed = true;\n    return null;\n  }\n  static extendDefaults(newDefaults) {\n    extend(extendedDefaults, newDefaults);\n  }\n  static get extendedDefaults() {\n    return extendedDefaults;\n  }\n  static get defaults() {\n    return defaults;\n  }\n  static installModule(mod) {\n    if (!Swiper.prototype.__modules__)\n      Swiper.prototype.__modules__ = [];\n    const modules = Swiper.prototype.__modules__;\n    if (typeof mod === \"function\" && modules.indexOf(mod) < 0) {\n      modules.push(mod);\n    }\n  }\n  static use(module) {\n    if (Array.isArray(module)) {\n      module.forEach((m) => Swiper.installModule(m));\n      return Swiper;\n    }\n    Swiper.installModule(module);\n    return Swiper;\n  }\n}\nObject.keys(prototypes).forEach((prototypeGroup) => {\n  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n  });\n});\nSwiper.use([Resize, Observer]);\nfunction createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n  if (swiper.params.createElements) {\n    Object.keys(checkProps).forEach((key) => {\n      if (!params[key] && params.auto === true) {\n        let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n        if (!element) {\n          element = createElement(\"div\", checkProps[key]);\n          element.className = checkProps[key];\n          swiper.el.append(element);\n        }\n        params[key] = element;\n        originalParams[key] = element;\n      }\n    });\n  }\n  return params;\n}\nfunction Navigation(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  extendParams({\n    navigation: {\n      nextEl: null,\n      prevEl: null,\n      hideOnClick: false,\n      disabledClass: \"swiper-button-disabled\",\n      hiddenClass: \"swiper-button-hidden\",\n      lockClass: \"swiper-button-lock\",\n      navigationDisabledClass: \"swiper-navigation-disabled\"\n    }\n  });\n  swiper.navigation = {\n    nextEl: null,\n    prevEl: null\n  };\n  function getEl(el) {\n    let res;\n    if (el && typeof el === \"string\" && swiper.isElement) {\n      res = swiper.el.querySelector(el);\n      if (res)\n        return res;\n    }\n    if (el) {\n      if (typeof el === \"string\")\n        res = [...document.querySelectorAll(el)];\n      if (swiper.params.uniqueNavElements && typeof el === \"string\" && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {\n        res = swiper.el.querySelector(el);\n      } else if (res && res.length === 1) {\n        res = res[0];\n      }\n    }\n    if (el && !res)\n      return el;\n    return res;\n  }\n  function toggleEl(el, disabled) {\n    const params = swiper.params.navigation;\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      if (subEl) {\n        subEl.classList[disabled ? \"add\" : \"remove\"](...params.disabledClass.split(\" \"));\n        if (subEl.tagName === \"BUTTON\")\n          subEl.disabled = disabled;\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](params.lockClass);\n        }\n      }\n    });\n  }\n  function update2() {\n    const {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    if (swiper.params.loop) {\n      toggleEl(prevEl, false);\n      toggleEl(nextEl, false);\n      return;\n    }\n    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n  }\n  function onPrevClick(e) {\n    e.preventDefault();\n    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind)\n      return;\n    swiper.slidePrev();\n    emit(\"navigationPrev\");\n  }\n  function onNextClick(e) {\n    e.preventDefault();\n    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind)\n      return;\n    swiper.slideNext();\n    emit(\"navigationNext\");\n  }\n  function init() {\n    const params = swiper.params.navigation;\n    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n      nextEl: \"swiper-button-next\",\n      prevEl: \"swiper-button-prev\"\n    });\n    if (!(params.nextEl || params.prevEl))\n      return;\n    let nextEl = getEl(params.nextEl);\n    let prevEl = getEl(params.prevEl);\n    Object.assign(swiper.navigation, {\n      nextEl,\n      prevEl\n    });\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const initButton = (el, dir) => {\n      if (el) {\n        el.addEventListener(\"click\", dir === \"next\" ? onNextClick : onPrevClick);\n      }\n      if (!swiper.enabled && el) {\n        el.classList.add(...params.lockClass.split(\" \"));\n      }\n    };\n    nextEl.forEach((el) => initButton(el, \"next\"));\n    prevEl.forEach((el) => initButton(el, \"prev\"));\n  }\n  function destroy() {\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const destroyButton = (el, dir) => {\n      el.removeEventListener(\"click\", dir === \"next\" ? onNextClick : onPrevClick);\n      el.classList.remove(...swiper.params.navigation.disabledClass.split(\" \"));\n    };\n    nextEl.forEach((el) => destroyButton(el, \"next\"));\n    prevEl.forEach((el) => destroyButton(el, \"prev\"));\n  }\n  on(\"init\", () => {\n    if (swiper.params.navigation.enabled === false) {\n      disable();\n    } else {\n      init();\n      update2();\n    }\n  });\n  on(\"toEdge fromEdge lock unlock\", () => {\n    update2();\n  });\n  on(\"destroy\", () => {\n    destroy();\n  });\n  on(\"enable disable\", () => {\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    if (swiper.enabled) {\n      update2();\n      return;\n    }\n    [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.add(swiper.params.navigation.lockClass));\n  });\n  on(\"click\", (_s, e) => {\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const targetEl = e.target;\n    if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {\n      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl)))\n        return;\n      let isHidden;\n      if (nextEl.length) {\n        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n      } else if (prevEl.length) {\n        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n      }\n      if (isHidden === true) {\n        emit(\"navigationShow\");\n      } else {\n        emit(\"navigationHide\");\n      }\n      [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.toggle(swiper.params.navigation.hiddenClass));\n    }\n  });\n  const enable = () => {\n    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(\" \"));\n    init();\n    update2();\n  };\n  const disable = () => {\n    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(\" \"));\n    destroy();\n  };\n  Object.assign(swiper.navigation, {\n    enable,\n    disable,\n    update: update2,\n    init,\n    destroy\n  });\n}\nfunction classesToSelector(classes2) {\n  if (classes2 === void 0) {\n    classes2 = \"\";\n  }\n  return `.${classes2.trim().replace(/([\\.:!+\\/])/g, \"\\\\$1\").replace(/ /g, \".\")}`;\n}\nfunction Pagination(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const pfx = \"swiper-pagination\";\n  extendParams({\n    pagination: {\n      el: null,\n      bulletElement: \"span\",\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: \"bullets\",\n      // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: (number) => number,\n      formatFractionTotal: (number) => number,\n      bulletClass: `${pfx}-bullet`,\n      bulletActiveClass: `${pfx}-bullet-active`,\n      modifierClass: `${pfx}-`,\n      currentClass: `${pfx}-current`,\n      totalClass: `${pfx}-total`,\n      hiddenClass: `${pfx}-hidden`,\n      progressbarFillClass: `${pfx}-progressbar-fill`,\n      progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n      clickableClass: `${pfx}-clickable`,\n      lockClass: `${pfx}-lock`,\n      horizontalClass: `${pfx}-horizontal`,\n      verticalClass: `${pfx}-vertical`,\n      paginationDisabledClass: `${pfx}-disabled`\n    }\n  });\n  swiper.pagination = {\n    el: null,\n    bullets: []\n  };\n  let bulletSize;\n  let dynamicBulletIndex = 0;\n  function isPaginationDisabled() {\n    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n  }\n  function setSideBullets(bulletEl, position) {\n    const {\n      bulletActiveClass\n    } = swiper.params.pagination;\n    if (!bulletEl)\n      return;\n    bulletEl = bulletEl[`${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`];\n    if (bulletEl) {\n      bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n      bulletEl = bulletEl[`${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`];\n      if (bulletEl) {\n        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n      }\n    }\n  }\n  function onBulletClick(e) {\n    const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n    if (!bulletEl) {\n      return;\n    }\n    e.preventDefault();\n    const index2 = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n    if (swiper.params.loop) {\n      if (swiper.realIndex === index2)\n        return;\n      swiper.slideToLoop(index2);\n    } else {\n      swiper.slideTo(index2);\n    }\n  }\n  function update2() {\n    const rtl = swiper.rtl;\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled())\n      return;\n    let el = swiper.pagination.el;\n    el = makeElementsArray(el);\n    let current;\n    let previousIndex;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n    if (swiper.params.loop) {\n      previousIndex = swiper.previousRealIndex || 0;\n      current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n    } else if (typeof swiper.snapIndex !== \"undefined\") {\n      current = swiper.snapIndex;\n      previousIndex = swiper.previousSnapIndex;\n    } else {\n      previousIndex = swiper.previousIndex || 0;\n      current = swiper.activeIndex || 0;\n    }\n    if (params.type === \"bullets\" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n      const bullets = swiper.pagination.bullets;\n      let firstIndex;\n      let lastIndex;\n      let midIndex;\n      if (params.dynamicBullets) {\n        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? \"width\" : \"height\", true);\n        el.forEach((subEl) => {\n          subEl.style[swiper.isHorizontal() ? \"width\" : \"height\"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n        });\n        if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {\n          dynamicBulletIndex += current - (previousIndex || 0);\n          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n            dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (dynamicBulletIndex < 0) {\n            dynamicBulletIndex = 0;\n          }\n        }\n        firstIndex = Math.max(current - dynamicBulletIndex, 0);\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n      bullets.forEach((bulletEl) => {\n        const classesToRemove = [...[\"\", \"-next\", \"-next-next\", \"-prev\", \"-prev-prev\", \"-main\"].map((suffix) => `${params.bulletActiveClass}${suffix}`)].map((s) => typeof s === \"string\" && s.includes(\" \") ? s.split(\" \") : s).flat();\n        bulletEl.classList.remove(...classesToRemove);\n      });\n      if (el.length > 1) {\n        bullets.forEach((bullet) => {\n          const bulletIndex = elementIndex(bullet);\n          if (bulletIndex === current) {\n            bullet.classList.add(...params.bulletActiveClass.split(\" \"));\n          } else if (swiper.isElement) {\n            bullet.setAttribute(\"part\", \"bullet\");\n          }\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(\" \"));\n            }\n            if (bulletIndex === firstIndex) {\n              setSideBullets(bullet, \"prev\");\n            }\n            if (bulletIndex === lastIndex) {\n              setSideBullets(bullet, \"next\");\n            }\n          }\n        });\n      } else {\n        const bullet = bullets[current];\n        if (bullet) {\n          bullet.classList.add(...params.bulletActiveClass.split(\" \"));\n        }\n        if (swiper.isElement) {\n          bullets.forEach((bulletEl, bulletIndex) => {\n            bulletEl.setAttribute(\"part\", bulletIndex === current ? \"bullet-active\" : \"bullet\");\n          });\n        }\n        if (params.dynamicBullets) {\n          const firstDisplayedBullet = bullets[firstIndex];\n          const lastDisplayedBullet = bullets[lastIndex];\n          for (let i = firstIndex; i <= lastIndex; i += 1) {\n            if (bullets[i]) {\n              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(\" \"));\n            }\n          }\n          setSideBullets(firstDisplayedBullet, \"prev\");\n          setSideBullets(lastDisplayedBullet, \"next\");\n        }\n      }\n      if (params.dynamicBullets) {\n        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n        const offsetProp = rtl ? \"right\" : \"left\";\n        bullets.forEach((bullet) => {\n          bullet.style[swiper.isHorizontal() ? offsetProp : \"top\"] = `${bulletsOffset}px`;\n        });\n      }\n    }\n    el.forEach((subEl, subElIndex) => {\n      if (params.type === \"fraction\") {\n        subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl) => {\n          fractionEl.textContent = params.formatFractionCurrent(current + 1);\n        });\n        subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl) => {\n          totalEl.textContent = params.formatFractionTotal(total);\n        });\n      }\n      if (params.type === \"progressbar\") {\n        let progressbarDirection;\n        if (params.progressbarOpposite) {\n          progressbarDirection = swiper.isHorizontal() ? \"vertical\" : \"horizontal\";\n        } else {\n          progressbarDirection = swiper.isHorizontal() ? \"horizontal\" : \"vertical\";\n        }\n        const scale = (current + 1) / total;\n        let scaleX = 1;\n        let scaleY = 1;\n        if (progressbarDirection === \"horizontal\") {\n          scaleX = scale;\n        } else {\n          scaleY = scale;\n        }\n        subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl) => {\n          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n          progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n        });\n      }\n      if (params.type === \"custom\" && params.renderCustom) {\n        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n        if (subElIndex === 0)\n          emit(\"paginationRender\", subEl);\n      } else {\n        if (subElIndex === 0)\n          emit(\"paginationRender\", subEl);\n        emit(\"paginationUpdate\", subEl);\n      }\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](params.lockClass);\n      }\n    });\n  }\n  function render() {\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled())\n      return;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;\n    let el = swiper.pagination.el;\n    el = makeElementsArray(el);\n    let paginationHTML = \"\";\n    if (params.type === \"bullets\") {\n      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {\n        numberOfBullets = slidesLength;\n      }\n      for (let i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : \"\"} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n        }\n      }\n    }\n    if (params.type === \"fraction\") {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML = `<span class=\"${params.currentClass}\"></span> / <span class=\"${params.totalClass}\"></span>`;\n      }\n    }\n    if (params.type === \"progressbar\") {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n      }\n    }\n    swiper.pagination.bullets = [];\n    el.forEach((subEl) => {\n      if (params.type !== \"custom\") {\n        subEl.innerHTML = paginationHTML || \"\";\n      }\n      if (params.type === \"bullets\") {\n        swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n      }\n    });\n    if (params.type !== \"custom\") {\n      emit(\"paginationRender\", el[0]);\n    }\n  }\n  function init() {\n    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n      el: \"swiper-pagination\"\n    });\n    const params = swiper.params.pagination;\n    if (!params.el)\n      return;\n    let el;\n    if (typeof params.el === \"string\" && swiper.isElement) {\n      el = swiper.el.querySelector(params.el);\n    }\n    if (!el && typeof params.el === \"string\") {\n      el = [...document.querySelectorAll(params.el)];\n    }\n    if (!el) {\n      el = params.el;\n    }\n    if (!el || el.length === 0)\n      return;\n    if (swiper.params.uniqueNavElements && typeof params.el === \"string\" && Array.isArray(el) && el.length > 1) {\n      el = [...swiper.el.querySelectorAll(params.el)];\n      if (el.length > 1) {\n        el = el.filter((subEl) => {\n          if (elementParents(subEl, \".swiper\")[0] !== swiper.el)\n            return false;\n          return true;\n        })[0];\n      }\n    }\n    if (Array.isArray(el) && el.length === 1)\n      el = el[0];\n    Object.assign(swiper.pagination, {\n      el\n    });\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      if (params.type === \"bullets\" && params.clickable) {\n        subEl.classList.add(...(params.clickableClass || \"\").split(\" \"));\n      }\n      subEl.classList.add(params.modifierClass + params.type);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      if (params.type === \"bullets\" && params.dynamicBullets) {\n        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n        dynamicBulletIndex = 0;\n        if (params.dynamicMainBullets < 1) {\n          params.dynamicMainBullets = 1;\n        }\n      }\n      if (params.type === \"progressbar\" && params.progressbarOpposite) {\n        subEl.classList.add(params.progressbarOppositeClass);\n      }\n      if (params.clickable) {\n        subEl.addEventListener(\"click\", onBulletClick);\n      }\n      if (!swiper.enabled) {\n        subEl.classList.add(params.lockClass);\n      }\n    });\n  }\n  function destroy() {\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled())\n      return;\n    let el = swiper.pagination.el;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) => {\n        subEl.classList.remove(params.hiddenClass);\n        subEl.classList.remove(params.modifierClass + params.type);\n        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        if (params.clickable) {\n          subEl.classList.remove(...(params.clickableClass || \"\").split(\" \"));\n          subEl.removeEventListener(\"click\", onBulletClick);\n        }\n      });\n    }\n    if (swiper.pagination.bullets)\n      swiper.pagination.bullets.forEach((subEl) => subEl.classList.remove(...params.bulletActiveClass.split(\" \")));\n  }\n  on(\"changeDirection\", () => {\n    if (!swiper.pagination || !swiper.pagination.el)\n      return;\n    const params = swiper.params.pagination;\n    let {\n      el\n    } = swiper.pagination;\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.classList.remove(params.horizontalClass, params.verticalClass);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    });\n  });\n  on(\"init\", () => {\n    if (swiper.params.pagination.enabled === false) {\n      disable();\n    } else {\n      init();\n      render();\n      update2();\n    }\n  });\n  on(\"activeIndexChange\", () => {\n    if (typeof swiper.snapIndex === \"undefined\") {\n      update2();\n    }\n  });\n  on(\"snapIndexChange\", () => {\n    update2();\n  });\n  on(\"snapGridLengthChange\", () => {\n    render();\n    update2();\n  });\n  on(\"destroy\", () => {\n    destroy();\n  });\n  on(\"enable disable\", () => {\n    let {\n      el\n    } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) => subEl.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.pagination.lockClass));\n    }\n  });\n  on(\"lock unlock\", () => {\n    update2();\n  });\n  on(\"click\", (_s, e) => {\n    const targetEl = e.target;\n    const el = makeElementsArray(swiper.pagination.el);\n    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))\n        return;\n      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n      if (isHidden === true) {\n        emit(\"paginationShow\");\n      } else {\n        emit(\"paginationHide\");\n      }\n      el.forEach((subEl) => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n    }\n  });\n  const enable = () => {\n    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n    let {\n      el\n    } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n    }\n    init();\n    render();\n    update2();\n  };\n  const disable = () => {\n    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n    let {\n      el\n    } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n    }\n    destroy();\n  };\n  Object.assign(swiper.pagination, {\n    enable,\n    disable,\n    render,\n    update: update2,\n    init,\n    destroy\n  });\n}\nfunction Autoplay(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit,\n    params\n  } = _ref;\n  swiper.autoplay = {\n    running: false,\n    paused: false,\n    timeLeft: 0\n  };\n  extendParams({\n    autoplay: {\n      enabled: false,\n      delay: 3e3,\n      waitForTransition: true,\n      disableOnInteraction: false,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n      pauseOnMouseEnter: false\n    }\n  });\n  let timeout;\n  let raf;\n  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;\n  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;\n  let autoplayTimeLeft;\n  let autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();\n  let wasPaused;\n  let isTouched;\n  let pausedByTouch;\n  let touchStartTimeout;\n  let slideChanged;\n  let pausedByInteraction;\n  let pausedByPointerEnter;\n  function onTransitionEnd(e) {\n    if (!swiper || swiper.destroyed || !swiper.wrapperEl)\n      return;\n    if (e.target !== swiper.wrapperEl)\n      return;\n    swiper.wrapperEl.removeEventListener(\"transitionend\", onTransitionEnd);\n    if (pausedByPointerEnter) {\n      return;\n    }\n    resume();\n  }\n  const calcTimeLeft = () => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    if (swiper.autoplay.paused) {\n      wasPaused = true;\n    } else if (wasPaused) {\n      autoplayDelayCurrent = autoplayTimeLeft;\n      wasPaused = false;\n    }\n    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (/* @__PURE__ */ new Date()).getTime();\n    swiper.autoplay.timeLeft = timeLeft;\n    emit(\"autoplayTimeLeft\", timeLeft, timeLeft / autoplayDelayTotal);\n    raf = requestAnimationFrame(() => {\n      calcTimeLeft();\n    });\n  };\n  const getSlideDelay = () => {\n    let activeSlideEl;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      activeSlideEl = swiper.slides.filter((slideEl) => slideEl.classList.contains(\"swiper-slide-active\"))[0];\n    } else {\n      activeSlideEl = swiper.slides[swiper.activeIndex];\n    }\n    if (!activeSlideEl)\n      return void 0;\n    const currentSlideDelay = parseInt(activeSlideEl.getAttribute(\"data-swiper-autoplay\"), 10);\n    return currentSlideDelay;\n  };\n  const run = (delayForce) => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    cancelAnimationFrame(raf);\n    calcTimeLeft();\n    let delay = typeof delayForce === \"undefined\" ? swiper.params.autoplay.delay : delayForce;\n    autoplayDelayTotal = swiper.params.autoplay.delay;\n    autoplayDelayCurrent = swiper.params.autoplay.delay;\n    const currentSlideDelay = getSlideDelay();\n    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === \"undefined\") {\n      delay = currentSlideDelay;\n      autoplayDelayTotal = currentSlideDelay;\n      autoplayDelayCurrent = currentSlideDelay;\n    }\n    autoplayTimeLeft = delay;\n    const speed = swiper.params.speed;\n    const proceed = () => {\n      if (!swiper || swiper.destroyed)\n        return;\n      if (swiper.params.autoplay.reverseDirection) {\n        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n          swiper.slidePrev(speed, true, true);\n          emit(\"autoplay\");\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n          emit(\"autoplay\");\n        }\n      } else {\n        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n          swiper.slideNext(speed, true, true);\n          emit(\"autoplay\");\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(0, speed, true, true);\n          emit(\"autoplay\");\n        }\n      }\n      if (swiper.params.cssMode) {\n        autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();\n        requestAnimationFrame(() => {\n          run();\n        });\n      }\n    };\n    if (delay > 0) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        proceed();\n      }, delay);\n    } else {\n      requestAnimationFrame(() => {\n        proceed();\n      });\n    }\n    return delay;\n  };\n  const start = () => {\n    autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();\n    swiper.autoplay.running = true;\n    run();\n    emit(\"autoplayStart\");\n  };\n  const stop = () => {\n    swiper.autoplay.running = false;\n    clearTimeout(timeout);\n    cancelAnimationFrame(raf);\n    emit(\"autoplayStop\");\n  };\n  const pause = (internal, reset) => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    clearTimeout(timeout);\n    if (!internal) {\n      pausedByInteraction = true;\n    }\n    const proceed = () => {\n      emit(\"autoplayPause\");\n      if (swiper.params.autoplay.waitForTransition) {\n        swiper.wrapperEl.addEventListener(\"transitionend\", onTransitionEnd);\n      } else {\n        resume();\n      }\n    };\n    swiper.autoplay.paused = true;\n    if (reset) {\n      if (slideChanged) {\n        autoplayTimeLeft = swiper.params.autoplay.delay;\n      }\n      slideChanged = false;\n      proceed();\n      return;\n    }\n    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n    autoplayTimeLeft = delay - ((/* @__PURE__ */ new Date()).getTime() - autoplayStartTime);\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop)\n      return;\n    if (autoplayTimeLeft < 0)\n      autoplayTimeLeft = 0;\n    proceed();\n  };\n  const resume = () => {\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running)\n      return;\n    autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();\n    if (pausedByInteraction) {\n      pausedByInteraction = false;\n      run(autoplayTimeLeft);\n    } else {\n      run();\n    }\n    swiper.autoplay.paused = false;\n    emit(\"autoplayResume\");\n  };\n  const onVisibilityChange = () => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    const document2 = getDocument();\n    if (document2.visibilityState === \"hidden\") {\n      pausedByInteraction = true;\n      pause(true);\n    }\n    if (document2.visibilityState === \"visible\") {\n      resume();\n    }\n  };\n  const onPointerEnter = (e) => {\n    if (e.pointerType !== \"mouse\")\n      return;\n    pausedByInteraction = true;\n    pausedByPointerEnter = true;\n    if (swiper.animating || swiper.autoplay.paused)\n      return;\n    pause(true);\n  };\n  const onPointerLeave = (e) => {\n    if (e.pointerType !== \"mouse\")\n      return;\n    pausedByPointerEnter = false;\n    if (swiper.autoplay.paused) {\n      resume();\n    }\n  };\n  const attachMouseEvents = () => {\n    if (swiper.params.autoplay.pauseOnMouseEnter) {\n      swiper.el.addEventListener(\"pointerenter\", onPointerEnter);\n      swiper.el.addEventListener(\"pointerleave\", onPointerLeave);\n    }\n  };\n  const detachMouseEvents = () => {\n    swiper.el.removeEventListener(\"pointerenter\", onPointerEnter);\n    swiper.el.removeEventListener(\"pointerleave\", onPointerLeave);\n  };\n  const attachDocumentEvents = () => {\n    const document2 = getDocument();\n    document2.addEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  const detachDocumentEvents = () => {\n    const document2 = getDocument();\n    document2.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  on(\"init\", () => {\n    if (swiper.params.autoplay.enabled) {\n      attachMouseEvents();\n      attachDocumentEvents();\n      start();\n    }\n  });\n  on(\"destroy\", () => {\n    detachMouseEvents();\n    detachDocumentEvents();\n    if (swiper.autoplay.running) {\n      stop();\n    }\n  });\n  on(\"_freeModeStaticRelease\", () => {\n    if (pausedByTouch || pausedByInteraction) {\n      resume();\n    }\n  });\n  on(\"_freeModeNoMomentumRelease\", () => {\n    if (!swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n  on(\"beforeTransitionStart\", (_s, speed, internal) => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    if (internal || !swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n  on(\"sliderFirstMove\", () => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    if (swiper.params.autoplay.disableOnInteraction) {\n      stop();\n      return;\n    }\n    isTouched = true;\n    pausedByTouch = false;\n    pausedByInteraction = false;\n    touchStartTimeout = setTimeout(() => {\n      pausedByInteraction = true;\n      pausedByTouch = true;\n      pause(true);\n    }, 200);\n  });\n  on(\"touchEnd\", () => {\n    if (swiper.destroyed || !swiper.autoplay.running || !isTouched)\n      return;\n    clearTimeout(touchStartTimeout);\n    clearTimeout(timeout);\n    if (swiper.params.autoplay.disableOnInteraction) {\n      pausedByTouch = false;\n      isTouched = false;\n      return;\n    }\n    if (pausedByTouch && swiper.params.cssMode)\n      resume();\n    pausedByTouch = false;\n    isTouched = false;\n  });\n  on(\"slideChange\", () => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    slideChanged = true;\n  });\n  Object.assign(swiper.autoplay, {\n    start,\n    stop,\n    pause,\n    resume\n  });\n}\nclass InitSlider {\n  constructor(props) {\n    __publicField(this, \"classSlider\", \"\");\n    __publicField(this, \"settingsSlider\", {});\n    __publicField(this, \"slider\", null);\n    this.classSlider = props.classSlider;\n    this.settingsSlider = props.settingsSlider;\n    this.checkSlider();\n    if (this.settingsSlider.destroySize) {\n      this.checkResizeSlider();\n    }\n  }\n  checkSlider() {\n    if (window.matchMedia(this.settingsSlider.destroySize).matches && this.settingsSlider.destroySize) {\n      if (this.slider) {\n        try {\n          this.destroySlider();\n        } catch (e) {\n          console.log(e);\n        }\n      }\n      return 1;\n    } else {\n      if (!this.slider) {\n        this.initSlider();\n      }\n    }\n  }\n  checkResizeSlider() {\n    window.addEventListener(\"resize\", () => {\n      this.checkSlider();\n    });\n  }\n  initSlider() {\n    this.slider = new Swiper(this.classSlider, this.settingsSlider) || null;\n  }\n  destroySlider() {\n    var _a, _b;\n    this.slider.destroy();\n    this.slider = null;\n    (_a = document.querySelectorAll(`${this.classSlider}__slider`)) == null ? void 0 : _a.forEach((i) => {\n      i.removeAttribute(\"style\");\n    });\n    (_b = document.querySelector(`${this.classSlider}__wrapper`)) == null ? void 0 : _b.removeAttribute(\"style\");\n  }\n}\nconst listSliders = [\n  {\n    classSlider: \".tmpl-hh-header__slider\",\n    settingsSlider: {\n      modules: [Autoplay, Navigation, Pagination],\n      autoplay: {\n        delay: 4e3\n      },\n      loop: true,\n      centeredSlides: true,\n      slidesPerView: \"auto\",\n      initialSlide: 0,\n      navigation: {\n        prevEl: \".slider-button_prev\",\n        nextEl: \".slider-button_next\"\n      },\n      pagination: {\n        el: \".tmpl-hh-header__slider-pagination\",\n        bulletClass: \"tmpl-hh-header__slider-bullet\",\n        bulletActiveClass: \"tmpl-hh-header__slider-bullet_active\"\n      }\n    }\n  }\n];\nconst initSliders = () => {\n  listSliders.map((i) => {\n    new InitSlider(i);\n  });\n};\nfunction playButton() {\n  document.querySelectorAll(\"[data-tmpl-hh-video]\").forEach((videoBlock) => {\n    const cover = videoBlock.querySelector(\"[data-tmpl-hh-video-cover]\");\n    const video = videoBlock.querySelector(\"[data-tmpl-hh-video-video]\");\n    const playButton2 = videoBlock.querySelector(\"[data-tmpl-hh-video-play-button]\");\n    const hidePlayButton = () => {\n      playButton2.classList.add(\"tmpl-hh-video__play-button_hidden\");\n    };\n    const playVideo = () => {\n      cover.classList.add(\"tmpl-hh-video__cover_hidden\");\n      hidePlayButton();\n      video.classList.remove(\"tmpl-hh-video__video_hidden\");\n      video.volume = 0.3;\n      video.play();\n    };\n    cover.addEventListener(\"click\", playVideo);\n    playButton2.addEventListener(\"click\", playVideo);\n  });\n}\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n  initSliders();\n  playButton();\n});\n\n\n//\n</script>\n",
  "vacancy_constructor_template": null,
  "key_skills": [
    {
      "name": "MS Excel"
    },
    {
      "name": "Формирование аналитической отчетности"
    },
    {
      "name": "Аналитическое мышление"
    },
    {
      "name": "Складской Учет"
    },
    {
      "name": "Работа с базами данных"
    },
    {
      "name": "Работа с большим объемом информации"
    },
    {
      "name": "SAP"
    }
  ],
  "accept_handicapped": false,
  "accept_kids": false,
  "archived": false,
  "response_url": null,
  "specializations": [],
  "professional_roles": [
    {
      "id": "10",
      "name": "Аналитик"
    }
  ],
  "code": null,
  "hidden": false,
  "quick_responses_allowed": false,
  "driver_license_types": [],
  "accept_incomplete_resumes": false,
  "employer": {
    "id": "15959",
    "name": "AB InBev Efes",
    "url": "https://api.hh.ru/employers/15959",
    "alternate_url": "https://hh.ru/employer/15959",
    "logo_urls": {
      "original": "https://img.hhcdn.ru/employer-logo-original/899939.jpg",
      "90": "https://img.hhcdn.ru/employer-logo/4040443.jpeg",
      "240": "https://img.hhcdn.ru/employer-logo/4040444.jpeg"
    },
    "vacancies_url": "https://api.hh.ru/vacancies?employer_id=15959",
    "accredited_it_employer": false,
    "trusted": true
  },
  "published_at": "2025-05-28T06:54:31+0300",
  "created_at": "2025-05-28T06:54:31+0300",
  "initial_created_at": "2025-04-28T06:54:30+0300",
  "negotiations_url": null,
  "suitable_resumes_url": null,
  "apply_alternate_url": "https://hh.ru/applicant/vacancy_response?vacancyId=120000181",
  "has_test": false,
  "test": null,
  "alternate_url": "https://hh.ru/vacancy/120000181",
  "working_days": [],
  "working_time_intervals": [],
  "working_time_modes": [],
  "accept_temporary": false,
  "languages": [],
  "approved": true,
  "employment_form": {
    "id": "FULL",
    "name": "Полная"
  },
  "fly_in_fly_out_duration": [],
  "internship": false,
  "night_shifts": false,
  "work_format": [
    {
      "id": "ON_SITE",
      "name": "На месте работодателя"
    }
  ],
  "work_schedule_by_days": [
    {
      "id": "FIVE_ON_TWO_OFF",
      "name": "5/2"
    }
  ],
  "working_hours": [
    {
      "id": "HOURS_8",
      "name": "8 часов"
    }
  ],
  "show_logo_in_search": true
}
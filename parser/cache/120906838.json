{
  "id": "120906838",
  "premium": false,
  "billing_type": {
    "id": "standard",
    "name": "Стандарт"
  },
  "relations": [],
  "name": "Data Scientist",
  "insider_interview": null,
  "response_letter_required": false,
  "area": {
    "id": "4",
    "name": "Новосибирск",
    "url": "https://api.hh.ru/areas/4"
  },
  "salary": null,
  "salary_range": null,
  "type": {
    "id": "open",
    "name": "Открытая"
  },
  "address": null,
  "allow_messages": true,
  "experience": {
    "id": "between1And3",
    "name": "От 1 года до 3 лет"
  },
  "schedule": {
    "id": "remote",
    "name": "Удаленная работа"
  },
  "employment": {
    "id": "full",
    "name": "Полная занятость"
  },
  "department": null,
  "show_contacts": false,
  "contacts": null,
  "description": "<p><strong>Чем предстоит заниматься:</strong></p> <ul> <li>Разрабатывать системы скоринга для различных стран;</li> <li>Исследовать поведенческие паттерны и находить<br />зависимости в данных используя статистические методы<br />анализа;</li> <li>Моделировать поведения клиентов для решения задач<br />маркетинга;</li> <li>Автоматизировать процессы компании с использованием LLM;</li> <li>Участвовать в разработке архитектуры ML сервисов;</li> <li>Оптимизировать и развивать уже существующие<br />пайплайны в рамках MLOps платформы.</li> </ul> <p><strong>Что для нас важно:</strong></p> <ul> <li>Имеешь хорошую математическую подготовку;</li> <li>Знаешь основы статистического анализа;</li> <li>Имеешь опыт использования и понимаешь основные алгоритмы машинного обучения;</li> <li>Понимаешь принципы постановки экспериментов и инструментарий для проверки гипотез;</li> <li>Имеешь опыт работы с Python, библиотеками scikit-learn, numpy, scipy, pandas, gbm фреймворками;</li> <li>Владеешь инструментами визуализации данных (seaborn, plotly, matplotlib);<br />Понимаешь микросервисную архитектуру и знаком с инструментами (Docker, K8S);</li> <li>Понимаешь методологию разработки GitFlow;</li> <li>Обладаешь навыками построения эффективной коммуникации и умеешь донести свою точку зрения.</li> </ul> <p><strong>Будет твоим преимуществом:</strong></p> <ul> <li>Имеешь профиль в GitHub или Kaggle, которым не стыдно поделиться;</li> <li>Имеешь опыт вывода моделей в прод и понимаешь их жизненный цикл;</li> <li>Применял практики MLOps в реальных проектах;</li> <li>Имеешь опыт участия в конкурсах по анализу данных;</li> <li>Знаешь pytorch, имеешь практические навыки в современных библиотеках для работы с большими языковыми моделями;</li> <li>Закончил ШАД или CSC.</li> </ul> <p><strong>Мы гарантируем:</strong></p> <ul> <li>Атмосферу безопасности. Так как мы предлагаем трудоустройство в полном соответствии с ТК РФ;</li> <li> <p>График работы 5\\2 (сб,вс - выходные);</p> </li> <li> <p>Чувство устойчивости в настоящем и будущем, даже когда времена вокруг нас меняются. Помогут тебе в этом наши оздоровительные и финансовые бенефиты;</p> </li> <li> <p>Комфорт в деталях: отсутствие дресс-кода, оборудованное рабочее место и возможность отдыха в неформальной обстановке.</p> </li> <li> <p>Динамику профессионального развития.</p> </li> </ul>",
  "branded_description": "\n<style>/*29.05.2025-hh-team-007*/\n.hht-vacancydescription {\n  padding: 0;\n}\n\n.tmpl_hh_wrapper {\n  position: relative;\n  z-index: 1;\n  overflow: hidden;\n  width: 100%;\n  max-width: 690px;\n  margin: 0 auto;\n  font-weight: 400;\n  font-size: 16px;\n  font-family: Arial, sans-serif;\n  line-height: 22px;\n  letter-spacing: 0.01em;\n  word-break: normal;\n}\n\n@media (max-width: 1019px) {\n  .tmpl_hh_wrapper {\n    max-width: 610px;\n  }\n}\n\n.tmpl_hh_wrapper p, .tmpl_hh_wrapper h1, .tmpl_hh_wrapper h2, .tmpl_hh_wrapper h3, .tmpl_hh_wrapper h4, .tmpl_hh_wrapper h5, .tmpl_hh_wrapper h6, .tmpl_hh_wrapper a, .tmpl_hh_wrapper img, .tmpl_hh_wrapper ol, .tmpl_hh_wrapper ul, .tmpl_hh_wrapper li {\n  vertical-align: baseline;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-weight: inherit;\n  font-size: inherit;\n}\n\n.tmpl_hh_wrapper ul {\n  list-style: none;\n}\n\n.tmpl_hh_wrapper a {\n  text-decoration: none;\n}\n\n.tmpl_hh_wrapper a:hover {\n  color: inherit;\n}\n\n.tmpl_hh_wrapper img {\n  display: block;\n}\n\n.tmpl_hh_wrapper button {\n  display: block;\n  padding: 0;\n  border: none;\n  background-color: transparent;\n  outline: none;\n  cursor: pointer;\n}\n\n.tmpl_hh_wrapper button svg {\n  cursor: pointer;\n}\n\n.tmpl_hh_wrapper .l-cell, .tmpl_hh_wrapper .l-paddings {\n  padding: 0 !important;\n}\n\n.tmpl_hh_wrapper .b-vacancy-desc-wrapper {\n  margin-top: 0 !important;\n}\n\n.tmpl_hh_wrapper .b-vacancy-desc {\n  overflow: visible !important;\n  line-height: inherit;\n}\n\n.tmpl_hh_content ol li b, .tmpl_hh_content ol li strong, .tmpl_hh_content ol li p b, .tmpl_hh_content ol li p strong, .tmpl_hh_content ul li b, .tmpl_hh_content ul li strong, .tmpl_hh_content ul li p b, .tmpl_hh_content ul li p strong {\n  margin: 0 !important;\n  color: inherit !important;\n  font-size: inherit !important;\n  line-height: inherit;\n  text-transform: none;\n}\n\n.tmpl_hh_content ol li p, .tmpl_hh_content ul li p {\n  margin: 0;\n  font-weight: normal;\n}\n\n.tmpl_hh_content p {\n  margin-bottom: 16px;\n}\n\n.tmpl_hh_content p b, .tmpl_hh_content p strong {\n  display: inline;\n  margin: 0;\n}\n\n.tmpl_hh_content ol, .tmpl_hh_content ul {\n  margin-bottom: 32px;\n  margin-left: 18px;\n  list-style: none !important;\n}\n\n.tmpl_hh_content ol {\n  counter-reset: list_counter;\n}\n\n.tmpl_hh_content li {\n  position: relative;\n  margin-bottom: 8px;\n  font-size: 16px;\n}\n\n.tmpl_hh_content li:last-child {\n  margin-bottom: 0;\n}\n\n.tmpl_hh_content ul ul, .tmpl_hh_content ul ol, .tmpl_hh_content ol ol, .tmpl_hh_content ol ul {\n  margin-top: 14px;\n}\n\n.tmpl_hh_content ol > li {\n  counter-increment: list_counter;\n}\n\n.tmpl_hh_content ul > li::before {\n  content: \"\";\n  position: absolute;\n  top: 9px;\n  left: -18px;\n  width: 5px;\n  height: 5px;\n  border-radius: 100%;\n  background-color: #000;\n}\n\n.tmpl_hh_content ol > li::before {\n  content: counter(list_counter) \".\";\n  right: 100%;\n  left: auto;\n  margin-right: 2px;\n}\n\n.tmpl_hh_content :last-child {\n  margin-bottom: 0;\n}\n\n@keyframes head-anim-1 {\n  0% {\n    transform: translateY(0) rotate(0deg);\n  }\n  20% {\n    transform: translateY(10px) rotate(-5deg);\n  }\n  40% {\n    transform: translateY(20px) rotate(-10deg);\n  }\n  60% {\n    transform: translateY(10px) rotate(5deg);\n  }\n  80% {\n    transform: translateY(5px) rotate(10deg);\n  }\n  100% {\n    transform: translateY(0) rotate(0deg);\n  }\n}\n\n@keyframes head-anim-2 {\n  0% {\n    transform: translateY(0) rotate(0deg);\n  }\n  20% {\n    transform: translateY(10px) rotate(5deg);\n  }\n  40% {\n    transform: translateY(20px) rotate(10deg);\n  }\n  60% {\n    transform: translateY(10px) rotate(-5deg);\n  }\n  80% {\n    transform: translateY(5px) rotate(-10deg);\n  }\n  100% {\n    transform: translateY(0) rotate(0deg);\n  }\n}\n\n@keyframes anim1 {\n  0% {\n    transform: translateX(0);\n  }\n  20% {\n    transform: translateX(-40%);\n  }\n  40% {\n    transform: translateX(-80%);\n  }\n  60% {\n    transform: translateX(-40%);\n  }\n  80% {\n    transform: translateX(-20%);\n  }\n  100% {\n    transform: translateX(0);\n  }\n}\n\n.tmpl_hh_wrapper {\n  box-sizing: border-box;\n  color: #3d3d3d;\n  font-size: 18px;\n  line-height: 120%;\n  letter-spacing: normal;\n}\n\n.tmpl_hh_wrapper .tmpl_hh_designation {\n  color: #b5b5b5;\n  font-size: 14px;\n  line-height: 120%;\n}\n\n.tmpl_hh_wrapper * {\n  box-sizing: border-box;\n}\n\n.tmpl_hh_wrapper br.tmpl_hh_xxl, .tmpl_hh_wrapper p.tmpl_hh_xxl, .tmpl_hh_wrapper div.tmpl_hh_xxl {\n  display: none;\n}\n\n@media (min-width: 1340px) {\n  .tmpl_hh_wrapper br.tmpl_hh_xxl, .tmpl_hh_wrapper p.tmpl_hh_xxl, .tmpl_hh_wrapper div.tmpl_hh_xxl {\n    display: block !important;\n  }\n}\n\n.tmpl_hh_wrapper br.tmpl_hh_xl, .tmpl_hh_wrapper p.tmpl_hh_xl, .tmpl_hh_wrapper div.tmpl_hh_xl {\n  display: none;\n}\n\n@media (min-width: 1020px) and (max-width: 1339px) {\n  .tmpl_hh_wrapper br.tmpl_hh_xl, .tmpl_hh_wrapper p.tmpl_hh_xl, .tmpl_hh_wrapper div.tmpl_hh_xl {\n    display: block !important;\n  }\n}\n\n.tmpl_hh_wrapper br.tmpl_hh_lg, .tmpl_hh_wrapper p.tmpl_hh_lg, .tmpl_hh_wrapper div.tmpl_hh_lg {\n  display: none;\n}\n\n@media (min-width: 656px) and (max-width: 1019px) {\n  .tmpl_hh_wrapper br.tmpl_hh_lg, .tmpl_hh_wrapper p.tmpl_hh_lg, .tmpl_hh_wrapper div.tmpl_hh_lg {\n    display: block !important;\n  }\n}\n\n.tmpl_hh_wrapper br.tmpl_hh_md, .tmpl_hh_wrapper p.tmpl_hh_md, .tmpl_hh_wrapper div.tmpl_hh_md {\n  display: none;\n}\n\n@media (min-width: 414px) and (max-width: 655px) {\n  .tmpl_hh_wrapper br.tmpl_hh_md, .tmpl_hh_wrapper p.tmpl_hh_md, .tmpl_hh_wrapper div.tmpl_hh_md {\n    display: block !important;\n  }\n}\n\n.tmpl_hh_wrapper br.tmpl_hh_sm, .tmpl_hh_wrapper p.tmpl_hh_sm, .tmpl_hh_wrapper div.tmpl_hh_sm {\n  display: none;\n}\n\n@media (min-width: 0px) and (max-width: 413px) {\n  .tmpl_hh_wrapper br.tmpl_hh_sm, .tmpl_hh_wrapper p.tmpl_hh_sm, .tmpl_hh_wrapper div.tmpl_hh_sm {\n    display: block !important;\n  }\n}\n\n.tmpl_hh_flex {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.tmpl_hh_header {\n  position: relative;\n  padding-block-start: 50px;\n}\n\n.tmpl_hh_header__inner {\n  position: relative;\n  z-index: 9;\n  overflow: hidden;\n  padding: 40px;\n  border-radius: 20px;\n  background-color: #fafafa;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_header__inner {\n    padding: 20px;\n  }\n}\n\n.tmpl_hh_header__inner::before {\n  content: \"\";\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  display: block;\n  min-width: 40%;\n  min-height: 200%;\n  border-radius: 100%;\n  background-color: #6d42a1;\n  filter: blur(100px);\n  animation: anim1 6s ease-in-out infinite;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_header__inner::before {\n    min-width: 384px;\n    min-height: 218px;\n  }\n}\n\n.tmpl_hh_header__decoration {\n  position: absolute;\n  top: 0;\n  right: 5%;\n  z-index: 10;\n  min-width: 243px;\n  min-height: 253px;\n  background: url(\"https://img.hhcdn.ru/ichameleon/451460.png\") no-repeat center/contain;\n}\n\n@media (max-width: 1019px) {\n  .tmpl_hh_header__decoration {\n    right: 2%;\n    min-width: 223px;\n    min-height: 233px;\n  }\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_header__decoration {\n    min-width: 134px;\n    min-height: 166px;\n  }\n}\n\n.tmpl_hh_header__decoration::before, .tmpl_hh_header__decoration::after {\n  content: \"\";\n  position: absolute;\n  display: block;\n}\n\n.tmpl_hh_header__decoration::before {\n  top: 30%;\n  left: 0;\n  min-width: 62px;\n  min-height: 68px;\n  background: url(\"https://img.hhcdn.ru/ichameleon/451458.png\") no-repeat center/contain;\n  animation: head-anim-1 6s ease-in-out infinite;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_header__decoration::before {\n    min-width: 28px;\n    min-height: 35px;\n  }\n}\n\n.tmpl_hh_header__decoration::after {\n  top: 50%;\n  right: 0;\n  min-width: 27px;\n  min-height: 29px;\n  background: url(\"https://img.hhcdn.ru/ichameleon/451459.png\") no-repeat center/contain;\n  animation: head-anim-2 8s ease-in-out infinite;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_header__decoration::after {\n    min-width: 14px;\n    min-height: 15px;\n  }\n}\n\n.tmpl_hh_header__description {\n  position: relative;\n  z-index: 9;\n}\n\n.tmpl_hh_header__description--1 {\n  max-width: 349px;\n  max-height: 230px;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_header__description--1 {\n    display: none;\n  }\n}\n\n.tmpl_hh_header__description--2 {\n  display: none;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_header__description--2 {\n    display: block;\n    max-width: 270px;\n    max-height: 178px;\n  }\n}\n\n.tmpl_hh_header__description svg {\n  object-fit: contain;\n  width: 100%;\n  height: 100%;\n}\n\n.tmpl_hh_about {\n  padding: 32px 40px 0;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_about {\n    padding-right: 20px;\n    padding-left: 20px;\n  }\n}\n\n.tmpl_hh_about p {\n  font-size: 15px;\n  line-height: 130%;\n}\n\n.tmpl_hh_about p:not(:last-of-type) {\n  margin-bottom: 1em;\n}\n\n.tmpl_hh_content {\n  padding: 32px 40px;\n}\n\n.tmpl_hh_content h2, .tmpl_hh_content p.tmpl_hh_content_title, .tmpl_hh_content b.tmpl_hh_content_title, .tmpl_hh_content strong.tmpl_hh_content_title {\n  display: block;\n  margin-bottom: 16px;\n  font-weight: 700;\n  font-style: normal;\n  font-size: 24px;\n  line-height: 120%;\n  color: #6d42a1;\n}\n\n.tmpl_hh_content h2, .tmpl_hh_content p.tmpl_hh_content_title > b, .tmpl_hh_content p.tmpl_hh_content_title > strong {\n  font-weight: 700;\n  font-style: normal;\n  font-size: 24px;\n  line-height: 120%;\n  color: #6d42a1;\n}\n\n.tmpl_hh_content p, .tmpl_hh_content div {\n  font-weight: 400;\n  font-style: normal;\n  font-size: 15px;\n  line-height: 140%;\n}\n\n.tmpl_hh_content ul:not(:last-child) {\n  margin-bottom: 20px;\n}\n\n.tmpl_hh_content ul:last-child {\n  margin-bottom: 0;\n}\n\n.tmpl_hh_content ul li {\n  font-weight: 400;\n  font-style: normal;\n  font-size: 15px;\n  line-height: 140%;\n}\n\n.tmpl_hh_content ul li:not(:last-of-type) {\n  margin-bottom: 5px;\n}\n\n.tmpl_hh_content ul li::before {\n  width: 6px;\n  height: 6px;\n  background: #3d3d3d;\n  top: 7px;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_content {\n    padding: 32px 20px;\n  }\n  .tmpl_hh_content h2, .tmpl_hh_content p.tmpl_hh_content_title, .tmpl_hh_content b.tmpl_hh_content_title, .tmpl_hh_content strong.tmpl_hh_content_title {\n    display: block;\n    margin-bottom: 32px;\n    font-weight: 700;\n    font-style: normal;\n    font-size: 18px;\n    line-height: 120%;\n    color: #6d42a1;\n  }\n  .tmpl_hh_content h2, .tmpl_hh_content p.tmpl_hh_content_title > b, .tmpl_hh_content p.tmpl_hh_content_title > strong {\n    font-weight: 700;\n    font-style: normal;\n    font-size: 18px;\n    line-height: 120%;\n    color: #6d42a1;\n  }\n}\n\n.tmpl_hh_content .tmpl_hh_content_title {\n  padding: 4px 20px;\n  border-radius: 12px;\n  background: linear-gradient(270deg, #6b3fa0 0%, #fafafa 55.04%);\n}\n\n.tmpl_hh_content ul li:not(:last-of-type) {\n  margin-block-end: 12px;\n}\n\n.tmpl_hh_content ul li::before {\n  background: #6d42a1;\n}\n\n.tmpl_hh_aside {\n  position: relative;\n}\n\n.tmpl_hh_aside::before {\n  content: \"\";\n  position: absolute;\n  right: -20%;\n  bottom: 30%;\n  display: block;\n  min-width: 658px;\n  min-height: 294px;\n  border-radius: 100%;\n  background: #6d42a1;\n  filter: blur(200px);\n  animation: anim1 6s ease-in-out infinite;\n  rotate: -30deg;\n}\n\n.tmpl_hh_aside h4 {\n  position: relative;\n  z-index: 2;\n  color: #6b3fa0;\n  font-weight: 700;\n  font-size: 18px;\n  line-height: 120%;\n  margin-block-end: 32px;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_aside h4 {\n    font-size: 18px;\n  }\n}\n\n.tmpl_hh_aside h3 {\n  position: relative;\n  z-index: 2;\n  padding: 4px 20px;\n  border-radius: 12px;\n  background: linear-gradient(270deg, #6b3fa0 0%, #fafafa 55.04%);\n  color: #6b3fa0;\n  font-weight: 700;\n  font-size: 24px;\n  line-height: 120%;\n  margin-block-end: 12px;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_aside h3 {\n    margin-inline: 20px;\n    font-size: 18px;\n  }\n}\n\n.tmpl_hh_aside__inner {\n  position: relative;\n  z-index: 2;\n  padding-inline: 40px;\n  padding-block: 32px;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_aside__inner {\n    padding-inline: 20px;\n  }\n}\n\n.tmpl_hh_aside__slider {\n  position: relative;\n  z-index: 2;\n}\n\n.tmpl_hh_aside__slider__inner {\n  padding-inline: 40px;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_aside__slider__inner {\n    padding-inline: 52px;\n  }\n}\n\n.tmpl_hh_aside__slider .swiper__slide {\n  overflow: hidden;\n  border-radius: 5px;\n}\n\n.tmpl_hh_aside__slider .swiper__slide > img {\n  object-fit: cover;\n  width: 100%;\n  height: 100%;\n}\n\n.tmpl_hh_aside__slider .swiper__btns {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n}\n\n.tmpl_hh_aside__slider .swiper__btns .swiper-button-prev, .tmpl_hh_aside__slider .swiper__btns .swiper-button-next {\n  position: relative;\n  z-index: 9;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 40px;\n  height: 40px;\n}\n\n.tmpl_hh_aside__slider .swiper__btns .swiper-button-prev svg, .tmpl_hh_aside__slider .swiper__btns .swiper-button-next svg {\n  width: 8px;\n  height: 14px;\n}\n\n.tmpl_hh_aside ul.tmpl_hh_aside__list {\n  position: relative;\n  z-index: 2;\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: 12px;\n  margin-block-end: 32px;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_aside ul.tmpl_hh_aside__list {\n    grid-template-columns: 1fr;\n  }\n}\n\n.tmpl_hh_aside ul.tmpl_hh_aside__list li {\n  display: flex;\n  gap: 8px;\n  justify-content: space-between;\n  padding: 12px 16px;\n  border: 1px solid #e0e0e0;\n  border-radius: 20px;\n  background: #fff;\n  transition: border-color 0.3s ease-in-out;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_aside ul.tmpl_hh_aside__list li {\n    padding-right: 15px;\n    padding-left: 15px;\n  }\n}\n\n@media (max-width: 413px) {\n  .tmpl_hh_aside ul.tmpl_hh_aside__list li {\n    flex-direction: column-reverse;\n  }\n}\n\n.tmpl_hh_aside ul.tmpl_hh_aside__list li:hover {\n  border-color: #6b3fa0;\n}\n\n.tmpl_hh_aside ul.tmpl_hh_aside__list li:hover p {\n  color: #6b3fa0;\n}\n\n.tmpl_hh_aside ul.tmpl_hh_aside__list li:nth-of-type(1), .tmpl_hh_aside ul.tmpl_hh_aside__list li:nth-of-type(4), .tmpl_hh_aside ul.tmpl_hh_aside__list li:nth-of-type(7) {\n  grid-column: -1/1;\n}\n\n.tmpl_hh_aside ul.tmpl_hh_aside__list li p {\n  font-weight: 700;\n  font-size: 18px;\n  line-height: 24px;\n  transition: color 0.3s ease-in-out;\n  margin-block-end: 8px;\n}\n\n.tmpl_hh_aside ul.tmpl_hh_aside__list li span {\n  font-size: 15px;\n  line-height: 130%;\n}\n\n.tmpl_hh_aside ul.tmpl_hh_aside__list li img {\n  flex-shrink: 0;\n  object-fit: contain;\n  width: 100%;\n  max-width: 34px;\n  height: 100%;\n  max-height: 34px;\n}\n\n.tmpl_hh_atmosphere {\n  margin-bottom: 32px;\n}\n\n.tmpl_hh_atmosphere__video {\n  position: relative;\n  z-index: 10;\n  overflow: hidden;\n  border-radius: 26px;\n  aspect-ratio: 690/390;\n}\n\n.tmpl_hh_atmosphere__video > iframe {\n  width: 100%;\n  height: 100%;\n}\n\n.tmpl_hh_footer {\n  position: relative;\n  z-index: 2;\n}\n\n.tmpl_hh_footer span {\n  color: #e0e0e0;\n  font-size: 15px;\n  line-height: 120%;\n}\n\n@media (max-width: 655px) {\n  .tmpl_hh_footer span {\n    font-size: 12px;\n  }\n}/**\n * Swiper 9.4.1\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: June 13, 2023\n */\n\n@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper,swiper-container{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1;display:block}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);box-sizing:content-box}.swiper-android .swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}.swiper-slide,swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide,.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{transform-style:preserve-3d}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-horizontal.swiper-css-mode>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-vertical.swiper-css-mode>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-css-mode.swiper-free-mode>.swiper-wrapper{scroll-snap-type:none}.swiper-css-mode.swiper-free-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:none}.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center;scroll-snap-stop:always}.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader,.swiper:not(.swiper-watch-progress) .swiper-lazy-preloader,swiper-container:not(.swiper-watch-progress) .swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear}.swiper-lazy-preloader-white{--swiper-preloader-color:#fff}.swiper-lazy-preloader-black{--swiper-preloader-color:#000}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.swiper-fade.swiper-free-mode .swiper-slide{transition-timing-function:ease-out}.swiper-fade .swiper-slide{pointer-events:none;transition-property:opacity}.swiper-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-fade .swiper-slide-active,.swiper-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}\n</style>\n<div>\n  <div class=\"tmpl_hh_wrapper\">\n    <header class=\"tmpl_hh_header\">\n      <div class=\"tmpl_hh_header__inner\">\n        <div class=\"tmpl_hh_header__description tmpl_hh_header__description--1\">\n          <svg width=\"349\" height=\"129\" viewBox=\"0 0 349 129\" fill=\"none\">\n            <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M117.188 15.319C117.188 17.5842 118.828 19.133 121.508 19.133H122.571C123.957 19.133 125.159 18.5783 125.782 17.3761C126.06 18.1621 126.729 18.8096 128.001 18.8096H129.113C129.213 18.8096 129.294 18.728 129.294 18.6282V16.7954C129.294 16.6956 129.213 16.614 129.113 16.614H128.739C128.046 16.614 127.769 16.2442 127.769 15.1116V11.5283C127.769 8.47709 126.175 6.67381 122.825 6.67381H122.571C119.988 6.67381 118.125 7.83241 117.62 10.3401C117.609 10.395 117.622 10.447 117.658 10.4913C117.693 10.5349 117.742 10.5581 117.798 10.5581H120.024C120.108 10.5581 120.178 10.5039 120.199 10.4231C120.434 9.545 121.247 8.91649 122.478 8.91649H123.033C124.419 8.91649 125.297 9.74888 125.297 10.9504V11.5515H121.509C118.829 11.5515 117.188 13.0531 117.188 15.319ZM133.839 3.62898H131.661C131.561 3.62898 131.48 3.71053 131.48 3.81036V14.1632C131.48 17.3072 133.397 18.8096 136.424 18.8096H137.721C137.821 18.8096 137.902 18.728 137.902 18.6282V16.6562C137.902 16.5564 137.821 16.4748 137.721 16.4748H136.817C135.292 16.4748 134.021 15.9201 134.021 13.9783V9.26238H137.863C137.963 9.26238 138.044 9.18083 138.044 9.081V7.15539C138.044 7.05556 137.963 6.97401 137.863 6.97401H134.021V3.81036C134.021 3.71053 133.939 3.62898 133.839 3.62898ZM33.9094 19.133C30.4442 19.133 27.8563 16.5437 27.8563 13.0763V8.1066C27.8563 4.63924 30.4442 2.04996 33.9094 2.04996H35.4575C39.1512 2.04996 41.422 4.74118 41.5078 7.92029C41.5092 7.97091 41.4916 8.0152 41.4565 8.05176C41.4213 8.08832 41.377 8.1066 41.3264 8.1066H39.0528C38.9558 8.1066 38.8763 8.03067 38.8714 7.93365C38.7765 5.90751 37.4091 4.63924 35.3415 4.63924H34.0704C31.8987 4.63924 30.5355 6.00312 30.5355 8.1994V12.9385C30.5355 15.1348 31.8987 16.5219 34.0704 16.5219H35.3415C37.4534 16.5219 38.8004 15.2318 38.8728 13.1832C38.8763 13.0855 38.9565 13.0081 39.0542 13.0081H41.3489C41.3995 13.0081 41.4438 13.0264 41.479 13.063C41.5141 13.0995 41.5317 13.1438 41.5303 13.1944C41.4459 16.5268 39.0858 19.1344 35.4568 19.1344H33.9087L33.9094 19.133ZM89.3021 3.62898H87.1241C87.0243 3.62898 86.9427 3.71053 86.9427 3.81036V14.1632C86.9427 17.3072 88.8599 18.8096 91.8864 18.8096H93.1835C93.2834 18.8096 93.3649 18.728 93.3649 18.6282V16.6562C93.3649 16.5564 93.2834 16.4748 93.1835 16.4748H92.2794C90.7546 16.4748 89.4842 15.9201 89.4842 13.9783V9.26238H93.3256C93.4254 9.26238 93.5069 9.18083 93.5069 9.081V7.15539C93.5069 7.05556 93.4254 6.97401 93.3256 6.97401H89.4842V3.81036C89.4842 3.71053 89.4019 3.62898 89.3021 3.62898ZM81.1413 18.6282V6.80739C81.1413 6.70756 81.2228 6.62601 81.3227 6.62601H83.5014C83.6012 6.62601 83.6828 6.70756 83.6828 6.80739V18.6282C83.6828 18.728 83.6012 18.8096 83.5014 18.8096H81.3227C81.2228 18.8096 81.1413 18.728 81.1413 18.6282ZM81.1181 4.96685V2.55615C81.1181 2.45632 81.1996 2.37477 81.2995 2.37477H83.5007C83.6005 2.37477 83.682 2.45632 83.682 2.55615V4.96685C83.682 5.06668 83.6005 5.14823 83.5007 5.14823H81.2995C81.1996 5.14823 81.1181 5.06668 81.1181 4.96685ZM51.3713 9.197V7.1561C51.3713 7.05626 51.2898 6.97471 51.19 6.97471H49.5927C46.3812 6.97471 44.4408 8.73159 44.4408 11.9445V18.6282C44.4408 18.728 44.5224 18.8096 44.6222 18.8096H46.8009C46.9008 18.8096 46.9823 18.728 46.9823 18.6282V12.1982C46.9823 10.5574 48.091 9.37838 49.6391 9.37838H51.1907C51.2905 9.37838 51.3713 9.29683 51.3713 9.197ZM4.53878 0.430879C2.03247 0.430879 0 2.46405 0 4.97177V10.3036C0 10.4245 0.0977216 10.5222 0.218643 10.5222H9.9662C10.0323 10.5222 10.085 10.5756 10.085 10.6417V20.3949C10.085 20.5158 10.1827 20.6136 10.3037 20.6136H11.8834C12.0043 20.6136 12.102 20.5158 12.102 20.3949V8.74214C12.102 8.61067 11.9952 8.50381 11.8637 8.50381H2.97594C2.90985 8.50381 2.85713 8.45038 2.85713 8.38429V6.60492C2.85713 6.53883 2.91056 6.4854 2.97594 6.4854H13.9995C14.0656 6.4854 14.1183 6.53883 14.1183 6.60492V20.3949C14.1183 20.5158 14.216 20.6136 14.337 20.6136H15.6312C15.7353 20.6136 15.8379 20.61 15.9399 20.603C16.051 20.5953 16.1346 20.5011 16.1346 20.39V4.70602C16.1346 4.57456 16.0278 4.4677 15.8963 4.4677H5.83166C5.76558 4.4677 5.71285 4.41427 5.71285 4.34818V2.5688C5.71285 2.50272 5.76628 2.44929 5.83166 2.44929H17.8149C18.0005 2.44929 18.1509 2.59974 18.1509 2.78534V19.4395C18.1509 19.6145 18.3442 19.7165 18.4806 19.6061C19.5099 18.7737 20.1686 17.4998 20.1686 16.072V1.43903C20.1686 0.881523 19.7173 0.430176 19.1598 0.430176H4.53597L4.53878 0.430879ZM8.06871 20.3752C8.06871 20.5067 7.96185 20.6136 7.83038 20.6136H1.00885C0.45205 20.6136 0 20.1615 0 19.6047V12.779C0 12.6475 0.106861 12.5406 0.238328 12.5406H7.83038C7.96185 12.5406 8.06871 12.6475 8.06871 12.779V20.3752ZM58.415 19.133C55.0426 19.133 53.2168 17.2608 53.2168 13.9551V11.8285C53.2168 8.54599 55.0419 6.67381 58.415 6.67381H58.9001C62.2501 6.67381 64.0751 8.54599 64.0751 11.8285V13.715C64.0751 13.8476 63.9676 13.9551 63.835 13.9551H55.7351V14.0936C55.7351 15.8505 56.6821 16.8446 58.3918 16.8446H58.9001C60.1206 16.8446 60.9354 16.3328 61.3052 15.4533C61.334 15.3844 61.398 15.3422 61.4725 15.3422H63.7363C63.7932 15.3422 63.8424 15.3661 63.8783 15.4104C63.9142 15.4554 63.9261 15.5081 63.9134 15.5644C63.3897 17.8527 61.6764 19.1337 58.9008 19.1337L58.415 19.133ZM55.7351 11.9206H61.5801V11.6893C61.5801 9.90917 60.6331 8.93828 58.9233 8.93828H58.3918C56.6828 8.93828 55.7351 9.90917 55.7351 11.6893V11.9206ZM66.8036 13.9551C66.8036 17.2608 68.6287 19.133 72.0019 19.133H72.6022C75.9986 19.133 77.8005 17.2608 77.8005 13.9551V2.55545C77.8005 2.45561 77.7189 2.37406 77.6191 2.37406H75.4411C75.3413 2.37406 75.2597 2.45561 75.2597 2.55545V6.71951L75.3293 7.8985C74.6825 7.13571 73.7348 6.67311 72.3724 6.67311H71.5864C68.6294 6.67311 66.8043 8.54529 66.8043 11.8278L66.8036 13.9551ZM75.259 13.9783C75.259 15.7352 74.3352 16.7293 72.579 16.7293H72.0243C70.3146 16.7293 69.3676 15.7352 69.3676 13.9783V11.8285C69.3676 10.0484 70.3146 9.05429 72.0243 9.05429H72.579C74.3352 9.05429 75.259 10.0484 75.259 11.8285V13.9783ZM101 18.6282V2.55545C101 2.45561 101.081 2.37406 101.181 2.37406H108.323C111.858 2.37406 114.422 4.89373 114.422 8.36109V12.8225C114.422 16.2899 111.812 18.8096 108.323 18.8096H101.181C101.081 18.8096 101 18.728 101 18.6282ZM108.185 16.221C110.357 16.221 111.743 14.9035 111.743 12.7072V8.4539C111.743 6.25762 110.357 4.94013 108.185 4.94013H103.815C103.715 4.94013 103.633 5.02169 103.633 5.12152V16.0396C103.633 16.1395 103.715 16.221 103.815 16.221H108.185ZM144.214 19.1337C141.534 19.1337 139.894 17.5849 139.894 15.3197C139.894 13.0545 141.534 11.5515 144.214 11.5515H148.003V10.9504C148.003 9.74818 147.124 8.91649 145.738 8.91649H145.183C143.952 8.91649 143.139 9.545 142.904 10.4231C142.882 10.5039 142.812 10.5581 142.729 10.5581H140.504C140.448 10.5581 140.399 10.5349 140.363 10.4913C140.328 10.4477 140.315 10.3957 140.326 10.3401C140.831 7.83241 142.693 6.67381 145.277 6.67381H145.531C148.881 6.67381 150.475 8.47709 150.475 11.5283V15.1116C150.475 16.2442 150.752 16.614 151.445 16.614H151.819C151.918 16.614 152 16.6956 152 16.7954V18.6282C152 18.728 151.918 18.8096 151.819 18.8096H150.706C149.435 18.8096 148.765 18.1621 148.488 17.3761C147.865 18.5783 146.663 19.133 145.277 19.133L144.214 19.1337ZM145.323 16.9838C146.824 16.9838 148.003 16.221 148.003 14.5337V13.5164H144.676C143.289 13.5164 142.504 14.2328 142.504 15.2501C142.504 16.2906 143.289 16.9838 144.676 16.9838H145.323ZM125.296 14.5337C125.296 16.221 124.118 16.9838 122.616 16.9838H121.969C120.584 16.9838 119.798 16.2906 119.798 15.2501C119.798 14.2328 120.584 13.5164 121.969 13.5164H125.296V14.5337Z\" fill=\"#6B3FA0\"></path>\n            <path d=\"M11.412 77.4336V75.1296C9.876 75.0336 8.424 74.7096 7.056 74.1576C5.688 73.6056 4.476 72.8376 3.42 71.8536C2.364 70.8696 1.524 69.7056 0.9 68.3616C0.3 66.9936 0 65.4936 0 63.8616C0 62.1336 0.312 60.5976 0.936 59.2536C1.584 57.8856 2.448 56.7216 3.528 55.7616C4.608 54.7776 5.82 54.0216 7.164 53.4936C8.532 52.9656 9.948 52.6536 11.412 52.5576V50.6136H16.128V52.5576C17.592 52.6536 19.008 52.9776 20.376 53.5296C21.744 54.0576 22.956 54.8136 24.012 55.7976C25.092 56.7576 25.944 57.9216 26.568 59.2896C27.192 60.6336 27.504 62.1576 27.504 63.8616C27.504 65.5416 27.192 67.0536 26.568 68.3976C25.968 69.7416 25.128 70.9056 24.048 71.8896C22.992 72.8736 21.78 73.6416 20.412 74.1936C19.044 74.7216 17.616 75.0336 16.128 75.1296V77.4336H11.412ZM11.556 71.1336V56.5536C10.356 56.6256 9.252 56.9616 8.244 57.5616C7.236 58.1616 6.432 58.9896 5.832 60.0456C5.256 61.0776 4.968 62.3496 4.968 63.8616C4.968 64.9896 5.148 65.9976 5.508 66.8856C5.868 67.7496 6.348 68.4936 6.948 69.1176C7.572 69.7176 8.28 70.1976 9.072 70.5576C9.864 70.8936 10.692 71.0856 11.556 71.1336ZM15.984 71.1336C17.16 71.0376 18.252 70.7016 19.26 70.1256C20.268 69.5256 21.072 68.7096 21.672 67.6776C22.272 66.6216 22.572 65.3496 22.572 63.8616C22.572 62.7336 22.392 61.7376 22.032 60.8736C21.696 60.0096 21.216 59.2656 20.592 58.6416C19.992 58.0176 19.296 57.5256 18.504 57.1656C17.712 56.8056 16.872 56.6016 15.984 56.5536V71.1336Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M30.6816 77.4336V58.6056H35.5056V70.9896L43.9656 58.5696H48.3576V77.4336H43.5336V65.3376L35.1816 77.4336H30.6816Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M52.7597 77.4336V58.5696H57.5837V65.7696H65.2157V58.5696H70.0397V77.4336H65.2157V69.8016H57.5837V77.4336H52.7597Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M78.8071 77.4336V62.7816H72.8311V58.5696H89.6431V62.7816H83.6311V77.4336H78.8071Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M101.094 77.7936C99.5816 77.7936 98.2136 77.5416 96.9896 77.0376C95.7656 76.5096 94.7216 75.8016 93.8576 74.9136C92.9936 74.0016 92.3216 72.9696 91.8416 71.8176C91.3856 70.6416 91.1576 69.4056 91.1576 68.1096C91.1576 66.3096 91.5536 64.6656 92.3456 63.1776C93.1616 61.6896 94.3136 60.5016 95.8016 59.6136C97.3136 58.7016 99.0896 58.2456 101.13 58.2456C103.194 58.2456 104.958 58.7016 106.422 59.6136C107.886 60.5016 109.002 61.6896 109.77 63.1776C110.562 64.6416 110.958 66.2256 110.958 67.9296C110.958 68.2176 110.946 68.5176 110.922 68.8296C110.898 69.1176 110.874 69.3576 110.85 69.5496H96.2696C96.3656 70.5096 96.6416 71.3496 97.0976 72.0696C97.5776 72.7896 98.1776 73.3416 98.8976 73.7256C99.6416 74.0856 100.434 74.2656 101.274 74.2656C102.234 74.2656 103.134 74.0376 103.974 73.5816C104.838 73.1016 105.426 72.4776 105.738 71.7096L109.878 72.8616C109.422 73.8216 108.762 74.6736 107.898 75.4176C107.058 76.1616 106.062 76.7496 104.91 77.1816C103.758 77.5896 102.486 77.7936 101.094 77.7936ZM96.1616 66.4896H106.026C105.93 65.5296 105.654 64.7016 105.198 64.0056C104.766 63.2856 104.19 62.7336 103.47 62.3496C102.75 61.9416 101.946 61.7376 101.058 61.7376C100.194 61.7376 99.4016 61.9416 98.6816 62.3496C97.9856 62.7336 97.4096 63.2856 96.9536 64.0056C96.5216 64.7016 96.2576 65.5296 96.1616 66.4896Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M116.992 58.5696L120.952 64.4736L121.24 65.1216L121.6 64.4736L125.524 58.5696H130.6L124.048 67.9656L130.708 77.4336H125.632L121.564 71.5656L121.24 70.9536L120.952 71.5656L116.92 77.4336H111.844L118.504 68.0736L111.952 58.5696H116.992Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M132.386 69.7296V65.3736H143.294V69.7296H132.386Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M155.209 77.7576C153.937 77.7576 152.737 77.5776 151.609 77.2176C150.505 76.8576 149.521 76.3296 148.657 75.6336C147.817 74.9136 147.133 74.0736 146.605 73.1136L150.457 71.3136C150.937 72.1776 151.561 72.8376 152.329 73.2936C153.097 73.7256 153.961 73.9416 154.921 73.9416C155.809 73.9416 156.613 73.7496 157.333 73.3656C158.053 72.9576 158.653 72.4176 159.133 71.7456C159.637 71.0736 159.961 70.3176 160.105 69.4776H153.481V66.3456H160.069C159.901 65.5776 159.589 64.8696 159.133 64.2216C158.677 63.5736 158.089 63.0576 157.369 62.6736C156.673 62.2896 155.857 62.0976 154.921 62.0976C153.985 62.0976 153.145 62.2896 152.401 62.6736C151.657 63.0576 151.033 63.6816 150.529 64.5456L146.893 62.6376C147.637 61.2936 148.717 60.2256 150.133 59.4336C151.549 58.6416 153.229 58.2456 155.173 58.2456C156.781 58.2456 158.197 58.5096 159.421 59.0376C160.645 59.5656 161.677 60.2976 162.517 61.2336C163.357 62.1456 163.993 63.1896 164.425 64.3656C164.857 65.5176 165.073 66.7176 165.073 67.9656C165.073 69.2376 164.857 70.4616 164.425 71.6376C163.993 72.7896 163.345 73.8336 162.481 74.7696C161.641 75.6816 160.609 76.4136 159.385 76.9656C158.161 77.4936 156.769 77.7576 155.209 77.7576Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M168.283 77.4336V58.5696H173.107V65.6976H174.727L179.839 58.5696H185.095L178.399 67.6776L185.815 77.4336H180.307L174.655 69.9456H173.107V77.4336H168.283Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M196.614 77.7936C195.078 77.7936 193.698 77.5416 192.474 77.0376C191.25 76.5096 190.206 75.7896 189.342 74.8776C188.478 73.9416 187.806 72.8856 187.326 71.7096C186.87 70.5336 186.642 69.2976 186.642 68.0016C186.642 66.2256 187.038 64.6056 187.83 63.1416C188.646 61.6536 189.798 60.4656 191.286 59.5776C192.774 58.6896 194.538 58.2456 196.578 58.2456C198.618 58.2456 200.37 58.6896 201.834 59.5776C203.298 60.4656 204.39 61.6296 205.11 63.0696L200.394 64.5096C199.986 63.8136 199.446 63.2856 198.774 62.9256C198.102 62.5416 197.358 62.3496 196.542 62.3496C195.63 62.3496 194.79 62.5896 194.022 63.0696C193.278 63.5256 192.69 64.1856 192.258 65.0496C191.826 65.8896 191.61 66.8736 191.61 68.0016C191.61 69.1056 191.826 70.0896 192.258 70.9536C192.714 71.7936 193.314 72.4656 194.058 72.9696C194.802 73.4496 195.63 73.6896 196.542 73.6896C197.118 73.6896 197.658 73.5936 198.162 73.4016C198.69 73.2096 199.158 72.9456 199.566 72.6096C199.974 72.2736 200.274 71.8896 200.466 71.4576L205.182 72.8976C204.75 73.8336 204.114 74.6736 203.274 75.4176C202.458 76.1616 201.486 76.7496 200.358 77.1816C199.254 77.5896 198.006 77.7936 196.614 77.7936Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M208.15 77.4336V58.5696H225.07V77.4336H220.246V62.7816H212.974V77.4336H208.15Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M238.203 77.7936C236.691 77.7936 235.323 77.5416 234.099 77.0376C232.875 76.5096 231.831 75.8016 230.967 74.9136C230.103 74.0016 229.431 72.9696 228.951 71.8176C228.495 70.6416 228.267 69.4056 228.267 68.1096C228.267 66.3096 228.663 64.6656 229.455 63.1776C230.271 61.6896 231.423 60.5016 232.911 59.6136C234.423 58.7016 236.199 58.2456 238.239 58.2456C240.303 58.2456 242.067 58.7016 243.531 59.6136C244.995 60.5016 246.111 61.6896 246.879 63.1776C247.671 64.6416 248.067 66.2256 248.067 67.9296C248.067 68.2176 248.055 68.5176 248.031 68.8296C248.007 69.1176 247.983 69.3576 247.959 69.5496H233.379C233.475 70.5096 233.751 71.3496 234.207 72.0696C234.687 72.7896 235.287 73.3416 236.007 73.7256C236.751 74.0856 237.543 74.2656 238.383 74.2656C239.343 74.2656 240.243 74.0376 241.083 73.5816C241.947 73.1016 242.535 72.4776 242.847 71.7096L246.987 72.8616C246.531 73.8216 245.871 74.6736 245.007 75.4176C244.167 76.1616 243.171 76.7496 242.019 77.1816C240.867 77.5896 239.595 77.7936 238.203 77.7936ZM233.271 66.4896H243.135C243.039 65.5296 242.763 64.7016 242.307 64.0056C241.875 63.2856 241.299 62.7336 240.579 62.3496C239.859 61.9416 239.055 61.7376 238.167 61.7376C237.303 61.7376 236.511 61.9416 235.791 62.3496C235.095 62.7336 234.519 63.2856 234.063 64.0056C233.631 64.7016 233.367 65.5296 233.271 66.4896Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M262.31 77.7936C260.846 77.7936 259.55 77.4696 258.422 76.8216C257.318 76.1496 256.454 75.2496 255.83 74.1216V85.1016H251.006V58.5696H255.218V61.8096C255.938 60.7056 256.85 59.8416 257.954 59.2176C259.058 58.5696 260.318 58.2456 261.734 58.2456C263.006 58.2456 264.17 58.4976 265.226 59.0016C266.306 59.5056 267.242 60.2136 268.034 61.1256C268.826 62.0136 269.438 63.0456 269.87 64.2216C270.326 65.3736 270.554 66.6216 270.554 67.9656C270.554 69.7896 270.194 71.4456 269.474 72.9336C268.778 74.4216 267.806 75.6096 266.558 76.4976C265.334 77.3616 263.918 77.7936 262.31 77.7936ZM260.69 73.6896C261.434 73.6896 262.106 73.5336 262.706 73.2216C263.306 72.9096 263.822 72.4896 264.254 71.9616C264.71 71.4096 265.046 70.7976 265.262 70.1256C265.502 69.4296 265.622 68.7096 265.622 67.9656C265.622 67.1736 265.49 66.4416 265.226 65.7696C264.986 65.0976 264.626 64.5096 264.146 64.0056C263.666 63.4776 263.102 63.0696 262.454 62.7816C261.83 62.4936 261.146 62.3496 260.402 62.3496C259.946 62.3496 259.478 62.4336 258.998 62.6016C258.542 62.7456 258.098 62.9616 257.666 63.2496C257.234 63.5376 256.85 63.8736 256.514 64.2576C256.202 64.6416 255.974 65.0616 255.83 65.5176V69.9456C256.118 70.6416 256.502 71.2776 256.982 71.8536C257.486 72.4296 258.062 72.8856 258.71 73.2216C259.358 73.5336 260.018 73.6896 260.69 73.6896Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M278.178 77.4336V62.7816H272.202V58.5696H289.014V62.7816H283.002V77.4336H278.178Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M291.717 77.4336V58.6056H296.541V70.9896L305.001 58.5696H309.393V77.4336H304.569V65.3376L296.217 77.4336H291.717Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M320.527 77.7216C318.511 77.7216 316.831 77.3616 315.487 76.6416C314.143 75.9216 313.087 74.9256 312.319 73.6536L316.207 71.8896C316.615 72.5136 317.143 73.0056 317.791 73.3656C318.463 73.7016 319.291 73.8696 320.275 73.8696C321.403 73.8696 322.267 73.6536 322.867 73.2216C323.491 72.7656 323.803 72.1776 323.803 71.4576C323.803 70.7856 323.551 70.2456 323.047 69.8376C322.543 69.4296 321.799 69.2256 320.815 69.2256H318.871V66.2376H320.851C321.307 66.2376 321.691 66.1536 322.003 65.9856C322.339 65.7936 322.591 65.5416 322.759 65.2296C322.951 64.9176 323.047 64.5576 323.047 64.1496C323.047 63.5496 322.807 63.0576 322.327 62.6736C321.871 62.2896 321.139 62.0976 320.131 62.0976C319.291 62.0976 318.595 62.2536 318.043 62.5656C317.515 62.8776 317.071 63.3456 316.711 63.9696L313.075 62.0256C313.747 60.8496 314.707 59.9256 315.955 59.2536C317.227 58.5816 318.703 58.2456 320.383 58.2456C321.703 58.2456 322.879 58.4496 323.911 58.8576C324.967 59.2656 325.795 59.8536 326.395 60.6216C326.995 61.3896 327.295 62.3496 327.295 63.5016C327.295 64.3176 327.091 65.1096 326.683 65.8776C326.299 66.6456 325.663 67.2096 324.775 67.5696C325.927 67.9056 326.791 68.4816 327.367 69.2976C327.967 70.1136 328.267 71.0736 328.267 72.1776C328.267 73.3776 327.931 74.3976 327.259 75.2376C326.587 76.0536 325.675 76.6776 324.523 77.1096C323.371 77.5176 322.039 77.7216 320.527 77.7216Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M330.358 71.8536C330.358 70.6296 330.694 69.5616 331.366 68.6496C332.062 67.7136 333.022 66.9936 334.246 66.4896C335.47 65.9856 336.874 65.7336 338.458 65.7336C339.25 65.7336 340.054 65.7936 340.87 65.9136C341.686 66.0336 342.394 66.2256 342.994 66.4896V65.4816C342.994 64.2816 342.634 63.3576 341.914 62.7096C341.218 62.0616 340.174 61.7376 338.782 61.7376C337.75 61.7376 336.766 61.9176 335.83 62.2776C334.894 62.6376 333.91 63.1656 332.878 63.8616L331.33 60.6936C332.578 59.8776 333.85 59.2656 335.146 58.8576C336.466 58.4496 337.846 58.2456 339.286 58.2456C341.974 58.2456 344.062 58.9176 345.55 60.2616C347.062 61.6056 347.818 63.5256 347.818 66.0216V72.0336C347.818 72.5376 347.902 72.8976 348.07 73.1136C348.262 73.3296 348.562 73.4616 348.97 73.5096V77.4336C348.538 77.5056 348.142 77.5656 347.782 77.6136C347.446 77.6616 347.158 77.6856 346.918 77.6856C345.958 77.6856 345.226 77.4696 344.722 77.0376C344.242 76.6056 343.942 76.0776 343.822 75.4536L343.714 74.4816C342.898 75.5376 341.878 76.3536 340.654 76.9296C339.43 77.5056 338.182 77.7936 336.91 77.7936C335.662 77.7936 334.534 77.5416 333.526 77.0376C332.542 76.5096 331.762 75.8016 331.186 74.9136C330.634 74.0016 330.358 72.9816 330.358 71.8536ZM342.094 72.8256C342.358 72.5376 342.574 72.2496 342.742 71.9616C342.91 71.6736 342.994 71.4096 342.994 71.1696V69.2616C342.418 69.0216 341.794 68.8416 341.122 68.7216C340.45 68.5776 339.814 68.5056 339.214 68.5056C337.966 68.5056 336.934 68.7816 336.118 69.3336C335.326 69.8616 334.93 70.5696 334.93 71.4576C334.93 71.9376 335.062 72.3936 335.326 72.8256C335.59 73.2576 335.974 73.6056 336.478 73.8696C336.982 74.1336 337.582 74.2656 338.278 74.2656C338.998 74.2656 339.706 74.1336 340.402 73.8696C341.098 73.5816 341.662 73.2336 342.094 72.8256Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M1.08 120.434V101.57H5.904V108.77H13.536V101.57H18.36V120.434H13.536V112.802H5.904V120.434H1.08Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M21.4754 114.854C21.4754 113.63 21.8114 112.562 22.4834 111.65C23.1794 110.714 24.1394 109.994 25.3634 109.49C26.5874 108.986 27.9914 108.734 29.5754 108.734C30.3674 108.734 31.1714 108.794 31.9874 108.914C32.8034 109.034 33.5114 109.226 34.1114 109.49V108.482C34.1114 107.282 33.7514 106.358 33.0314 105.71C32.3354 105.062 31.2914 104.738 29.8994 104.738C28.8674 104.738 27.8834 104.918 26.9474 105.278C26.0114 105.638 25.0274 106.166 23.9954 106.862L22.4474 103.694C23.6954 102.878 24.9674 102.266 26.2634 101.858C27.5834 101.45 28.9634 101.246 30.4034 101.246C33.0914 101.246 35.1794 101.918 36.6674 103.262C38.1794 104.606 38.9354 106.526 38.9354 109.022V115.034C38.9354 115.538 39.0194 115.898 39.1874 116.114C39.3794 116.33 39.6794 116.462 40.0874 116.51V120.434C39.6554 120.506 39.2594 120.566 38.8994 120.614C38.5634 120.662 38.2754 120.686 38.0354 120.686C37.0754 120.686 36.3434 120.47 35.8394 120.038C35.3594 119.606 35.0594 119.078 34.9394 118.454L34.8314 117.482C34.0154 118.538 32.9954 119.354 31.7714 119.93C30.5474 120.506 29.2994 120.794 28.0274 120.794C26.7794 120.794 25.6514 120.542 24.6434 120.038C23.6594 119.51 22.8794 118.802 22.3034 117.914C21.7514 117.002 21.4754 115.982 21.4754 114.854ZM33.2114 115.826C33.4754 115.538 33.6914 115.25 33.8594 114.962C34.0274 114.674 34.1114 114.41 34.1114 114.17V112.262C33.5354 112.022 32.9114 111.842 32.2394 111.722C31.5674 111.578 30.9314 111.506 30.3314 111.506C29.0834 111.506 28.0514 111.782 27.2354 112.334C26.4434 112.862 26.0474 113.57 26.0474 114.458C26.0474 114.938 26.1794 115.394 26.4434 115.826C26.7074 116.258 27.0914 116.606 27.5954 116.87C28.0994 117.134 28.6994 117.266 29.3954 117.266C30.1154 117.266 30.8234 117.134 31.5194 116.87C32.2154 116.582 32.7794 116.234 33.2114 115.826Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M52.0917 120.434V101.57H62.6037C63.8997 101.57 64.9437 101.786 65.7357 102.218C66.5517 102.65 67.1517 103.214 67.5357 103.91C67.9197 104.606 68.1117 105.35 68.1117 106.142C68.1117 107.198 67.8717 108.122 67.3917 108.914C66.9357 109.706 66.2157 110.318 65.2317 110.75C66.3357 111.062 67.2357 111.602 67.9317 112.37C68.6277 113.114 68.9757 114.098 68.9757 115.322C68.9757 116.498 68.6997 117.47 68.1477 118.238C67.5957 118.982 66.8037 119.534 65.7717 119.894C64.7397 120.254 63.5157 120.434 62.0997 120.434H52.0917ZM56.6637 117.158H61.9557C62.3877 117.158 62.7837 117.05 63.1437 116.834C63.5037 116.618 63.7797 116.33 63.9717 115.97C64.1877 115.61 64.2957 115.214 64.2957 114.782C64.2957 114.326 64.1997 113.93 64.0077 113.594C63.8157 113.234 63.5397 112.958 63.1797 112.766C62.8437 112.55 62.4477 112.442 61.9917 112.442H56.6637V117.158ZM56.6637 109.418H61.3797C61.8117 109.418 62.1957 109.31 62.5317 109.094C62.8677 108.878 63.1197 108.59 63.2877 108.23C63.4797 107.87 63.5757 107.474 63.5757 107.042C63.5757 106.418 63.3717 105.902 62.9637 105.494C62.5797 105.062 62.0637 104.846 61.4157 104.846H56.6637V109.418Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M72.4823 120.434V101.57H77.3063V107.51H80.6183C82.8983 107.51 84.6383 108.086 85.8383 109.238C87.0383 110.39 87.6383 111.914 87.6383 113.81C87.6383 115.082 87.3743 116.222 86.8463 117.23C86.3423 118.238 85.5983 119.03 84.6143 119.606C83.6303 120.158 82.4063 120.434 80.9423 120.434H72.4823ZM77.3063 116.762H80.1863C80.8583 116.762 81.3983 116.63 81.8063 116.366C82.2143 116.102 82.5143 115.754 82.7063 115.322C82.9223 114.89 83.0303 114.398 83.0303 113.846C83.0303 113.318 82.9343 112.85 82.7423 112.442C82.5503 112.01 82.2383 111.674 81.8063 111.434C81.3983 111.17 80.8463 111.038 80.1503 111.038H77.3063V116.762ZM90.5903 120.434V101.606H95.4143V120.434H90.5903Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M108.618 120.794C107.082 120.794 105.702 120.542 104.478 120.038C103.254 119.51 102.21 118.79 101.346 117.878C100.482 116.942 99.8099 115.886 99.3299 114.71C98.8739 113.534 98.6459 112.298 98.6459 111.002C98.6459 109.226 99.0419 107.606 99.8339 106.142C100.65 104.654 101.802 103.466 103.29 102.578C104.778 101.69 106.542 101.246 108.582 101.246C110.622 101.246 112.374 101.69 113.838 102.578C115.302 103.466 116.394 104.63 117.114 106.07L112.398 107.51C111.99 106.814 111.45 106.286 110.778 105.926C110.106 105.542 109.362 105.35 108.546 105.35C107.634 105.35 106.794 105.59 106.026 106.07C105.282 106.526 104.694 107.186 104.262 108.05C103.83 108.89 103.614 109.874 103.614 111.002C103.614 112.106 103.83 113.09 104.262 113.954C104.718 114.794 105.318 115.466 106.062 115.97C106.806 116.45 107.634 116.69 108.546 116.69C109.122 116.69 109.662 116.594 110.166 116.402C110.694 116.21 111.162 115.946 111.57 115.61C111.978 115.274 112.278 114.89 112.47 114.458L117.186 115.898C116.754 116.834 116.118 117.674 115.278 118.418C114.462 119.162 113.49 119.75 112.362 120.182C111.258 120.59 110.01 120.794 108.618 120.794Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M128.69 120.794C127.154 120.794 125.774 120.542 124.55 120.038C123.326 119.51 122.282 118.79 121.418 117.878C120.578 116.966 119.93 115.922 119.474 114.746C119.018 113.57 118.79 112.334 118.79 111.038C118.79 109.718 119.018 108.47 119.474 107.294C119.93 106.118 120.578 105.074 121.418 104.162C122.282 103.25 123.326 102.542 124.55 102.038C125.774 101.51 127.154 101.246 128.69 101.246C130.226 101.246 131.594 101.51 132.794 102.038C134.018 102.542 135.062 103.25 135.926 104.162C136.79 105.074 137.438 106.118 137.87 107.294C138.326 108.47 138.554 109.718 138.554 111.038C138.554 112.334 138.326 113.57 137.87 114.746C137.438 115.922 136.79 116.966 135.926 117.878C135.086 118.79 134.054 119.51 132.83 120.038C131.606 120.542 130.226 120.794 128.69 120.794ZM123.758 111.038C123.758 112.142 123.974 113.126 124.406 113.99C124.838 114.83 125.426 115.49 126.17 115.97C126.914 116.45 127.754 116.69 128.69 116.69C129.602 116.69 130.43 116.45 131.174 115.97C131.918 115.466 132.506 114.794 132.938 113.954C133.394 113.09 133.622 112.106 133.622 111.002C133.622 109.922 133.394 108.95 132.938 108.086C132.506 107.222 131.918 106.55 131.174 106.07C130.43 105.59 129.602 105.35 128.69 105.35C127.754 105.35 126.914 105.602 126.17 106.106C125.426 106.586 124.838 107.258 124.406 108.122C123.974 108.962 123.758 109.934 123.758 111.038Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M141.81 120.434V101.57H146.634V108.698H148.254L153.366 101.57H158.622L151.926 110.678L159.342 120.434H153.834L148.182 112.946H146.634V120.434H141.81Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M170.069 120.794C168.533 120.794 167.153 120.542 165.929 120.038C164.705 119.51 163.661 118.79 162.797 117.878C161.957 116.966 161.309 115.922 160.853 114.746C160.397 113.57 160.169 112.334 160.169 111.038C160.169 109.718 160.397 108.47 160.853 107.294C161.309 106.118 161.957 105.074 162.797 104.162C163.661 103.25 164.705 102.542 165.929 102.038C167.153 101.51 168.533 101.246 170.069 101.246C171.605 101.246 172.973 101.51 174.173 102.038C175.397 102.542 176.441 103.25 177.305 104.162C178.169 105.074 178.817 106.118 179.249 107.294C179.705 108.47 179.933 109.718 179.933 111.038C179.933 112.334 179.705 113.57 179.249 114.746C178.817 115.922 178.169 116.966 177.305 117.878C176.465 118.79 175.433 119.51 174.209 120.038C172.985 120.542 171.605 120.794 170.069 120.794ZM165.137 111.038C165.137 112.142 165.353 113.126 165.785 113.99C166.217 114.83 166.805 115.49 167.549 115.97C168.293 116.45 169.133 116.69 170.069 116.69C170.981 116.69 171.809 116.45 172.553 115.97C173.297 115.466 173.885 114.794 174.317 113.954C174.773 113.09 175.001 112.106 175.001 111.002C175.001 109.922 174.773 108.95 174.317 108.086C173.885 107.222 173.297 106.55 172.553 106.07C171.809 105.59 170.981 105.35 170.069 105.35C169.133 105.35 168.293 105.602 167.549 106.106C166.805 106.586 166.217 107.258 165.785 108.122C165.353 108.962 165.137 109.934 165.137 111.038Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M183.189 120.434V101.57H188.229L194.133 112.478L200.073 101.57H205.041V120.434H200.469V108.23L195.645 117.086H192.621L187.761 108.23V120.434H183.189Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M219.958 128.57C219.454 128.57 218.938 128.51 218.41 128.39C217.906 128.27 217.318 128.09 216.646 127.85L217.582 124.034C217.942 124.202 218.278 124.322 218.59 124.394C218.926 124.466 219.226 124.502 219.49 124.502C220.09 124.502 220.618 124.286 221.074 123.854C221.554 123.422 221.938 122.762 222.226 121.874L222.802 120.326L215.17 101.57H220.174L225.25 115.502L229.714 101.57H234.322L226.618 123.134C226.21 124.286 225.67 125.258 224.998 126.05C224.326 126.866 223.558 127.49 222.694 127.922C221.83 128.354 220.918 128.57 219.958 128.57Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M248.247 120.794C246.783 120.794 245.487 120.47 244.359 119.822C243.255 119.15 242.391 118.25 241.767 117.122V128.102H236.943V101.57H241.155V104.81C241.875 103.706 242.787 102.842 243.891 102.218C244.995 101.57 246.255 101.246 247.671 101.246C248.943 101.246 250.107 101.498 251.163 102.002C252.243 102.506 253.179 103.214 253.971 104.126C254.763 105.014 255.375 106.046 255.807 107.222C256.263 108.374 256.491 109.622 256.491 110.966C256.491 112.79 256.131 114.446 255.411 115.934C254.715 117.422 253.743 118.61 252.495 119.498C251.271 120.362 249.855 120.794 248.247 120.794ZM246.627 116.69C247.371 116.69 248.043 116.534 248.643 116.222C249.243 115.91 249.759 115.49 250.191 114.962C250.647 114.41 250.983 113.798 251.199 113.126C251.439 112.43 251.559 111.71 251.559 110.966C251.559 110.174 251.427 109.442 251.163 108.77C250.923 108.098 250.563 107.51 250.083 107.006C249.603 106.478 249.039 106.07 248.391 105.782C247.767 105.494 247.083 105.35 246.339 105.35C245.883 105.35 245.415 105.434 244.935 105.602C244.479 105.746 244.035 105.962 243.603 106.25C243.171 106.538 242.787 106.874 242.451 107.258C242.139 107.642 241.911 108.062 241.767 108.518V112.946C242.055 113.642 242.439 114.278 242.919 114.854C243.423 115.43 243.999 115.886 244.647 116.222C245.295 116.534 245.955 116.69 246.627 116.69Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M268.472 120.794C266.936 120.794 265.556 120.542 264.332 120.038C263.108 119.51 262.064 118.79 261.2 117.878C260.36 116.966 259.712 115.922 259.256 114.746C258.8 113.57 258.572 112.334 258.572 111.038C258.572 109.718 258.8 108.47 259.256 107.294C259.712 106.118 260.36 105.074 261.2 104.162C262.064 103.25 263.108 102.542 264.332 102.038C265.556 101.51 266.936 101.246 268.472 101.246C270.008 101.246 271.376 101.51 272.576 102.038C273.8 102.542 274.844 103.25 275.708 104.162C276.572 105.074 277.22 106.118 277.652 107.294C278.108 108.47 278.336 109.718 278.336 111.038C278.336 112.334 278.108 113.57 277.652 114.746C277.22 115.922 276.572 116.966 275.708 117.878C274.868 118.79 273.836 119.51 272.612 120.038C271.388 120.542 270.008 120.794 268.472 120.794ZM263.54 111.038C263.54 112.142 263.756 113.126 264.188 113.99C264.62 114.83 265.208 115.49 265.952 115.97C266.696 116.45 267.536 116.69 268.472 116.69C269.384 116.69 270.212 116.45 270.956 115.97C271.7 115.466 272.288 114.794 272.72 113.954C273.176 113.09 273.404 112.106 273.404 111.002C273.404 109.922 273.176 108.95 272.72 108.086C272.288 107.222 271.7 106.55 270.956 106.07C270.212 105.59 269.384 105.35 268.472 105.35C267.536 105.35 266.696 105.602 265.952 106.106C265.208 106.586 264.62 107.258 264.188 108.122C263.756 108.962 263.54 109.934 263.54 111.038Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M281.592 120.434V101.57H292.104C293.4 101.57 294.444 101.786 295.236 102.218C296.052 102.65 296.652 103.214 297.036 103.91C297.42 104.606 297.612 105.35 297.612 106.142C297.612 107.198 297.372 108.122 296.892 108.914C296.436 109.706 295.716 110.318 294.732 110.75C295.836 111.062 296.736 111.602 297.432 112.37C298.128 113.114 298.476 114.098 298.476 115.322C298.476 116.498 298.2 117.47 297.648 118.238C297.096 118.982 296.304 119.534 295.272 119.894C294.24 120.254 293.016 120.434 291.6 120.434H281.592ZM286.164 117.158H291.456C291.888 117.158 292.284 117.05 292.644 116.834C293.004 116.618 293.28 116.33 293.472 115.97C293.688 115.61 293.796 115.214 293.796 114.782C293.796 114.326 293.7 113.93 293.508 113.594C293.316 113.234 293.04 112.958 292.68 112.766C292.344 112.55 291.948 112.442 291.492 112.442H286.164V117.158ZM286.164 109.418H290.88C291.312 109.418 291.696 109.31 292.032 109.094C292.368 108.878 292.62 108.59 292.788 108.23C292.98 107.87 293.076 107.474 293.076 107.042C293.076 106.418 292.872 105.902 292.464 105.494C292.08 105.062 291.564 104.846 290.916 104.846H286.164V109.418Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M301.982 120.434V101.57H306.806V108.77H314.438V101.57H319.262V120.434H314.438V112.802H306.806V120.434H301.982Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M332.422 120.794C330.91 120.794 329.542 120.542 328.318 120.038C327.094 119.51 326.05 118.802 325.186 117.914C324.322 117.002 323.65 115.97 323.17 114.818C322.714 113.642 322.486 112.406 322.486 111.11C322.486 109.31 322.882 107.666 323.674 106.178C324.49 104.69 325.642 103.502 327.13 102.614C328.642 101.702 330.418 101.246 332.458 101.246C334.522 101.246 336.286 101.702 337.75 102.614C339.214 103.502 340.33 104.69 341.098 106.178C341.89 107.642 342.286 109.226 342.286 110.93C342.286 111.218 342.274 111.518 342.25 111.83C342.226 112.118 342.202 112.358 342.178 112.55H327.598C327.694 113.51 327.97 114.35 328.426 115.07C328.906 115.79 329.506 116.342 330.226 116.726C330.97 117.086 331.762 117.266 332.602 117.266C333.562 117.266 334.462 117.038 335.302 116.582C336.166 116.102 336.754 115.478 337.066 114.71L341.206 115.862C340.75 116.822 340.09 117.674 339.226 118.418C338.386 119.162 337.39 119.75 336.238 120.182C335.086 120.59 333.814 120.794 332.422 120.794ZM327.49 109.49H337.354C337.258 108.53 336.982 107.702 336.526 107.006C336.094 106.286 335.518 105.734 334.798 105.35C334.078 104.942 333.274 104.738 332.386 104.738C331.522 104.738 330.73 104.942 330.01 105.35C329.314 105.734 328.738 106.286 328.282 107.006C327.85 107.702 327.586 108.53 327.49 109.49Z\" fill=\"#3D3D3D\"></path>\n          </svg>\n        </div>\n        <div class=\"tmpl_hh_header__description tmpl_hh_header__description--2\">\n          <svg width=\"311\" height=\"183\" viewBox=\"0 0 311 183\" fill=\"none\">\n            <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M117.188 14.8888C117.188 17.154 118.828 18.7028 121.508 18.7028H122.571C123.957 18.7028 125.159 18.1481 125.782 16.9459C126.06 17.7319 126.729 18.3794 128.001 18.3794H129.113C129.213 18.3794 129.294 18.2978 129.294 18.198V16.3652C129.294 16.2654 129.213 16.1838 129.113 16.1838H128.739C128.046 16.1838 127.769 15.814 127.769 14.6814V11.0981C127.769 8.04692 126.175 6.24364 122.825 6.24364H122.571C119.988 6.24364 118.125 7.40224 117.62 9.90996C117.609 9.96479 117.622 10.0168 117.658 10.0611C117.693 10.1047 117.742 10.1279 117.798 10.1279H120.024C120.108 10.1279 120.178 10.0738 120.199 9.99292C120.434 9.11483 121.247 8.48631 122.478 8.48631H123.033C124.419 8.48631 125.297 9.31871 125.297 10.5202V11.1213H121.509C118.829 11.1213 117.188 12.623 117.188 14.8888ZM133.839 3.1988H131.661C131.561 3.1988 131.48 3.28035 131.48 3.38018V13.7331C131.48 16.877 133.397 18.3794 136.424 18.3794H137.721C137.821 18.3794 137.902 18.2978 137.902 18.198V16.226C137.902 16.1262 137.821 16.0446 137.721 16.0446H136.817C135.292 16.0446 134.021 15.4899 134.021 13.5482V8.83221H137.863C137.963 8.83221 138.044 8.75066 138.044 8.65082V6.72522C138.044 6.62539 137.963 6.54383 137.863 6.54383H134.021V3.38018C134.021 3.28035 133.939 3.1988 133.839 3.1988ZM33.9094 18.7028C30.4442 18.7028 27.8563 16.1135 27.8563 12.6462V7.67642C27.8563 4.20906 30.4442 1.61979 33.9094 1.61979H35.4575C39.1512 1.61979 41.422 4.311 41.5078 7.49012C41.5092 7.54073 41.4916 7.58503 41.4565 7.62158C41.4213 7.65814 41.377 7.67642 41.3264 7.67642H39.0528C38.9558 7.67642 38.8763 7.60049 38.8714 7.50347C38.7765 5.47733 37.4091 4.20906 35.3415 4.20906H34.0704C31.8987 4.20906 30.5355 5.57294 30.5355 7.76922V12.5084C30.5355 14.7046 31.8987 16.0917 34.0704 16.0917H35.3415C37.4534 16.0917 38.8004 14.8017 38.8728 12.753C38.8763 12.6553 38.9565 12.578 39.0542 12.578H41.3489C41.3995 12.578 41.4438 12.5962 41.479 12.6328C41.5141 12.6694 41.5317 12.7137 41.5303 12.7643C41.4459 16.0966 39.0858 18.7042 35.4568 18.7042H33.9087L33.9094 18.7028ZM89.3021 3.1988H87.1241C87.0243 3.1988 86.9427 3.28035 86.9427 3.38018V13.7331C86.9427 16.877 88.8599 18.3794 91.8864 18.3794H93.1835C93.2834 18.3794 93.3649 18.2978 93.3649 18.198V16.226C93.3649 16.1262 93.2834 16.0446 93.1835 16.0446H92.2794C90.7546 16.0446 89.4842 15.4899 89.4842 13.5482V8.83221H93.3256C93.4254 8.83221 93.5069 8.75066 93.5069 8.65082V6.72522C93.5069 6.62539 93.4254 6.54383 93.3256 6.54383H89.4842V3.38018C89.4842 3.28035 89.4019 3.1988 89.3021 3.1988ZM81.1413 18.198V6.37721C81.1413 6.27738 81.2228 6.19583 81.3227 6.19583H83.5014C83.6012 6.19583 83.6828 6.27738 83.6828 6.37721V18.198C83.6828 18.2978 83.6012 18.3794 83.5014 18.3794H81.3227C81.2228 18.3794 81.1413 18.2978 81.1413 18.198ZM81.1181 4.53667V2.12597C81.1181 2.02614 81.1996 1.94459 81.2995 1.94459H83.5007C83.6005 1.94459 83.682 2.02614 83.682 2.12597V4.53667C83.682 4.6365 83.6005 4.71806 83.5007 4.71806H81.2995C81.1996 4.71806 81.1181 4.6365 81.1181 4.53667ZM51.3713 8.76683V6.72592C51.3713 6.62609 51.2898 6.54454 51.19 6.54454H49.5927C46.3812 6.54454 44.4408 8.30142 44.4408 11.5143V18.198C44.4408 18.2978 44.5224 18.3794 44.6222 18.3794H46.8009C46.9008 18.3794 46.9823 18.2978 46.9823 18.198V11.7681C46.9823 10.1272 48.091 8.94821 49.6391 8.94821H51.1907C51.2905 8.94821 51.3713 8.86666 51.3713 8.76683ZM4.53878 0.000703033C2.03247 0.000703033 0 2.03387 0 4.54159V9.8734C0 9.99432 0.0977216 10.092 0.218643 10.092H9.9662C10.0323 10.092 10.085 10.1455 10.085 10.2116V19.9647C10.085 20.0857 10.1827 20.1834 10.3037 20.1834H11.8834C12.0043 20.1834 12.102 20.0857 12.102 19.9647V8.31196C12.102 8.1805 11.9952 8.07363 11.8637 8.07363H2.97594C2.90985 8.07363 2.85713 8.0202 2.85713 7.95412V6.17474C2.85713 6.10866 2.91056 6.05523 2.97594 6.05523H13.9995C14.0656 6.05523 14.1183 6.10866 14.1183 6.17474V19.9647C14.1183 20.0857 14.216 20.1834 14.337 20.1834H15.6312C15.7353 20.1834 15.8379 20.1799 15.9399 20.1728C16.051 20.1651 16.1346 20.0709 16.1346 19.9598V4.27585C16.1346 4.14438 16.0278 4.03752 15.8963 4.03752H5.83166C5.76558 4.03752 5.71285 3.98409 5.71285 3.918V2.13863C5.71285 2.07254 5.76628 2.01911 5.83166 2.01911H17.8149C18.0005 2.01911 18.1509 2.16956 18.1509 2.35516V19.0093C18.1509 19.1844 18.3442 19.2863 18.4806 19.1759C19.5099 18.3435 20.1686 17.0696 20.1686 15.6418V1.00885C20.1686 0.451347 19.7173 0 19.1598 0H4.53597L4.53878 0.000703033ZM8.06871 19.9451C8.06871 20.0765 7.96185 20.1834 7.83038 20.1834H1.00885C0.45205 20.1834 0 19.7313 0 19.1745V12.3488C0 12.2173 0.106861 12.1105 0.238328 12.1105H7.83038C7.96185 12.1105 8.06871 12.2173 8.06871 12.3488V19.9451ZM58.415 18.7028C55.0426 18.7028 53.2168 16.8306 53.2168 13.525V11.3983C53.2168 8.11582 55.0419 6.24364 58.415 6.24364H58.9001C62.2501 6.24364 64.0751 8.11582 64.0751 11.3983V13.2848C64.0751 13.4174 63.9676 13.525 63.835 13.525H55.7351V13.6635C55.7351 15.4203 56.6821 16.4144 58.3918 16.4144H58.9001C60.1206 16.4144 60.9354 15.9026 61.3052 15.0231C61.334 14.9542 61.398 14.912 61.4725 14.912H63.7363C63.7932 14.912 63.8424 14.9359 63.8783 14.9802C63.9142 15.0252 63.9261 15.078 63.9134 15.1342C63.3897 17.4226 61.6764 18.7035 58.9008 18.7035L58.415 18.7028ZM55.7351 11.4904H61.5801V11.2591C61.5801 9.479 60.6331 8.50811 58.9233 8.50811H58.3918C56.6828 8.50811 55.7351 9.479 55.7351 11.2591V11.4904ZM66.8036 13.525C66.8036 16.8306 68.6287 18.7028 72.0019 18.7028H72.6022C75.9986 18.7028 77.8005 16.8306 77.8005 13.525V2.12527C77.8005 2.02544 77.7189 1.94389 77.6191 1.94389H75.4411C75.3413 1.94389 75.2597 2.02544 75.2597 2.12527V6.28934L75.3293 7.46832C74.6825 6.70553 73.7348 6.24294 72.3724 6.24294H71.5864C68.6294 6.24294 66.8043 8.11511 66.8043 11.3976L66.8036 13.525ZM75.259 13.5482C75.259 15.305 74.3352 16.2991 72.579 16.2991H72.0243C70.3146 16.2991 69.3676 15.305 69.3676 13.5482V11.3983C69.3676 9.6182 70.3146 8.62411 72.0243 8.62411H72.579C74.3352 8.62411 75.259 9.6182 75.259 11.3983V13.5482ZM101 18.198V2.12527C101 2.02544 101.081 1.94389 101.181 1.94389H108.323C111.858 1.94389 114.422 4.46356 114.422 7.93092V12.3924C114.422 15.8597 111.812 18.3794 108.323 18.3794H101.181C101.081 18.3794 101 18.2978 101 18.198ZM108.185 15.7908C110.357 15.7908 111.743 14.4733 111.743 12.2771V8.02372C111.743 5.82744 110.357 4.50996 108.185 4.50996H103.815C103.715 4.50996 103.633 4.59151 103.633 4.69134V15.6094C103.633 15.7093 103.715 15.7908 103.815 15.7908H108.185ZM144.214 18.7035C141.534 18.7035 139.894 17.1547 139.894 14.8895C139.894 12.6244 141.534 11.1213 144.214 11.1213H148.003V10.5202C148.003 9.318 147.124 8.48631 145.738 8.48631H145.183C143.952 8.48631 143.139 9.11483 142.904 9.99292C142.882 10.0738 142.812 10.1279 142.729 10.1279H140.504C140.448 10.1279 140.399 10.1047 140.363 10.0611C140.328 10.0175 140.315 9.9655 140.326 9.90996C140.831 7.40224 142.693 6.24364 145.277 6.24364H145.531C148.881 6.24364 150.475 8.04692 150.475 11.0981V14.6814C150.475 15.814 150.752 16.1838 151.445 16.1838H151.819C151.918 16.1838 152 16.2654 152 16.3652V18.198C152 18.2978 151.918 18.3794 151.819 18.3794H150.706C149.435 18.3794 148.765 17.7319 148.488 16.9459C147.865 18.1481 146.663 18.7028 145.277 18.7028L144.214 18.7035ZM145.323 16.5536C146.824 16.5536 148.003 15.7908 148.003 14.1035V13.0863H144.676C143.289 13.0863 142.504 13.8027 142.504 14.8199C142.504 15.8604 143.289 16.5536 144.676 16.5536H145.323ZM125.296 14.1035C125.296 15.7908 124.118 16.5536 122.616 16.5536H121.969C120.584 16.5536 119.798 15.8604 119.798 14.8199C119.798 13.8027 120.584 13.0863 121.969 13.0863H125.296V14.1035Z\" fill=\"#6B3FA0\"></path>\n            <path d=\"M10.144 137.023V134.975C8.77867 134.89 7.488 134.602 6.272 134.111C5.056 133.621 3.97867 132.938 3.04 132.063C2.10133 131.189 1.35467 130.154 0.8 128.959C0.266667 127.743 0 126.41 0 124.959C0 123.423 0.277333 122.058 0.832 120.863C1.408 119.647 2.176 118.613 3.136 117.759C4.096 116.885 5.17333 116.213 6.368 115.743C7.584 115.274 8.84267 114.997 10.144 114.911V113.183H14.336V114.911C15.6373 114.997 16.896 115.285 18.112 115.775C19.328 116.245 20.4053 116.917 21.344 117.791C22.304 118.645 23.0613 119.679 23.616 120.895C24.1707 122.09 24.448 123.445 24.448 124.959C24.448 126.453 24.1707 127.797 23.616 128.991C23.0827 130.186 22.336 131.221 21.376 132.095C20.4373 132.97 19.36 133.653 18.144 134.143C16.928 134.613 15.6587 134.89 14.336 134.975V137.023H10.144ZM10.272 131.423V118.463C9.20533 118.527 8.224 118.826 7.328 119.359C6.432 119.893 5.71733 120.629 5.184 121.567C4.672 122.485 4.416 123.615 4.416 124.959C4.416 125.962 4.576 126.858 4.896 127.647C5.216 128.415 5.64267 129.077 6.176 129.631C6.73067 130.165 7.36 130.591 8.064 130.911C8.768 131.21 9.504 131.381 10.272 131.423ZM14.208 131.423C15.2533 131.338 16.224 131.039 17.12 130.527C18.016 129.994 18.7307 129.269 19.264 128.351C19.7973 127.413 20.064 126.282 20.064 124.959C20.064 123.957 19.904 123.071 19.584 122.303C19.2853 121.535 18.8587 120.874 18.304 120.319C17.7707 119.765 17.152 119.327 16.448 119.007C15.744 118.687 14.9973 118.506 14.208 118.463V131.423Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M27.2725 137.023V120.287H31.5605V131.295L39.0805 120.255H42.9845V137.023H38.6965V126.271L31.2725 137.023H27.2725Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M46.8975 137.023V120.255H51.1855V126.655H57.9695V120.255H62.2575V137.023H57.9695V130.239H51.1855V137.023H46.8975Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M70.0508 137.023V123.999H64.7387V120.255H79.6827V123.999H74.3388V137.023H70.0508Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M89.861 137.343C88.517 137.343 87.301 137.119 86.213 136.671C85.125 136.202 84.197 135.573 83.429 134.783C82.661 133.973 82.0637 133.055 81.637 132.031C81.2317 130.986 81.029 129.887 81.029 128.735C81.029 127.135 81.381 125.674 82.085 124.351C82.8103 123.029 83.8343 121.973 85.157 121.183C86.501 120.373 88.0797 119.967 89.893 119.967C91.7277 119.967 93.2957 120.373 94.597 121.183C95.8983 121.973 96.8903 123.029 97.573 124.351C98.277 125.653 98.629 127.061 98.629 128.575C98.629 128.831 98.6183 129.098 98.597 129.375C98.5757 129.631 98.5543 129.845 98.533 130.015H85.573C85.6583 130.869 85.9037 131.615 86.309 132.255C86.7357 132.895 87.269 133.386 87.909 133.727C88.5703 134.047 89.2743 134.207 90.021 134.207C90.8743 134.207 91.6743 134.005 92.421 133.599C93.189 133.173 93.7117 132.618 93.989 131.935L97.669 132.959C97.2637 133.813 96.677 134.57 95.909 135.231C95.1623 135.893 94.277 136.415 93.253 136.799C92.229 137.162 91.0983 137.343 89.861 137.343ZM85.477 127.295H94.245C94.1597 126.442 93.9143 125.706 93.509 125.087C93.125 124.447 92.613 123.957 91.973 123.615C91.333 123.253 90.6183 123.071 89.829 123.071C89.061 123.071 88.357 123.253 87.717 123.615C87.0983 123.957 86.5863 124.447 86.181 125.087C85.797 125.706 85.5623 126.442 85.477 127.295Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M103.993 120.255L107.513 125.503L107.769 126.079L108.089 125.503L111.577 120.255H116.089L110.265 128.607L116.185 137.023H111.673L108.057 131.807L107.769 131.263L107.513 131.807L103.929 137.023H99.4173L105.337 128.703L99.5133 120.255H103.993Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M117.645 130.175V126.303H127.341V130.175H117.645Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M137.932 137.311C136.802 137.311 135.735 137.151 134.732 136.831C133.751 136.511 132.876 136.042 132.108 135.423C131.362 134.783 130.754 134.037 130.284 133.183L133.708 131.583C134.135 132.351 134.69 132.938 135.372 133.343C136.055 133.727 136.823 133.919 137.676 133.919C138.466 133.919 139.18 133.749 139.82 133.407C140.46 133.045 140.994 132.565 141.42 131.967C141.868 131.37 142.156 130.698 142.284 129.951H136.396V127.167H142.252C142.103 126.485 141.826 125.855 141.42 125.279C141.015 124.703 140.492 124.245 139.852 123.903C139.234 123.562 138.508 123.391 137.676 123.391C136.844 123.391 136.098 123.562 135.436 123.903C134.775 124.245 134.22 124.799 133.772 125.567L130.54 123.871C131.202 122.677 132.162 121.727 133.42 121.023C134.679 120.319 136.172 119.967 137.9 119.967C139.33 119.967 140.588 120.202 141.676 120.671C142.764 121.141 143.682 121.791 144.428 122.623C145.175 123.434 145.74 124.362 146.124 125.407C146.508 126.431 146.7 127.498 146.7 128.607C146.7 129.738 146.508 130.826 146.124 131.871C145.74 132.895 145.164 133.823 144.396 134.655C143.65 135.466 142.732 136.117 141.644 136.607C140.556 137.077 139.319 137.311 137.932 137.311Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M149.554 137.023V120.255H153.842V126.591H155.282L159.826 120.255H164.498L158.546 128.351L165.138 137.023H160.242L155.218 130.367H153.842V137.023H149.554Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M174.737 137.343C173.371 137.343 172.145 137.119 171.057 136.671C169.969 136.202 169.041 135.562 168.273 134.751C167.505 133.919 166.907 132.981 166.481 131.935C166.075 130.89 165.873 129.791 165.873 128.639C165.873 127.061 166.225 125.621 166.929 124.319C167.654 122.997 168.678 121.941 170.001 121.151C171.323 120.362 172.891 119.967 174.705 119.967C176.518 119.967 178.075 120.362 179.377 121.151C180.678 121.941 181.649 122.975 182.289 124.255L178.097 125.535C177.734 124.917 177.254 124.447 176.657 124.127C176.059 123.786 175.398 123.615 174.673 123.615C173.862 123.615 173.115 123.829 172.433 124.255C171.771 124.661 171.249 125.247 170.865 126.015C170.481 126.762 170.289 127.637 170.289 128.639C170.289 129.621 170.481 130.495 170.865 131.263C171.27 132.01 171.803 132.607 172.465 133.055C173.126 133.482 173.862 133.695 174.673 133.695C175.185 133.695 175.665 133.61 176.113 133.439C176.582 133.269 176.998 133.034 177.361 132.735C177.723 132.437 177.99 132.095 178.161 131.711L182.353 132.991C181.969 133.823 181.403 134.57 180.657 135.231C179.931 135.893 179.067 136.415 178.065 136.799C177.083 137.162 175.974 137.343 174.737 137.343Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M184.991 137.023V120.255H200.031V137.023H195.743V123.999H189.279V137.023H184.991Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M211.705 137.343C210.361 137.343 209.145 137.119 208.057 136.671C206.969 136.202 206.041 135.573 205.273 134.783C204.505 133.973 203.907 133.055 203.481 132.031C203.075 130.986 202.873 129.887 202.873 128.735C202.873 127.135 203.225 125.674 203.929 124.351C204.654 123.029 205.678 121.973 207.001 121.183C208.345 120.373 209.923 119.967 211.737 119.967C213.571 119.967 215.139 120.373 216.441 121.183C217.742 121.973 218.734 123.029 219.417 124.351C220.121 125.653 220.473 127.061 220.473 128.575C220.473 128.831 220.462 129.098 220.441 129.375C220.419 129.631 220.398 129.845 220.377 130.015H207.417C207.502 130.869 207.747 131.615 208.153 132.255C208.579 132.895 209.113 133.386 209.753 133.727C210.414 134.047 211.118 134.207 211.865 134.207C212.718 134.207 213.518 134.005 214.265 133.599C215.033 133.173 215.555 132.618 215.833 131.935L219.513 132.959C219.107 133.813 218.521 134.57 217.753 135.231C217.006 135.893 216.121 136.415 215.097 136.799C214.073 137.162 212.942 137.343 211.705 137.343ZM207.321 127.295H216.089C216.003 126.442 215.758 125.706 215.353 125.087C214.969 124.447 214.457 123.957 213.817 123.615C213.177 123.253 212.462 123.071 211.673 123.071C210.905 123.071 210.201 123.253 209.561 123.615C208.942 123.957 208.43 124.447 208.025 125.087C207.641 125.706 207.406 126.442 207.321 127.295Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M233.133 137.343C231.832 137.343 230.68 137.055 229.677 136.479C228.696 135.882 227.928 135.082 227.373 134.079V143.839H223.085V120.255H226.829V123.135C227.469 122.154 228.28 121.386 229.261 120.831C230.242 120.255 231.362 119.967 232.621 119.967C233.752 119.967 234.786 120.191 235.725 120.639C236.685 121.087 237.517 121.717 238.221 122.527C238.925 123.317 239.469 124.234 239.853 125.279C240.258 126.303 240.461 127.413 240.461 128.607C240.461 130.229 240.141 131.701 239.501 133.023C238.882 134.346 238.018 135.402 236.909 136.191C235.821 136.959 234.562 137.343 233.133 137.343ZM231.693 133.695C232.354 133.695 232.952 133.557 233.485 133.279C234.018 133.002 234.477 132.629 234.861 132.159C235.266 131.669 235.565 131.125 235.757 130.527C235.97 129.909 236.077 129.269 236.077 128.607C236.077 127.903 235.96 127.253 235.725 126.655C235.512 126.058 235.192 125.535 234.765 125.087C234.338 124.618 233.837 124.255 233.261 123.999C232.706 123.743 232.098 123.615 231.437 123.615C231.032 123.615 230.616 123.69 230.189 123.839C229.784 123.967 229.389 124.159 229.005 124.415C228.621 124.671 228.28 124.97 227.981 125.311C227.704 125.653 227.501 126.026 227.373 126.431V130.367C227.629 130.986 227.97 131.551 228.397 132.063C228.845 132.575 229.357 132.981 229.933 133.279C230.509 133.557 231.096 133.695 231.693 133.695Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M247.238 137.023V123.999H241.926V120.255H256.87V123.999H251.526V137.023H247.238Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M259.272 137.023V120.287H263.56V131.295L271.081 120.255H274.984V137.023H270.697V126.271L263.272 137.023H259.272Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M284.882 137.279C283.09 137.279 281.596 136.959 280.401 136.319C279.207 135.679 278.268 134.794 277.586 133.663L281.042 132.095C281.404 132.65 281.874 133.087 282.449 133.407C283.047 133.706 283.783 133.855 284.658 133.855C285.66 133.855 286.428 133.663 286.961 133.279C287.516 132.874 287.793 132.351 287.793 131.711C287.793 131.114 287.569 130.634 287.121 130.271C286.673 129.909 286.012 129.727 285.138 129.727H283.41V127.071H285.169C285.575 127.071 285.916 126.997 286.194 126.847C286.492 126.677 286.716 126.453 286.866 126.175C287.036 125.898 287.121 125.578 287.121 125.215C287.121 124.682 286.908 124.245 286.482 123.903C286.076 123.562 285.426 123.391 284.53 123.391C283.783 123.391 283.164 123.53 282.673 123.807C282.204 124.085 281.81 124.501 281.49 125.055L278.258 123.327C278.855 122.282 279.708 121.461 280.818 120.863C281.948 120.266 283.26 119.967 284.754 119.967C285.927 119.967 286.972 120.149 287.889 120.511C288.828 120.874 289.564 121.397 290.098 122.079C290.631 122.762 290.897 123.615 290.897 124.639C290.897 125.365 290.716 126.069 290.354 126.751C290.012 127.434 289.447 127.935 288.658 128.255C289.681 128.554 290.449 129.066 290.961 129.791C291.495 130.517 291.762 131.37 291.762 132.351C291.762 133.418 291.463 134.325 290.866 135.071C290.268 135.797 289.457 136.351 288.434 136.735C287.41 137.098 286.225 137.279 284.882 137.279Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M293.621 132.063C293.621 130.975 293.919 130.026 294.517 129.215C295.135 128.383 295.988 127.743 297.077 127.295C298.165 126.847 299.413 126.623 300.82 126.623C301.525 126.623 302.239 126.677 302.965 126.783C303.69 126.89 304.319 127.061 304.853 127.295V126.399C304.853 125.333 304.533 124.511 303.892 123.935C303.274 123.359 302.346 123.071 301.108 123.071C300.191 123.071 299.316 123.231 298.484 123.551C297.652 123.871 296.778 124.341 295.861 124.959L294.484 122.143C295.594 121.418 296.724 120.874 297.876 120.511C299.05 120.149 300.276 119.967 301.556 119.967C303.946 119.967 305.802 120.565 307.125 121.759C308.469 122.954 309.141 124.661 309.141 126.879V132.223C309.141 132.671 309.215 132.991 309.365 133.183C309.535 133.375 309.802 133.493 310.164 133.535V137.023C309.78 137.087 309.428 137.141 309.108 137.183C308.81 137.226 308.554 137.247 308.341 137.247C307.487 137.247 306.836 137.055 306.388 136.671C305.962 136.287 305.695 135.818 305.589 135.263L305.492 134.399C304.767 135.338 303.861 136.063 302.772 136.575C301.684 137.087 300.575 137.343 299.444 137.343C298.335 137.343 297.332 137.119 296.436 136.671C295.562 136.202 294.868 135.573 294.357 134.783C293.866 133.973 293.621 133.066 293.621 132.063ZM304.052 132.927C304.287 132.671 304.479 132.415 304.629 132.159C304.778 131.903 304.853 131.669 304.853 131.455V129.759C304.341 129.546 303.786 129.386 303.189 129.279C302.591 129.151 302.026 129.087 301.492 129.087C300.383 129.087 299.466 129.333 298.741 129.823C298.036 130.293 297.685 130.922 297.685 131.711C297.685 132.138 297.802 132.543 298.036 132.927C298.271 133.311 298.612 133.621 299.06 133.855C299.508 134.09 300.042 134.207 300.66 134.207C301.301 134.207 301.93 134.09 302.548 133.855C303.167 133.599 303.668 133.29 304.052 132.927Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M0.96 175.023V158.255H5.248V164.655H12.032V158.255H16.32V175.023H12.032V168.239H5.248V175.023H0.96Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M19.0893 170.063C19.0893 168.975 19.3879 168.026 19.9853 167.215C20.6039 166.383 21.4573 165.743 22.5452 165.295C23.6333 164.847 24.8813 164.623 26.2892 164.623C26.9932 164.623 27.7079 164.677 28.4333 164.783C29.1586 164.89 29.7879 165.061 30.3213 165.295V164.399C30.3213 163.333 30.0012 162.511 29.3612 161.935C28.7426 161.359 27.8146 161.071 26.5772 161.071C25.6599 161.071 24.7853 161.231 23.9533 161.551C23.1213 161.871 22.2466 162.341 21.3293 162.959L19.9533 160.143C21.0626 159.418 22.1933 158.874 23.3453 158.511C24.5186 158.149 25.7453 157.967 27.0252 157.967C29.4146 157.967 31.2706 158.565 32.5933 159.759C33.9373 160.954 34.6093 162.661 34.6093 164.879V170.223C34.6093 170.671 34.6839 170.991 34.8333 171.183C35.0039 171.375 35.2706 171.493 35.6333 171.535V175.023C35.2493 175.087 34.8973 175.141 34.5773 175.183C34.2786 175.226 34.0226 175.247 33.8092 175.247C32.9559 175.247 32.3053 175.055 31.8573 174.671C31.4306 174.287 31.1639 173.818 31.0573 173.263L30.9613 172.399C30.2359 173.338 29.3293 174.063 28.2413 174.575C27.1533 175.087 26.0439 175.343 24.9132 175.343C23.8039 175.343 22.8013 175.119 21.9053 174.671C21.0306 174.202 20.3372 173.573 19.8253 172.783C19.3346 171.973 19.0893 171.066 19.0893 170.063ZM29.5212 170.927C29.7559 170.671 29.9479 170.415 30.0972 170.159C30.2466 169.903 30.3213 169.669 30.3213 169.455V167.759C29.8093 167.546 29.2546 167.386 28.6572 167.279C28.0599 167.151 27.4946 167.087 26.9613 167.087C25.8519 167.087 24.9346 167.333 24.2092 167.823C23.5052 168.293 23.1532 168.922 23.1532 169.711C23.1532 170.138 23.2706 170.543 23.5053 170.927C23.7399 171.311 24.0813 171.621 24.5293 171.855C24.9773 172.09 25.5106 172.207 26.1292 172.207C26.7692 172.207 27.3986 172.09 28.0173 171.855C28.6359 171.599 29.1372 171.29 29.5212 170.927Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M46.3037 175.023V158.255H55.6478C56.7998 158.255 57.7278 158.447 58.4318 158.831C59.1571 159.215 59.6904 159.717 60.0317 160.335C60.3731 160.954 60.5438 161.615 60.5438 162.319C60.5438 163.258 60.3304 164.079 59.9038 164.783C59.4984 165.487 58.8584 166.031 57.9837 166.415C58.9651 166.693 59.7651 167.173 60.3838 167.855C61.0024 168.517 61.3118 169.391 61.3118 170.479C61.3118 171.525 61.0664 172.389 60.5758 173.071C60.0851 173.733 59.3811 174.223 58.4637 174.543C57.5464 174.863 56.4584 175.023 55.1997 175.023H46.3037ZM50.3678 172.111H55.0718C55.4557 172.111 55.8078 172.015 56.1278 171.823C56.4478 171.631 56.6931 171.375 56.8638 171.055C57.0557 170.735 57.1517 170.383 57.1517 169.999C57.1517 169.594 57.0664 169.242 56.8958 168.943C56.7251 168.623 56.4798 168.378 56.1598 168.207C55.8611 168.015 55.5091 167.919 55.1038 167.919H50.3678V172.111ZM50.3678 165.231H54.5597C54.9437 165.231 55.2851 165.135 55.5838 164.943C55.8824 164.751 56.1064 164.495 56.2557 164.175C56.4264 163.855 56.5117 163.503 56.5117 163.119C56.5117 162.565 56.3304 162.106 55.9678 161.743C55.6264 161.359 55.1678 161.167 54.5918 161.167H50.3678V165.231Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M64.4287 175.023V158.255H68.7168V163.535H71.6608C73.6874 163.535 75.2341 164.047 76.3008 165.071C77.3674 166.095 77.9007 167.45 77.9007 169.135C77.9007 170.266 77.6661 171.279 77.1967 172.175C76.7487 173.071 76.0874 173.775 75.2128 174.287C74.3381 174.778 73.2501 175.023 71.9488 175.023H64.4287ZM68.7168 171.759H71.2767C71.8741 171.759 72.3541 171.642 72.7168 171.407C73.0794 171.173 73.3461 170.863 73.5168 170.479C73.7088 170.095 73.8047 169.658 73.8047 169.167C73.8047 168.698 73.7194 168.282 73.5488 167.919C73.3781 167.535 73.1008 167.237 72.7168 167.023C72.3541 166.789 71.8634 166.671 71.2448 166.671H68.7168V171.759ZM80.5247 175.023V158.287H84.8128V175.023H80.5247Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M96.5492 175.343C95.1839 175.343 93.9572 175.119 92.8692 174.671C91.7812 174.202 90.8532 173.562 90.0853 172.751C89.3173 171.919 88.7199 170.981 88.2933 169.935C87.8879 168.89 87.6852 167.791 87.6852 166.639C87.6852 165.061 88.0372 163.621 88.7412 162.319C89.4666 160.997 90.4906 159.941 91.8132 159.151C93.1359 158.362 94.7039 157.967 96.5173 157.967C98.3306 157.967 99.8879 158.362 101.189 159.151C102.491 159.941 103.461 160.975 104.101 162.255L99.9092 163.535C99.5466 162.917 99.0666 162.447 98.4693 162.127C97.8719 161.786 97.2106 161.615 96.4853 161.615C95.6746 161.615 94.9279 161.829 94.2452 162.255C93.5839 162.661 93.0613 163.247 92.6773 164.015C92.2933 164.762 92.1012 165.637 92.1012 166.639C92.1012 167.621 92.2933 168.495 92.6773 169.263C93.0826 170.01 93.6159 170.607 94.2773 171.055C94.9386 171.482 95.6746 171.695 96.4853 171.695C96.9973 171.695 97.4772 171.61 97.9252 171.439C98.3946 171.269 98.8106 171.034 99.1732 170.735C99.5359 170.437 99.8026 170.095 99.9733 169.711L104.165 170.991C103.781 171.823 103.216 172.57 102.469 173.231C101.744 173.893 100.88 174.415 99.8773 174.799C98.8959 175.162 97.7866 175.343 96.5492 175.343Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M114.392 175.343C113.026 175.343 111.799 175.119 110.712 174.671C109.624 174.202 108.695 173.562 107.927 172.751C107.181 171.941 106.605 171.013 106.2 169.967C105.794 168.922 105.591 167.823 105.591 166.671C105.591 165.498 105.794 164.389 106.2 163.343C106.605 162.298 107.181 161.37 107.927 160.559C108.695 159.749 109.624 159.119 110.712 158.671C111.799 158.202 113.026 157.967 114.392 157.967C115.757 157.967 116.973 158.202 118.039 158.671C119.127 159.119 120.056 159.749 120.824 160.559C121.591 161.37 122.167 162.298 122.551 163.343C122.957 164.389 123.16 165.498 123.16 166.671C123.16 167.823 122.957 168.922 122.551 169.967C122.167 171.013 121.591 171.941 120.824 172.751C120.077 173.562 119.16 174.202 118.072 174.671C116.984 175.119 115.757 175.343 114.392 175.343ZM110.007 166.671C110.007 167.653 110.2 168.527 110.584 169.295C110.968 170.042 111.49 170.629 112.151 171.055C112.813 171.482 113.56 171.695 114.392 171.695C115.202 171.695 115.938 171.482 116.6 171.055C117.261 170.607 117.784 170.01 118.168 169.263C118.573 168.495 118.775 167.621 118.775 166.639C118.775 165.679 118.573 164.815 118.168 164.047C117.784 163.279 117.261 162.682 116.6 162.255C115.938 161.829 115.202 161.615 114.392 161.615C113.56 161.615 112.813 161.839 112.151 162.287C111.49 162.714 110.968 163.311 110.584 164.079C110.2 164.826 110.007 165.69 110.007 166.671Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M126.054 175.023V158.255H130.342V164.591H131.782L136.326 158.255H140.998L135.046 166.351L141.638 175.023H136.742L131.718 168.367H130.342V175.023H126.054Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M151.173 175.343C149.807 175.343 148.581 175.119 147.493 174.671C146.405 174.202 145.477 173.562 144.709 172.751C143.962 171.941 143.386 171.013 142.981 169.967C142.575 168.922 142.373 167.823 142.373 166.671C142.373 165.498 142.575 164.389 142.981 163.343C143.386 162.298 143.962 161.37 144.709 160.559C145.477 159.749 146.405 159.119 147.493 158.671C148.581 158.202 149.807 157.967 151.173 157.967C152.538 157.967 153.754 158.202 154.821 158.671C155.909 159.119 156.837 159.749 157.605 160.559C158.373 161.37 158.949 162.298 159.333 163.343C159.738 164.389 159.941 165.498 159.941 166.671C159.941 167.823 159.738 168.922 159.333 169.967C158.949 171.013 158.373 171.941 157.605 172.751C156.858 173.562 155.941 174.202 154.853 174.671C153.765 175.119 152.538 175.343 151.173 175.343ZM146.789 166.671C146.789 167.653 146.981 168.527 147.365 169.295C147.749 170.042 148.271 170.629 148.933 171.055C149.594 171.482 150.341 171.695 151.173 171.695C151.983 171.695 152.719 171.482 153.381 171.055C154.042 170.607 154.565 170.01 154.949 169.263C155.354 168.495 155.557 167.621 155.557 166.639C155.557 165.679 155.354 164.815 154.949 164.047C154.565 163.279 154.042 162.682 153.381 162.255C152.719 161.829 151.983 161.615 151.173 161.615C150.341 161.615 149.594 161.839 148.933 162.287C148.271 162.714 147.749 163.311 147.365 164.079C146.981 164.826 146.789 165.69 146.789 166.671Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M162.835 175.023V158.255H167.315L172.563 167.951L177.843 158.255H182.259V175.023H178.195V164.175L173.907 172.047H171.219L166.899 164.175V175.023H162.835Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M195.518 182.255C195.07 182.255 194.612 182.202 194.143 182.095C193.695 181.989 193.172 181.829 192.574 181.615L193.406 178.223C193.727 178.373 194.025 178.479 194.303 178.543C194.601 178.607 194.868 178.639 195.102 178.639C195.636 178.639 196.105 178.447 196.51 178.063C196.937 177.679 197.279 177.093 197.535 176.303L198.046 174.927L191.262 158.255H195.71L200.223 170.639L204.191 158.255H208.286L201.439 177.423C201.076 178.447 200.596 179.311 199.999 180.015C199.401 180.741 198.719 181.295 197.951 181.679C197.182 182.063 196.372 182.255 195.518 182.255Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M220.664 175.343C219.363 175.343 218.211 175.055 217.208 174.479C216.227 173.882 215.459 173.082 214.904 172.079V181.839H210.616V158.255H214.36V161.135C215 160.154 215.811 159.386 216.792 158.831C217.774 158.255 218.894 157.967 220.152 157.967C221.283 157.967 222.318 158.191 223.256 158.639C224.216 159.087 225.048 159.717 225.752 160.527C226.456 161.317 227 162.234 227.384 163.279C227.79 164.303 227.992 165.413 227.992 166.607C227.992 168.229 227.672 169.701 227.032 171.023C226.414 172.346 225.55 173.402 224.44 174.191C223.352 174.959 222.094 175.343 220.664 175.343ZM219.224 171.695C219.886 171.695 220.483 171.557 221.016 171.279C221.55 171.002 222.008 170.629 222.392 170.159C222.798 169.669 223.096 169.125 223.288 168.527C223.502 167.909 223.608 167.269 223.608 166.607C223.608 165.903 223.491 165.253 223.256 164.655C223.043 164.058 222.723 163.535 222.296 163.087C221.87 162.618 221.368 162.255 220.792 161.999C220.238 161.743 219.63 161.615 218.968 161.615C218.563 161.615 218.147 161.69 217.72 161.839C217.315 161.967 216.92 162.159 216.536 162.415C216.152 162.671 215.811 162.97 215.512 163.311C215.235 163.653 215.032 164.026 214.904 164.431V168.367C215.16 168.986 215.502 169.551 215.928 170.063C216.376 170.575 216.888 170.981 217.464 171.279C218.04 171.557 218.627 171.695 219.224 171.695Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M238.641 175.343C237.276 175.343 236.049 175.119 234.962 174.671C233.874 174.202 232.946 173.562 232.178 172.751C231.431 171.941 230.855 171.013 230.449 169.967C230.044 168.922 229.842 167.823 229.842 166.671C229.842 165.498 230.044 164.389 230.449 163.343C230.855 162.298 231.431 161.37 232.178 160.559C232.946 159.749 233.874 159.119 234.962 158.671C236.049 158.202 237.276 157.967 238.641 157.967C240.007 157.967 241.223 158.202 242.29 158.671C243.378 159.119 244.305 159.749 245.074 160.559C245.842 161.37 246.417 162.298 246.801 163.343C247.207 164.389 247.41 165.498 247.41 166.671C247.41 167.823 247.207 168.922 246.801 169.967C246.417 171.013 245.842 171.941 245.074 172.751C244.327 173.562 243.41 174.202 242.322 174.671C241.234 175.119 240.007 175.343 238.641 175.343ZM234.258 166.671C234.258 167.653 234.449 168.527 234.833 169.295C235.217 170.042 235.74 170.629 236.402 171.055C237.063 171.482 237.809 171.695 238.641 171.695C239.452 171.695 240.188 171.482 240.85 171.055C241.511 170.607 242.033 170.01 242.417 169.263C242.823 168.495 243.025 167.621 243.025 166.639C243.025 165.679 242.823 164.815 242.417 164.047C242.033 163.279 241.511 162.682 240.85 162.255C240.188 161.829 239.452 161.615 238.641 161.615C237.809 161.615 237.063 161.839 236.402 162.287C235.74 162.714 235.217 163.311 234.833 164.079C234.449 164.826 234.258 165.69 234.258 166.671Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M250.304 175.023V158.255H259.648C260.8 158.255 261.728 158.447 262.432 158.831C263.157 159.215 263.69 159.717 264.032 160.335C264.373 160.954 264.544 161.615 264.544 162.319C264.544 163.258 264.33 164.079 263.904 164.783C263.498 165.487 262.858 166.031 261.984 166.415C262.965 166.693 263.765 167.173 264.384 167.855C265.002 168.517 265.312 169.391 265.312 170.479C265.312 171.525 265.066 172.389 264.576 173.071C264.085 173.733 263.381 174.223 262.464 174.543C261.546 174.863 260.458 175.023 259.2 175.023H250.304ZM254.368 172.111H259.072C259.456 172.111 259.808 172.015 260.128 171.823C260.448 171.631 260.693 171.375 260.864 171.055C261.056 170.735 261.152 170.383 261.152 169.999C261.152 169.594 261.066 169.242 260.896 168.943C260.725 168.623 260.48 168.378 260.16 168.207C259.861 168.015 259.509 167.919 259.104 167.919H254.368V172.111ZM254.368 165.231H258.56C258.944 165.231 259.285 165.135 259.584 164.943C259.882 164.751 260.106 164.495 260.256 164.175C260.426 163.855 260.512 163.503 260.512 163.119C260.512 162.565 260.33 162.106 259.968 161.743C259.626 161.359 259.168 161.167 258.592 161.167H254.368V165.231Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M268.429 175.023V158.255H272.717V164.655H279.501V158.255H283.789V175.023H279.501V168.239H272.717V175.023H268.429Z\" fill=\"#3D3D3D\"></path>\n            <path d=\"M295.486 175.343C294.142 175.343 292.926 175.119 291.838 174.671C290.75 174.202 289.822 173.573 289.054 172.783C288.286 171.973 287.689 171.055 287.262 170.031C286.857 168.986 286.654 167.887 286.654 166.735C286.654 165.135 287.006 163.674 287.71 162.351C288.435 161.029 289.459 159.973 290.782 159.183C292.126 158.373 293.705 157.967 295.518 157.967C297.353 157.967 298.921 158.373 300.222 159.183C301.523 159.973 302.515 161.029 303.198 162.351C303.902 163.653 304.254 165.061 304.254 166.575C304.254 166.831 304.243 167.098 304.222 167.375C304.201 167.631 304.179 167.845 304.158 168.015H291.198C291.283 168.869 291.529 169.615 291.934 170.255C292.361 170.895 292.894 171.386 293.534 171.727C294.195 172.047 294.899 172.207 295.646 172.207C296.499 172.207 297.299 172.005 298.046 171.599C298.814 171.173 299.337 170.618 299.614 169.935L303.294 170.959C302.889 171.813 302.302 172.57 301.534 173.231C300.787 173.893 299.902 174.415 298.878 174.799C297.854 175.162 296.723 175.343 295.486 175.343ZM291.102 165.295H299.87C299.785 164.442 299.539 163.706 299.134 163.087C298.75 162.447 298.238 161.957 297.598 161.615C296.958 161.253 296.243 161.071 295.454 161.071C294.686 161.071 293.982 161.253 293.342 161.615C292.723 161.957 292.211 162.447 291.806 163.087C291.422 163.706 291.187 164.442 291.102 165.295Z\" fill=\"#3D3D3D\"></path>\n          </svg>\n        </div>\n      </div>\n      <div class=\"tmpl_hh_header__decoration\"></div>\n    </header>\n    <section class=\"tmpl_hh_about\">\n      <p>Credit Data — часть ГК Lime Credit Group, аккредитованная ІТ-компания, разрабатывающая технологичные решения\n        для финансового рынка.</p>\n      <p>Наша команда имеет профильный опыт исследований и аналитики в сфере кредитования, включая работу с\n        искусственным интеллектом и машинным обучением. Мы постоянно осваиваем новые технологии, внедряем их в продукты,\n        делая финансовую сферу быстрой, доступной и понятной.</p>\n    </section>\n    <main class=\"tmpl_hh_content\">\n      <p><strong>Чем предстоит заниматься:</strong></p> <ul> <li>Разрабатывать системы скоринга для различных стран;</li> <li>Исследовать поведенческие паттерны и находить<br>зависимости в данных используя статистические методы<br>анализа;</li> <li>Моделировать поведения клиентов для решения задач<br>маркетинга;</li> <li>Автоматизировать процессы компании с использованием LLM;</li> <li>Участвовать в разработке архитектуры ML сервисов;</li> <li>Оптимизировать и развивать уже существующие<br>пайплайны в рамках MLOps платформы.</li> </ul> <p><strong>Что для нас важно:</strong></p> <ul> <li>Имеешь хорошую математическую подготовку;</li> <li>Знаешь основы статистического анализа;</li> <li>Имеешь опыт использования и понимаешь основные алгоритмы машинного обучения;</li> <li>Понимаешь принципы постановки экспериментов и инструментарий для проверки гипотез;</li> <li>Имеешь опыт работы с Python, библиотеками scikit-learn, numpy, scipy, pandas, gbm фреймворками;</li> <li>Владеешь инструментами визуализации данных (seaborn, plotly, matplotlib);<br>Понимаешь микросервисную архитектуру и знаком с инструментами (Docker, K8S);</li> <li>Понимаешь методологию разработки GitFlow;</li> <li>Обладаешь навыками построения эффективной коммуникации и умеешь донести свою точку зрения.</li> </ul> <p><strong>Будет твоим преимуществом:</strong></p> <ul> <li>Имеешь профиль в GitHub или Kaggle, которым не стыдно поделиться;</li> <li>Имеешь опыт вывода моделей в прод и понимаешь их жизненный цикл;</li> <li>Применял практики MLOps в реальных проектах;</li> <li>Имеешь опыт участия в конкурсах по анализу данных;</li> <li>Знаешь pytorch, имеешь практические навыки в современных библиотеках для работы с большими языковыми моделями;</li> <li>Закончил ШАД или CSC.</li> </ul> <p><strong>Мы гарантируем:</strong></p> <ul> <li>Атмосферу безопасности. Так как мы предлагаем трудоустройство в полном соответствии с ТК РФ;</li> <li> <p>График работы 5\\2 (сб,вс - выходные);</p> </li> <li> <p>Чувство устойчивости в настоящем и будущем, даже когда времена вокруг нас меняются. Помогут тебе в этом наши оздоровительные и финансовые бенефиты;</p> </li> <li> <p>Комфорт в деталях: отсутствие дресс-кода, оборудованное рабочее место и возможность отдыха в неформальной обстановке.</p> </li> <li> <p>Динамику профессионального развития.</p> </li> </ul></main>\n    <aside class=\"tmpl_hh_aside\">\n      <div class=\"tmpl_hh_aside__slider\">\n        <div class=\"tmpl_hh_aside__slider__inner\">\n          <div class=\"swiper swiper\">\n            <div class=\"swiper-wrapper swiper__wrapper\">\n              <div class=\"swiper-slide swiper__slide\">\n                <img src=\"https://img.hhcdn.ru/ichameleon/451461.png\" alt=\"img\">\n              </div>\n              <div class=\"swiper-slide swiper__slide\">\n                <img src=\"https://img.hhcdn.ru/ichameleon/451463.png\" alt=\"img\">\n              </div>\n              <div class=\"swiper-slide swiper__slide\">\n                <img src=\"https://img.hhcdn.ru/ichameleon/451464.png\" alt=\"img\">\n              </div>\n              <div class=\"swiper-slide swiper__slide\">\n                <img src=\"https://img.hhcdn.ru/ichameleon/451462.png\" alt=\"img\">\n              </div>\n              <div class=\"swiper-slide swiper__slide\">\n                <img src=\"https://img.hhcdn.ru/ichameleon/451465.png\" alt=\"img\">\n              </div>\n              <div class=\"swiper-slide swiper__slide\">\n                <img src=\"https://img.hhcdn.ru/ichameleon/451461.png\" alt=\"img\">\n              </div>\n              <div class=\"swiper-slide swiper__slide\">\n                <img src=\"https://img.hhcdn.ru/ichameleon/451463.png\" alt=\"img\">\n              </div>\n              <div class=\"swiper-slide swiper__slide\">\n                <img src=\"https://img.hhcdn.ru/ichameleon/451464.png\" alt=\"img\">\n              </div>\n              <div class=\"swiper-slide swiper__slide\">\n                <img src=\"https://img.hhcdn.ru/ichameleon/451462.png\" alt=\"img\">\n              </div>\n              <div class=\"swiper-slide swiper__slide\">\n                <img src=\"https://img.hhcdn.ru/ichameleon/451465.png\" alt=\"img\">\n              </div>\n            </div>\n          </div>\n        </div>\n        <div class=\"swiper__btns\">\n          <button class=\"swiper-button-prev swiper__button swiper__button-prev\" type=\"button\">\n            <svg width=\"10\" height=\"15\" viewBox=\"0 0 10 15\" fill=\"none\">\n              <path d=\"M8.74179 14.1583C9.1974 13.7027 9.1974 12.964 8.74179 12.5084L3.73341 7.5L8.74179 2.49162C9.1974 2.03601 9.1974 1.29732 8.74179 0.841709C8.28617 0.386097 7.54748 0.386097 7.09187 0.841709L1.25854 6.67504C0.802926 7.13065 0.802926 7.86935 1.25854 8.32496L7.09187 14.1583C7.54748 14.6139 8.28618 14.6139 8.74179 14.1583Z\" fill=\"#6B3FA0\"></path>\n            </svg>\n          </button>\n          <button class=\"swiper-button-next swiper__button swiper__button-next\" type=\"button\">\n            <svg width=\"10\" height=\"15\" viewBox=\"0 0 10 15\" fill=\"none\">\n              <path d=\"M1.25821 0.841709C0.802601 1.29732 0.802601 2.03601 1.25821 2.49162L6.26659 7.5L1.25821 12.5084C0.8026 12.964 0.8026 13.7027 1.25821 14.1583C1.71382 14.6139 2.45252 14.6139 2.90813 14.1583L8.74146 8.32496C9.19707 7.86935 9.19707 7.13065 8.74146 6.67504L2.90813 0.841709C2.45252 0.386097 1.71382 0.386097 1.25821 0.841709Z\" fill=\"#6B3FA0\"></path>\n            </svg>\n          </button>\n        </div>\n      </div>\n      <div class=\"tmpl_hh_aside__inner\">\n        <h3>Забота о сотрудниках</h3>\n        <ul class=\"tmpl_hh_aside__list\">\n          <li>\n            <div class=\"tmpl_hh_aside__text\">\n              <p>Профессиональный рост</p>\n              <span> Возможности для развития, получения новых знаний и навыков. </span>\n            </div>\n            <img src=\"https://img.hhcdn.ru/ichameleon/451466.png\" alt=\"icon\">\n          </li>\n          <li>\n            <div class=\"tmpl_hh_aside__text\">\n              <p>Корпоративный университет</p>\n              <span> Системное обучение и формирование компетенций, безграничный доступ к онлайн-библиотеке, курсам\n                и тренингам. </span>\n            </div>\n            <img src=\"https://img.hhcdn.ru/ichameleon/451467.png\" alt=\"icon\">\n          </li>\n          <li>\n            <div class=\"tmpl_hh_aside__text\">\n              <p>ДМС</p>\n              <span> Забота о здоровье сотрудников. Предлагаем широкую программу медицинского страхования, включая\n                стоматологию. </span>\n            </div>\n            <img src=\"https://img.hhcdn.ru/ichameleon/451468.png\" alt=\"icon\">\n          </li>\n          <li>\n            <div class=\"tmpl_hh_aside__text\">\n              <p>Насыщенная корпоративная жизнь</p>\n              <span> Участие в городских спортивных мероприятиях, социальных, благотворительных и волонтёрских акциях.\n              </span>\n            </div>\n            <img src=\"https://img.hhcdn.ru/ichameleon/451472.png\" alt=\"icon\">\n          </li>\n          <li>\n            <div class=\"tmpl_hh_aside__text\">\n              <p>Современный офис</p>\n              <span> В наших офисах есть всё для комфортной работы: кухонная зона, комната отдыха, настольные игры,\n                чай и кофе, полезные завтраки. </span>\n            </div>\n            <img src=\"https://img.hhcdn.ru/ichameleon/451469.png\" alt=\"icon\">\n          </li>\n          <li>\n            <div class=\"tmpl_hh_aside__text\">\n              <p>Легендарные корпоративы</p>\n              <span> Гавайские вечеринки на берегу моря или гала-ужин в центре города? Найдётся праздник на любой вкус!\n              </span>\n            </div>\n            <img src=\"https://img.hhcdn.ru/ichameleon/451470.png\" alt=\"icon\">\n          </li>\n          <li>\n            <div class=\"tmpl_hh_aside__text\">\n              <p>Корпоративные бенефиты</p>\n              <span> Скидки и бонусы от партнёров компании, корпоративный фитнес, компенсации за занятия по английскому\n                языку и многое другое. </span>\n            </div>\n            <img src=\"https://img.hhcdn.ru/ichameleon/451471.png\" alt=\"icon\">\n          </li>\n        </ul>\n        <section class=\"tmpl_hh_atmosphere\">\n          <div class=\"tmpl_hh_atmosphere__video\">\n            <iframe width=\"720\" height=\"405\" src=\"https://rutube.ru/play/embed/d4939d92f839c56271f0edf65c1bf969/\" frameBorder=\"0\" allow=\"clipboard-write; autoplay\" webkitAllowFullScreen=\"\" mozallowfullscreen=\"\" allowFullScreen=\"\"></iframe>\n          </div>\n        </section>\n        <h4>Присоединяйся к нам, чтобы вместе развивать <br class=\"tmpl_hh_xxl tmpl_hh_xl tmpl_hh_lg\">финтех-отрасль в\n          России и реализовывать <br class=\"tmpl_hh_xxl tmpl_hh_xl tmpl_hh_lg\">самые амбициозные\n          проекты!</h4>\n        <div class=\"tmpl_hh_footer\">\n          <span> подбор сотрудников осуществляется в ООО МИКРОФИНАНСОВАЯ КОМПАНИЯ \"ЛАЙМ-ЗАЙМ\" </span>\n        </div>\n      </div>\n    </aside>\n  </div>\n</div>\n<script>\n//\n\n\nconst main = \"\";\nconst customTitle = () => {\n  const allUl = document.querySelectorAll(\".tmpl_hh_content ul\");\n  allUl.forEach((ul, i) => {\n    const ulTitle = ul.previousElementSibling;\n    if (ulTitle) {\n      ulTitle.classList.add(\"tmpl_hh_content_title\");\n      if (i === 0) {\n        ul.previousElementSibling.classList.add(\"tmpl_hh_content_title--first\");\n      }\n    }\n  });\n};\nconst swiper_min = \"\";\nconst effectFade_min = \"\";\nfunction isObject$1(obj) {\n  return obj !== null && typeof obj === \"object\" && \"constructor\" in obj && obj.constructor === Object;\n}\nfunction extend$1(target = {}, src = {}) {\n  Object.keys(src).forEach((key) => {\n    if (typeof target[key] === \"undefined\")\n      target[key] = src[key];\n    else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n      extend$1(target[key], src[key]);\n    }\n  });\n}\nconst ssrDocument = {\n  body: {},\n  addEventListener() {\n  },\n  removeEventListener() {\n  },\n  activeElement: {\n    blur() {\n    },\n    nodeName: \"\"\n  },\n  querySelector() {\n    return null;\n  },\n  querySelectorAll() {\n    return [];\n  },\n  getElementById() {\n    return null;\n  },\n  createEvent() {\n    return {\n      initEvent() {\n      }\n    };\n  },\n  createElement() {\n    return {\n      children: [],\n      childNodes: [],\n      style: {},\n      setAttribute() {\n      },\n      getElementsByTagName() {\n        return [];\n      }\n    };\n  },\n  createElementNS() {\n    return {};\n  },\n  importNode() {\n    return null;\n  },\n  location: {\n    hash: \"\",\n    host: \"\",\n    hostname: \"\",\n    href: \"\",\n    origin: \"\",\n    pathname: \"\",\n    protocol: \"\",\n    search: \"\"\n  }\n};\nfunction getDocument() {\n  const doc = typeof document !== \"undefined\" ? document : {};\n  extend$1(doc, ssrDocument);\n  return doc;\n}\nconst ssrWindow = {\n  document: ssrDocument,\n  navigator: {\n    userAgent: \"\"\n  },\n  location: {\n    hash: \"\",\n    host: \"\",\n    hostname: \"\",\n    href: \"\",\n    origin: \"\",\n    pathname: \"\",\n    protocol: \"\",\n    search: \"\"\n  },\n  history: {\n    replaceState() {\n    },\n    pushState() {\n    },\n    go() {\n    },\n    back() {\n    }\n  },\n  CustomEvent: function CustomEvent() {\n    return this;\n  },\n  addEventListener() {\n  },\n  removeEventListener() {\n  },\n  getComputedStyle() {\n    return {\n      getPropertyValue() {\n        return \"\";\n      }\n    };\n  },\n  Image() {\n  },\n  Date() {\n  },\n  screen: {},\n  setTimeout() {\n  },\n  clearTimeout() {\n  },\n  matchMedia() {\n    return {};\n  },\n  requestAnimationFrame(callback) {\n    if (typeof setTimeout === \"undefined\") {\n      callback();\n      return null;\n    }\n    return setTimeout(callback, 0);\n  },\n  cancelAnimationFrame(id) {\n    if (typeof setTimeout === \"undefined\") {\n      return;\n    }\n    clearTimeout(id);\n  }\n};\nfunction getWindow() {\n  const win = typeof window !== \"undefined\" ? window : {};\n  extend$1(win, ssrWindow);\n  return win;\n}\nfunction deleteProps(obj) {\n  const object = obj;\n  Object.keys(object).forEach((key) => {\n    try {\n      object[key] = null;\n    } catch (e) {\n    }\n    try {\n      delete object[key];\n    } catch (e) {\n    }\n  });\n}\nfunction nextTick(callback, delay = 0) {\n  return setTimeout(callback, delay);\n}\nfunction now() {\n  return Date.now();\n}\nfunction getComputedStyle$1(el) {\n  const window2 = getWindow();\n  let style;\n  if (window2.getComputedStyle) {\n    style = window2.getComputedStyle(el, null);\n  }\n  if (!style && el.currentStyle) {\n    style = el.currentStyle;\n  }\n  if (!style) {\n    style = el.style;\n  }\n  return style;\n}\nfunction getTranslate(el, axis = \"x\") {\n  const window2 = getWindow();\n  let matrix;\n  let curTransform;\n  let transformMatrix;\n  const curStyle = getComputedStyle$1(el, null);\n  if (window2.WebKitCSSMatrix) {\n    curTransform = curStyle.transform || curStyle.webkitTransform;\n    if (curTransform.split(\",\").length > 6) {\n      curTransform = curTransform.split(\", \").map((a) => a.replace(\",\", \".\")).join(\", \");\n    }\n    transformMatrix = new window2.WebKitCSSMatrix(curTransform === \"none\" ? \"\" : curTransform);\n  } else {\n    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\");\n    matrix = transformMatrix.toString().split(\",\");\n  }\n  if (axis === \"x\") {\n    if (window2.WebKitCSSMatrix)\n      curTransform = transformMatrix.m41;\n    else if (matrix.length === 16)\n      curTransform = parseFloat(matrix[12]);\n    else\n      curTransform = parseFloat(matrix[4]);\n  }\n  if (axis === \"y\") {\n    if (window2.WebKitCSSMatrix)\n      curTransform = transformMatrix.m42;\n    else if (matrix.length === 16)\n      curTransform = parseFloat(matrix[13]);\n    else\n      curTransform = parseFloat(matrix[5]);\n  }\n  return curTransform || 0;\n}\nfunction isObject(o) {\n  return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\";\n}\nfunction isNode(node) {\n  if (typeof window !== \"undefined\" && typeof window.HTMLElement !== \"undefined\") {\n    return node instanceof HTMLElement;\n  }\n  return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction extend(...args) {\n  const to = Object(args[0]);\n  const noExtend = [\"__proto__\", \"constructor\", \"prototype\"];\n  for (let i = 1; i < args.length; i += 1) {\n    const nextSource = args[i];\n    if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {\n      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);\n      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n        const nextKey = keysArray[nextIndex];\n        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n        if (desc !== void 0 && desc.enumerable) {\n          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            to[nextKey] = {};\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n  }\n  return to;\n}\nfunction setCSSProperty(el, varName, varValue) {\n  el.style.setProperty(varName, varValue);\n}\nfunction animateCSSModeScroll({\n  swiper,\n  targetPosition,\n  side\n}) {\n  const window2 = getWindow();\n  const startPosition = -swiper.translate;\n  let startTime = null;\n  let time;\n  const duration = swiper.params.speed;\n  swiper.wrapperEl.style.scrollSnapType = \"none\";\n  window2.cancelAnimationFrame(swiper.cssModeFrameID);\n  const dir = targetPosition > startPosition ? \"next\" : \"prev\";\n  const isOutOfBound = (current, target) => {\n    return dir === \"next\" && current >= target || dir === \"prev\" && current <= target;\n  };\n  const animate = () => {\n    time = (/* @__PURE__ */ new Date()).getTime();\n    if (startTime === null) {\n      startTime = time;\n    }\n    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      currentPosition = targetPosition;\n    }\n    swiper.wrapperEl.scrollTo({\n      [side]: currentPosition\n    });\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      swiper.wrapperEl.style.overflow = \"hidden\";\n      swiper.wrapperEl.style.scrollSnapType = \"\";\n      setTimeout(() => {\n        swiper.wrapperEl.style.overflow = \"\";\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition\n        });\n      });\n      window2.cancelAnimationFrame(swiper.cssModeFrameID);\n      return;\n    }\n    swiper.cssModeFrameID = window2.requestAnimationFrame(animate);\n  };\n  animate();\n}\nfunction getSlideTransformEl(slideEl) {\n  return slideEl.querySelector(\".swiper-slide-transform\") || slideEl.shadowEl && slideEl.shadowEl.querySelector(\".swiper-slide-transform\") || slideEl;\n}\nfunction findElementsInElements(elements = [], selector = \"\") {\n  const found = [];\n  elements.forEach((el) => {\n    found.push(...el.querySelectorAll(selector));\n  });\n  return found;\n}\nfunction elementChildren(element, selector = \"\") {\n  return [...element.children].filter((el) => el.matches(selector));\n}\nfunction createElement(tag, classes2 = []) {\n  const el = document.createElement(tag);\n  el.classList.add(...Array.isArray(classes2) ? classes2 : [classes2]);\n  return el;\n}\nfunction elementOffset(el) {\n  const window2 = getWindow();\n  const document2 = getDocument();\n  const box = el.getBoundingClientRect();\n  const body = document2.body;\n  const clientTop = el.clientTop || body.clientTop || 0;\n  const clientLeft = el.clientLeft || body.clientLeft || 0;\n  const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;\n  const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;\n  return {\n    top: box.top + scrollTop - clientTop,\n    left: box.left + scrollLeft - clientLeft\n  };\n}\nfunction elementPrevAll(el, selector) {\n  const prevEls = [];\n  while (el.previousElementSibling) {\n    const prev = el.previousElementSibling;\n    if (selector) {\n      if (prev.matches(selector))\n        prevEls.push(prev);\n    } else\n      prevEls.push(prev);\n    el = prev;\n  }\n  return prevEls;\n}\nfunction elementNextAll(el, selector) {\n  const nextEls = [];\n  while (el.nextElementSibling) {\n    const next = el.nextElementSibling;\n    if (selector) {\n      if (next.matches(selector))\n        nextEls.push(next);\n    } else\n      nextEls.push(next);\n    el = next;\n  }\n  return nextEls;\n}\nfunction elementStyle(el, prop) {\n  const window2 = getWindow();\n  return window2.getComputedStyle(el, null).getPropertyValue(prop);\n}\nfunction elementIndex(el) {\n  let child = el;\n  let i;\n  if (child) {\n    i = 0;\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1)\n        i += 1;\n    }\n    return i;\n  }\n  return void 0;\n}\nfunction elementParents(el, selector) {\n  const parents = [];\n  let parent = el.parentElement;\n  while (parent) {\n    if (selector) {\n      if (parent.matches(selector))\n        parents.push(parent);\n    } else {\n      parents.push(parent);\n    }\n    parent = parent.parentElement;\n  }\n  return parents;\n}\nfunction elementTransitionEnd(el, callback) {\n  function fireCallBack(e) {\n    if (e.target !== el)\n      return;\n    callback.call(el, e);\n    el.removeEventListener(\"transitionend\", fireCallBack);\n  }\n  if (callback) {\n    el.addEventListener(\"transitionend\", fireCallBack);\n  }\n}\nfunction elementOuterSize(el, size, includeMargins) {\n  const window2 = getWindow();\n  if (includeMargins) {\n    return el[size === \"width\" ? \"offsetWidth\" : \"offsetHeight\"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-right\" : \"margin-top\")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-left\" : \"margin-bottom\"));\n  }\n  return el.offsetWidth;\n}\nlet support;\nfunction calcSupport() {\n  const window2 = getWindow();\n  const document2 = getDocument();\n  return {\n    smoothScroll: document2.documentElement && document2.documentElement.style && \"scrollBehavior\" in document2.documentElement.style,\n    touch: !!(\"ontouchstart\" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)\n  };\n}\nfunction getSupport() {\n  if (!support) {\n    support = calcSupport();\n  }\n  return support;\n}\nlet deviceCached;\nfunction calcDevice({\n  userAgent\n} = {}) {\n  const support2 = getSupport();\n  const window2 = getWindow();\n  const platform = window2.navigator.platform;\n  const ua = userAgent || window2.navigator.userAgent;\n  const device = {\n    ios: false,\n    android: false\n  };\n  const screenWidth = window2.screen.width;\n  const screenHeight = window2.screen.height;\n  const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n  let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n  const windows = platform === \"Win32\";\n  let macos = platform === \"MacIntel\";\n  const iPadScreens = [\"1024x1366\", \"1366x1024\", \"834x1194\", \"1194x834\", \"834x1112\", \"1112x834\", \"768x1024\", \"1024x768\", \"820x1180\", \"1180x820\", \"810x1080\", \"1080x810\"];\n  if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n    ipad = ua.match(/(Version)\\/([\\d.]+)/);\n    if (!ipad)\n      ipad = [0, 1, \"13_0_0\"];\n    macos = false;\n  }\n  if (android && !windows) {\n    device.os = \"android\";\n    device.android = true;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = \"ios\";\n    device.ios = true;\n  }\n  return device;\n}\nfunction getDevice(overrides = {}) {\n  if (!deviceCached) {\n    deviceCached = calcDevice(overrides);\n  }\n  return deviceCached;\n}\nlet browser;\nfunction calcBrowser() {\n  const window2 = getWindow();\n  let needPerspectiveFix = false;\n  function isSafari() {\n    const ua = window2.navigator.userAgent.toLowerCase();\n    return ua.indexOf(\"safari\") >= 0 && ua.indexOf(\"chrome\") < 0 && ua.indexOf(\"android\") < 0;\n  }\n  if (isSafari()) {\n    const ua = String(window2.navigator.userAgent);\n    if (ua.includes(\"Version/\")) {\n      const [major, minor] = ua.split(\"Version/\")[1].split(\" \")[0].split(\".\").map((num) => Number(num));\n      needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n    }\n  }\n  return {\n    isSafari: needPerspectiveFix || isSafari(),\n    needPerspectiveFix,\n    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)\n  };\n}\nfunction getBrowser() {\n  if (!browser) {\n    browser = calcBrowser();\n  }\n  return browser;\n}\nfunction Resize({\n  swiper,\n  on,\n  emit\n}) {\n  const window2 = getWindow();\n  let observer = null;\n  let animationFrame = null;\n  const resizeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized)\n      return;\n    emit(\"beforeResize\");\n    emit(\"resize\");\n  };\n  const createObserver = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized)\n      return;\n    observer = new ResizeObserver((entries) => {\n      animationFrame = window2.requestAnimationFrame(() => {\n        const {\n          width,\n          height\n        } = swiper;\n        let newWidth = width;\n        let newHeight = height;\n        entries.forEach(({\n          contentBoxSize,\n          contentRect,\n          target\n        }) => {\n          if (target && target !== swiper.el)\n            return;\n          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n        });\n        if (newWidth !== width || newHeight !== height) {\n          resizeHandler();\n        }\n      });\n    });\n    observer.observe(swiper.el);\n  };\n  const removeObserver = () => {\n    if (animationFrame) {\n      window2.cancelAnimationFrame(animationFrame);\n    }\n    if (observer && observer.unobserve && swiper.el) {\n      observer.unobserve(swiper.el);\n      observer = null;\n    }\n  };\n  const orientationChangeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized)\n      return;\n    emit(\"orientationchange\");\n  };\n  on(\"init\", () => {\n    if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== \"undefined\") {\n      createObserver();\n      return;\n    }\n    window2.addEventListener(\"resize\", resizeHandler);\n    window2.addEventListener(\"orientationchange\", orientationChangeHandler);\n  });\n  on(\"destroy\", () => {\n    removeObserver();\n    window2.removeEventListener(\"resize\", resizeHandler);\n    window2.removeEventListener(\"orientationchange\", orientationChangeHandler);\n  });\n}\nfunction Observer({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const observers = [];\n  const window2 = getWindow();\n  const attach = (target, options = {}) => {\n    const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;\n    const observer = new ObserverFunc((mutations) => {\n      if (swiper.__preventObserver__)\n        return;\n      if (mutations.length === 1) {\n        emit(\"observerUpdate\", mutations[0]);\n        return;\n      }\n      const observerUpdate = function observerUpdate2() {\n        emit(\"observerUpdate\", mutations[0]);\n      };\n      if (window2.requestAnimationFrame) {\n        window2.requestAnimationFrame(observerUpdate);\n      } else {\n        window2.setTimeout(observerUpdate, 0);\n      }\n    });\n    observer.observe(target, {\n      attributes: typeof options.attributes === \"undefined\" ? true : options.attributes,\n      childList: typeof options.childList === \"undefined\" ? true : options.childList,\n      characterData: typeof options.characterData === \"undefined\" ? true : options.characterData\n    });\n    observers.push(observer);\n  };\n  const init = () => {\n    if (!swiper.params.observer)\n      return;\n    if (swiper.params.observeParents) {\n      const containerParents = elementParents(swiper.el);\n      for (let i = 0; i < containerParents.length; i += 1) {\n        attach(containerParents[i]);\n      }\n    }\n    attach(swiper.el, {\n      childList: swiper.params.observeSlideChildren\n    });\n    attach(swiper.wrapperEl, {\n      attributes: false\n    });\n  };\n  const destroy = () => {\n    observers.forEach((observer) => {\n      observer.disconnect();\n    });\n    observers.splice(0, observers.length);\n  };\n  extendParams({\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false\n  });\n  on(\"init\", init);\n  on(\"destroy\", destroy);\n}\nconst eventsEmitter = {\n  on(events2, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (typeof handler !== \"function\")\n      return self;\n    const method = priority ? \"unshift\" : \"push\";\n    events2.split(\" \").forEach((event2) => {\n      if (!self.eventsListeners[event2])\n        self.eventsListeners[event2] = [];\n      self.eventsListeners[event2][method](handler);\n    });\n    return self;\n  },\n  once(events2, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (typeof handler !== \"function\")\n      return self;\n    function onceHandler(...args) {\n      self.off(events2, onceHandler);\n      if (onceHandler.__emitterProxy) {\n        delete onceHandler.__emitterProxy;\n      }\n      handler.apply(self, args);\n    }\n    onceHandler.__emitterProxy = handler;\n    return self.on(events2, onceHandler, priority);\n  },\n  onAny(handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (typeof handler !== \"function\")\n      return self;\n    const method = priority ? \"unshift\" : \"push\";\n    if (self.eventsAnyListeners.indexOf(handler) < 0) {\n      self.eventsAnyListeners[method](handler);\n    }\n    return self;\n  },\n  offAny(handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (!self.eventsAnyListeners)\n      return self;\n    const index = self.eventsAnyListeners.indexOf(handler);\n    if (index >= 0) {\n      self.eventsAnyListeners.splice(index, 1);\n    }\n    return self;\n  },\n  off(events2, handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (!self.eventsListeners)\n      return self;\n    events2.split(\" \").forEach((event2) => {\n      if (typeof handler === \"undefined\") {\n        self.eventsListeners[event2] = [];\n      } else if (self.eventsListeners[event2]) {\n        self.eventsListeners[event2].forEach((eventHandler, index) => {\n          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n            self.eventsListeners[event2].splice(index, 1);\n          }\n        });\n      }\n    });\n    return self;\n  },\n  emit(...args) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (!self.eventsListeners)\n      return self;\n    let events2;\n    let data;\n    let context;\n    if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n      events2 = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events2 = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n    data.unshift(context);\n    const eventsArray = Array.isArray(events2) ? events2 : events2.split(\" \");\n    eventsArray.forEach((event2) => {\n      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n        self.eventsAnyListeners.forEach((eventHandler) => {\n          eventHandler.apply(context, [event2, ...data]);\n        });\n      }\n      if (self.eventsListeners && self.eventsListeners[event2]) {\n        self.eventsListeners[event2].forEach((eventHandler) => {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  }\n};\nfunction updateSize() {\n  const swiper = this;\n  let width;\n  let height;\n  const el = swiper.el;\n  if (typeof swiper.params.width !== \"undefined\" && swiper.params.width !== null) {\n    width = swiper.params.width;\n  } else {\n    width = el.clientWidth;\n  }\n  if (typeof swiper.params.height !== \"undefined\" && swiper.params.height !== null) {\n    height = swiper.params.height;\n  } else {\n    height = el.clientHeight;\n  }\n  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n    return;\n  }\n  width = width - parseInt(elementStyle(el, \"padding-left\") || 0, 10) - parseInt(elementStyle(el, \"padding-right\") || 0, 10);\n  height = height - parseInt(elementStyle(el, \"padding-top\") || 0, 10) - parseInt(elementStyle(el, \"padding-bottom\") || 0, 10);\n  if (Number.isNaN(width))\n    width = 0;\n  if (Number.isNaN(height))\n    height = 0;\n  Object.assign(swiper, {\n    width,\n    height,\n    size: swiper.isHorizontal() ? width : height\n  });\n}\nfunction updateSlides() {\n  const swiper = this;\n  function getDirectionLabel(property) {\n    if (swiper.isHorizontal()) {\n      return property;\n    }\n    return {\n      \"width\": \"height\",\n      \"margin-top\": \"margin-left\",\n      \"margin-bottom \": \"margin-right\",\n      \"margin-left\": \"margin-top\",\n      \"margin-right\": \"margin-bottom\",\n      \"padding-left\": \"padding-top\",\n      \"padding-right\": \"padding-bottom\",\n      \"marginRight\": \"marginBottom\"\n    }[property];\n  }\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n  }\n  const params = swiper.params;\n  const {\n    wrapperEl,\n    slidesEl,\n    size: swiperSize,\n    rtlTranslate: rtl,\n    wrongRTL\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === \"function\") {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === \"function\") {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n  if (typeof swiperSize === \"undefined\") {\n    return;\n  }\n  if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiperSize;\n  } else if (typeof spaceBetween === \"string\") {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n  swiper.virtualSize = -spaceBetween;\n  slides.forEach((slideEl) => {\n    if (rtl) {\n      slideEl.style.marginLeft = \"\";\n    } else {\n      slideEl.style.marginRight = \"\";\n    }\n    slideEl.style.marginBottom = \"\";\n    slideEl.style.marginTop = \"\";\n  });\n  if (params.centeredSlides && params.cssMode) {\n    setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", \"\");\n    setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", \"\");\n  }\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n  if (gridEnabled) {\n    swiper.grid.initSlides(slidesLength);\n  }\n  let slideSize;\n  const shouldResetSlideSize = params.slidesPerView === \"auto\" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {\n    return typeof params.breakpoints[key].slidesPerView !== \"undefined\";\n  }).length > 0;\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    let slide2;\n    if (slides[i])\n      slide2 = slides[i];\n    if (gridEnabled) {\n      swiper.grid.updateSlide(i, slide2, slidesLength, getDirectionLabel);\n    }\n    if (slides[i] && elementStyle(slide2, \"display\") === \"none\")\n      continue;\n    if (params.slidesPerView === \"auto\") {\n      if (shouldResetSlideSize) {\n        slides[i].style[getDirectionLabel(\"width\")] = ``;\n      }\n      const slideStyles = getComputedStyle(slide2);\n      const currentTransform = slide2.style.transform;\n      const currentWebKitTransform = slide2.style.webkitTransform;\n      if (currentTransform) {\n        slide2.style.transform = \"none\";\n      }\n      if (currentWebKitTransform) {\n        slide2.style.webkitTransform = \"none\";\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, \"width\", true) : elementOuterSize(slide2, \"height\", true);\n      } else {\n        const width = getDirectionPropertyValue(slideStyles, \"width\");\n        const paddingLeft = getDirectionPropertyValue(slideStyles, \"padding-left\");\n        const paddingRight = getDirectionPropertyValue(slideStyles, \"padding-right\");\n        const marginLeft = getDirectionPropertyValue(slideStyles, \"margin-left\");\n        const marginRight = getDirectionPropertyValue(slideStyles, \"margin-right\");\n        const boxSizing = slideStyles.getPropertyValue(\"box-sizing\");\n        if (boxSizing && boxSizing === \"border-box\") {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const {\n            clientWidth,\n            offsetWidth\n          } = slide2;\n          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n        }\n      }\n      if (currentTransform) {\n        slide2.style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide2.style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths)\n        slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths)\n        slideSize = Math.floor(slideSize);\n      if (slides[i]) {\n        slides[i].style[getDirectionLabel(\"width\")] = `${slideSize}px`;\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0)\n        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0)\n        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1e3)\n        slidePosition = 0;\n      if (params.roundLengths)\n        slidePosition = Math.floor(slidePosition);\n      if (index % params.slidesPerGroup === 0)\n        snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths)\n        slidePosition = Math.floor(slidePosition);\n      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0)\n        snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n    swiper.virtualSize += slideSize + spaceBetween;\n    prevSlideSize = slideSize;\n    index += 1;\n  }\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n  if (rtl && wrongRTL && (params.effect === \"slide\" || params.effect === \"coverflow\")) {\n    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n  }\n  if (params.setWrapperSize) {\n    wrapperEl.style[getDirectionLabel(\"width\")] = `${swiper.virtualSize + spaceBetween}px`;\n  }\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n  }\n  if (!params.centeredSlides) {\n    const newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths)\n        slidesGridItem = Math.floor(slidesGridItem);\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (isVirtual && params.loop) {\n    const size = slidesSizesGrid[0] + spaceBetween;\n    if (params.slidesPerGroup > 1) {\n      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n      const groupSize = size * params.slidesPerGroup;\n      for (let i = 0; i < groups; i += 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n      }\n    }\n    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n      if (params.slidesPerGroup === 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n      }\n      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n      swiper.virtualSize += size;\n    }\n  }\n  if (snapGrid.length === 0)\n    snapGrid = [0];\n  if (spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? \"marginLeft\" : getDirectionLabel(\"marginRight\");\n    slides.filter((_, slideIndex) => {\n      if (!params.cssMode || params.loop)\n        return true;\n      if (slideIndex === slides.length - 1) {\n        return false;\n      }\n      return true;\n    }).forEach((slideEl) => {\n      slideEl.style[key] = `${spaceBetween}px`;\n    });\n  }\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map((snap) => {\n      if (snap <= 0)\n        return -offsetBefore;\n      if (snap > maxSnap)\n        return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid\n  });\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", `${-snapGrid[0]}px`);\n    setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);\n  }\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit(\"slidesLengthChange\");\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow)\n      swiper.checkOverflow();\n    swiper.emit(\"snapGridLengthChange\");\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit(\"slidesGridLengthChange\");\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  if (!isVirtual && !params.cssMode && (params.effect === \"slide\" || params.effect === \"fade\")) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded)\n        swiper.el.classList.add(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.el.classList.remove(backFaceHiddenClass);\n    }\n  }\n}\nfunction updateAutoHeight(speed) {\n  const swiper = this;\n  const activeSlides = [];\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  let newHeight = 0;\n  let i;\n  if (typeof speed === \"number\") {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n  const getSlideByIndex = (index) => {\n    if (isVirtual) {\n      return swiper.slides[swiper.getSlideIndexByData(index)];\n    }\n    return swiper.slides[index];\n  };\n  if (swiper.params.slidesPerView !== \"auto\" && swiper.params.slidesPerView > 1) {\n    if (swiper.params.centeredSlides) {\n      (swiper.visibleSlides || []).forEach((slide2) => {\n        activeSlides.push(slide2);\n      });\n    } else {\n      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n        const index = swiper.activeIndex + i;\n        if (index > swiper.slides.length && !isVirtual)\n          break;\n        activeSlides.push(getSlideByIndex(index));\n      }\n    }\n  } else {\n    activeSlides.push(getSlideByIndex(swiper.activeIndex));\n  }\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== \"undefined\") {\n      const height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n  if (newHeight || newHeight === 0)\n    swiper.wrapperEl.style.height = `${newHeight}px`;\n}\nfunction updateSlidesOffset() {\n  const swiper = this;\n  const slides = swiper.slides;\n  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n  for (let i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n  }\n}\nfunction updateSlidesProgress(translate2 = this && this.translate || 0) {\n  const swiper = this;\n  const params = swiper.params;\n  const {\n    slides,\n    rtlTranslate: rtl,\n    snapGrid\n  } = swiper;\n  if (slides.length === 0)\n    return;\n  if (typeof slides[0].swiperSlideOffset === \"undefined\")\n    swiper.updateSlidesOffset();\n  let offsetCenter = -translate2;\n  if (rtl)\n    offsetCenter = translate2;\n  slides.forEach((slideEl) => {\n    slideEl.classList.remove(params.slideVisibleClass);\n  });\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n  let spaceBetween = params.spaceBetween;\n  if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiper.size;\n  } else if (typeof spaceBetween === \"string\") {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n  for (let i = 0; i < slides.length; i += 1) {\n    const slide2 = slides[i];\n    let slideOffset = slide2.swiperSlideOffset;\n    if (params.cssMode && params.centeredSlides) {\n      slideOffset -= slides[0].swiperSlideOffset;\n    }\n    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);\n    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);\n    const slideBefore = -(offsetCenter - slideOffset);\n    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n    if (isVisible) {\n      swiper.visibleSlides.push(slide2);\n      swiper.visibleSlidesIndexes.push(i);\n      slides[i].classList.add(params.slideVisibleClass);\n    }\n    slide2.progress = rtl ? -slideProgress : slideProgress;\n    slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n  }\n}\nfunction updateProgress(translate2) {\n  const swiper = this;\n  if (typeof translate2 === \"undefined\") {\n    const multiplier = swiper.rtlTranslate ? -1 : 1;\n    translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;\n  }\n  const params = swiper.params;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  let {\n    progress,\n    isBeginning,\n    isEnd,\n    progressLoop\n  } = swiper;\n  const wasBeginning = isBeginning;\n  const wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate2 - swiper.minTranslate()) / translatesDiff;\n    const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;\n    const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;\n    isBeginning = isBeginningRounded || progress <= 0;\n    isEnd = isEndRounded || progress >= 1;\n    if (isBeginningRounded)\n      progress = 0;\n    if (isEndRounded)\n      progress = 1;\n  }\n  if (params.loop) {\n    const firstSlideIndex = swiper.getSlideIndexByData(0);\n    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n    const translateAbs = Math.abs(translate2);\n    if (translateAbs >= firstSlideTranslate) {\n      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n    } else {\n      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n    }\n    if (progressLoop > 1)\n      progressLoop -= 1;\n  }\n  Object.assign(swiper, {\n    progress,\n    progressLoop,\n    isBeginning,\n    isEnd\n  });\n  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)\n    swiper.updateSlidesProgress(translate2);\n  if (isBeginning && !wasBeginning) {\n    swiper.emit(\"reachBeginning toEdge\");\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit(\"reachEnd toEdge\");\n  }\n  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n    swiper.emit(\"fromEdge\");\n  }\n  swiper.emit(\"progress\", progress);\n}\nfunction updateSlidesClasses() {\n  const swiper = this;\n  const {\n    slides,\n    params,\n    slidesEl,\n    activeIndex\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const getFilteredSlide = (selector) => {\n    return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n  };\n  slides.forEach((slideEl) => {\n    slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n  });\n  let activeSlide;\n  if (isVirtual) {\n    if (params.loop) {\n      let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n      if (slideIndex < 0)\n        slideIndex = swiper.virtual.slides.length + slideIndex;\n      if (slideIndex >= swiper.virtual.slides.length)\n        slideIndex -= swiper.virtual.slides.length;\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n    } else {\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n    }\n  } else {\n    activeSlide = slides[activeIndex];\n  }\n  if (activeSlide) {\n    activeSlide.classList.add(params.slideActiveClass);\n    let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n    if (params.loop && !nextSlide) {\n      nextSlide = slides[0];\n    }\n    if (nextSlide) {\n      nextSlide.classList.add(params.slideNextClass);\n    }\n    let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n    if (params.loop && !prevSlide === 0) {\n      prevSlide = slides[slides.length - 1];\n    }\n    if (prevSlide) {\n      prevSlide.classList.add(params.slidePrevClass);\n    }\n  }\n  swiper.emitSlidesClasses();\n}\nconst processLazyPreloader = (swiper, imageEl) => {\n  if (!swiper || swiper.destroyed || !swiper.params)\n    return;\n  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n  const slideEl = imageEl.closest(slideSelector());\n  if (slideEl) {\n    const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n    if (lazyEl)\n      lazyEl.remove();\n  }\n};\nconst unlazy = (swiper, index) => {\n  if (!swiper.slides[index])\n    return;\n  const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n  if (imageEl)\n    imageEl.removeAttribute(\"loading\");\n};\nconst preload = (swiper) => {\n  if (!swiper || swiper.destroyed || !swiper.params)\n    return;\n  let amount = swiper.params.lazyPreloadPrevNext;\n  const len = swiper.slides.length;\n  if (!len || !amount || amount < 0)\n    return;\n  amount = Math.min(amount, len);\n  const slidesPerView = swiper.params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n  const activeIndex = swiper.activeIndex;\n  if (swiper.params.grid && swiper.params.grid.rows > 1) {\n    const activeColumn = activeIndex;\n    const preloadColumns = [activeColumn - amount];\n    preloadColumns.push(...Array.from({\n      length: amount\n    }).map((_, i) => {\n      return activeColumn + slidesPerView + i;\n    }));\n    swiper.slides.forEach((slideEl, i) => {\n      if (preloadColumns.includes(slideEl.column))\n        unlazy(swiper, i);\n    });\n    return;\n  }\n  const slideIndexLastInView = activeIndex + slidesPerView - 1;\n  if (swiper.params.rewind || swiper.params.loop) {\n    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n      const realIndex = (i % len + len) % len;\n      if (realIndex < activeIndex || realIndex > slideIndexLastInView)\n        unlazy(swiper, realIndex);\n    }\n  } else {\n    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {\n      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n        unlazy(swiper, i);\n      }\n    }\n  }\n};\nfunction getActiveIndexByTranslate(swiper) {\n  const {\n    slidesGrid,\n    params\n  } = swiper;\n  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  let activeIndex;\n  for (let i = 0; i < slidesGrid.length; i += 1) {\n    if (typeof slidesGrid[i + 1] !== \"undefined\") {\n      if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n        activeIndex = i;\n      } else if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1]) {\n        activeIndex = i + 1;\n      }\n    } else if (translate2 >= slidesGrid[i]) {\n      activeIndex = i;\n    }\n  }\n  if (params.normalizeSlideIndex) {\n    if (activeIndex < 0 || typeof activeIndex === \"undefined\")\n      activeIndex = 0;\n  }\n  return activeIndex;\n}\nfunction updateActiveIndex(newActiveIndex) {\n  const swiper = this;\n  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  const {\n    snapGrid,\n    params,\n    activeIndex: previousIndex,\n    realIndex: previousRealIndex,\n    snapIndex: previousSnapIndex\n  } = swiper;\n  let activeIndex = newActiveIndex;\n  let snapIndex;\n  const getVirtualRealIndex = (aIndex) => {\n    let realIndex2 = aIndex - swiper.virtual.slidesBefore;\n    if (realIndex2 < 0) {\n      realIndex2 = swiper.virtual.slides.length + realIndex2;\n    }\n    if (realIndex2 >= swiper.virtual.slides.length) {\n      realIndex2 -= swiper.virtual.slides.length;\n    }\n    return realIndex2;\n  };\n  if (typeof activeIndex === \"undefined\") {\n    activeIndex = getActiveIndexByTranslate(swiper);\n  }\n  if (snapGrid.indexOf(translate2) >= 0) {\n    snapIndex = snapGrid.indexOf(translate2);\n  } else {\n    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length)\n    snapIndex = snapGrid.length - 1;\n  if (activeIndex === previousIndex) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit(\"snapIndexChange\");\n    }\n    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.realIndex = getVirtualRealIndex(activeIndex);\n    }\n    return;\n  }\n  let realIndex;\n  if (swiper.virtual && params.virtual.enabled && params.loop) {\n    realIndex = getVirtualRealIndex(activeIndex);\n  } else if (swiper.slides[activeIndex]) {\n    realIndex = parseInt(swiper.slides[activeIndex].getAttribute(\"data-swiper-slide-index\") || activeIndex, 10);\n  } else {\n    realIndex = activeIndex;\n  }\n  Object.assign(swiper, {\n    previousSnapIndex,\n    snapIndex,\n    previousRealIndex,\n    realIndex,\n    previousIndex,\n    activeIndex\n  });\n  if (swiper.initialized) {\n    preload(swiper);\n  }\n  swiper.emit(\"activeIndexChange\");\n  swiper.emit(\"snapIndexChange\");\n  if (previousRealIndex !== realIndex) {\n    swiper.emit(\"realIndexChange\");\n  }\n  if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n    swiper.emit(\"slideChange\");\n  }\n}\nfunction updateClickedSlide(e) {\n  const swiper = this;\n  const params = swiper.params;\n  const slide2 = e.closest(`.${params.slideClass}, swiper-slide`);\n  let slideFound = false;\n  let slideIndex;\n  if (slide2) {\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide2) {\n        slideFound = true;\n        slideIndex = i;\n        break;\n      }\n    }\n  }\n  if (slide2 && slideFound) {\n    swiper.clickedSlide = slide2;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt(slide2.getAttribute(\"data-swiper-slide-index\"), 10);\n    } else {\n      swiper.clickedIndex = slideIndex;\n    }\n  } else {\n    swiper.clickedSlide = void 0;\n    swiper.clickedIndex = void 0;\n    return;\n  }\n  if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {\n    swiper.slideToClickedSlide();\n  }\n}\nconst update = {\n  updateSize,\n  updateSlides,\n  updateAutoHeight,\n  updateSlidesOffset,\n  updateSlidesProgress,\n  updateProgress,\n  updateSlidesClasses,\n  updateActiveIndex,\n  updateClickedSlide\n};\nfunction getSwiperTranslate(axis = this.isHorizontal() ? \"x\" : \"y\") {\n  const swiper = this;\n  const {\n    params,\n    rtlTranslate: rtl,\n    translate: translate2,\n    wrapperEl\n  } = swiper;\n  if (params.virtualTranslate) {\n    return rtl ? -translate2 : translate2;\n  }\n  if (params.cssMode) {\n    return translate2;\n  }\n  let currentTranslate = getTranslate(wrapperEl, axis);\n  currentTranslate += swiper.cssOverflowAdjustment();\n  if (rtl)\n    currentTranslate = -currentTranslate;\n  return currentTranslate || 0;\n}\nfunction setTranslate(translate2, byController) {\n  const swiper = this;\n  const {\n    rtlTranslate: rtl,\n    params,\n    wrapperEl,\n    progress\n  } = swiper;\n  let x = 0;\n  let y = 0;\n  const z = 0;\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate2 : translate2;\n  } else {\n    y = translate2;\n  }\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y;\n  if (params.cssMode) {\n    wrapperEl[swiper.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = swiper.isHorizontal() ? -x : -y;\n  } else if (!params.virtualTranslate) {\n    if (swiper.isHorizontal()) {\n      x -= swiper.cssOverflowAdjustment();\n    } else {\n      y -= swiper.cssOverflowAdjustment();\n    }\n    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n  }\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate2);\n  }\n  swiper.emit(\"setTranslate\", swiper.translate, byController);\n}\nfunction minTranslate() {\n  return -this.snapGrid[0];\n}\nfunction maxTranslate() {\n  return -this.snapGrid[this.snapGrid.length - 1];\n}\nfunction translateTo(translate2 = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {\n  const swiper = this;\n  const {\n    params,\n    wrapperEl\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n  const minTranslate2 = swiper.minTranslate();\n  const maxTranslate2 = swiper.maxTranslate();\n  let newTranslate;\n  if (translateBounds && translate2 > minTranslate2)\n    newTranslate = minTranslate2;\n  else if (translateBounds && translate2 < maxTranslate2)\n    newTranslate = maxTranslate2;\n  else\n    newTranslate = translate2;\n  swiper.updateProgress(newTranslate);\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    if (speed === 0) {\n      wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = -newTranslate;\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: -newTranslate,\n          side: isH ? \"left\" : \"top\"\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? \"left\" : \"top\"]: -newTranslate,\n        behavior: \"smooth\"\n      });\n    }\n    return true;\n  }\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit(\"beforeTransitionStart\", speed, internal);\n      swiper.emit(\"transitionEnd\");\n    }\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit(\"beforeTransitionStart\", speed, internal);\n      swiper.emit(\"transitionStart\");\n    }\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onTranslateToWrapperTransitionEnd) {\n        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e) {\n          if (!swiper || swiper.destroyed)\n            return;\n          if (e.target !== this)\n            return;\n          swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n          swiper.onTranslateToWrapperTransitionEnd = null;\n          delete swiper.onTranslateToWrapperTransitionEnd;\n          if (runCallbacks) {\n            swiper.emit(\"transitionEnd\");\n          }\n        };\n      }\n      swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n    }\n  }\n  return true;\n}\nconst translate = {\n  getTranslate: getSwiperTranslate,\n  setTranslate,\n  minTranslate,\n  maxTranslate,\n  translateTo\n};\nfunction setTransition(duration, byController) {\n  const swiper = this;\n  if (!swiper.params.cssMode) {\n    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n  }\n  swiper.emit(\"setTransition\", duration, byController);\n}\nfunction transitionEmit({\n  swiper,\n  runCallbacks,\n  direction,\n  step\n}) {\n  const {\n    activeIndex,\n    previousIndex\n  } = swiper;\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex)\n      dir = \"next\";\n    else if (activeIndex < previousIndex)\n      dir = \"prev\";\n    else\n      dir = \"reset\";\n  }\n  swiper.emit(`transition${step}`);\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === \"reset\") {\n      swiper.emit(`slideResetTransition${step}`);\n      return;\n    }\n    swiper.emit(`slideChangeTransition${step}`);\n    if (dir === \"next\") {\n      swiper.emit(`slideNextTransition${step}`);\n    } else {\n      swiper.emit(`slidePrevTransition${step}`);\n    }\n  }\n}\nfunction transitionStart(runCallbacks = true, direction) {\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  if (params.cssMode)\n    return;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n  transitionEmit({\n    swiper,\n    runCallbacks,\n    direction,\n    step: \"Start\"\n  });\n}\nfunction transitionEnd(runCallbacks = true, direction) {\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  swiper.animating = false;\n  if (params.cssMode)\n    return;\n  swiper.setTransition(0);\n  transitionEmit({\n    swiper,\n    runCallbacks,\n    direction,\n    step: \"End\"\n  });\n}\nconst transition = {\n  setTransition,\n  transitionStart,\n  transitionEnd\n};\nfunction slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {\n  if (typeof index === \"string\") {\n    index = parseInt(index, 10);\n  }\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0)\n    slideIndex = 0;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl,\n    enabled\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n    return false;\n  }\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length)\n    snapIndex = snapGrid.length - 1;\n  const translate2 = -snapGrid[snapIndex];\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      const normalizedTranslate = -Math.floor(translate2 * 100);\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n      if (typeof slidesGrid[i + 1] !== \"undefined\") {\n        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  }\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && (rtl ? translate2 > swiper.translate && translate2 > swiper.minTranslate() : translate2 < swiper.translate && translate2 < swiper.minTranslate())) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) {\n        return false;\n      }\n    }\n  }\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit(\"beforeSlideChangeStart\");\n  }\n  swiper.updateProgress(translate2);\n  let direction;\n  if (slideIndex > activeIndex)\n    direction = \"next\";\n  else if (slideIndex < activeIndex)\n    direction = \"prev\";\n  else\n    direction = \"reset\";\n  if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex);\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== \"slide\") {\n      swiper.setTranslate(translate2);\n    }\n    if (direction !== \"reset\") {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    const t = rtl ? translate2 : -translate2;\n    if (speed === 0) {\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = \"none\";\n        swiper._immediateVirtual = true;\n      }\n      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n        swiper._cssModeVirtualInitialSet = true;\n        requestAnimationFrame(() => {\n          wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n        });\n      } else {\n        wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n      }\n      if (isVirtual) {\n        requestAnimationFrame(() => {\n          swiper.wrapperEl.style.scrollSnapType = \"\";\n          swiper._immediateVirtual = false;\n        });\n      }\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: t,\n          side: isH ? \"left\" : \"top\"\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? \"left\" : \"top\"]: t,\n        behavior: \"smooth\"\n      });\n    }\n    return true;\n  }\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate2);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit(\"beforeTransitionStart\", speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e) {\n        if (!swiper || swiper.destroyed)\n          return;\n        if (e.target !== this)\n          return;\n        swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n    swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n  }\n  return true;\n}\nfunction slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {\n  if (typeof index === \"string\") {\n    const indexAsNumber = parseInt(index, 10);\n    index = indexAsNumber;\n  }\n  const swiper = this;\n  let newIndex = index;\n  if (swiper.params.loop) {\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      newIndex = newIndex + swiper.virtual.slidesBefore;\n    } else {\n      newIndex = swiper.getSlideIndexByData(newIndex);\n    }\n  }\n  return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n}\nfunction slideNext(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const {\n    enabled,\n    params,\n    animating\n  } = swiper;\n  if (!enabled)\n    return swiper;\n  let perGroup = params.slidesPerGroup;\n  if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n    perGroup = Math.max(swiper.slidesPerViewDynamic(\"current\", true), 1);\n  }\n  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding)\n      return false;\n    swiper.loopFix({\n      direction: \"next\"\n    });\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n  }\n  if (params.rewind && swiper.isEnd) {\n    return swiper.slideTo(0, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\nfunction slidePrev(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    rtlTranslate,\n    enabled,\n    animating\n  } = swiper;\n  if (!enabled)\n    return swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding)\n      return false;\n    swiper.loopFix({\n      direction: \"prev\"\n    });\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n  }\n  const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;\n  function normalize(val) {\n    if (val < 0)\n      return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n  const normalizedTranslate = normalize(translate2);\n  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));\n  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n  if (typeof prevSnap === \"undefined\" && params.cssMode) {\n    let prevSnapIndex;\n    snapGrid.forEach((snap, snapIndex) => {\n      if (normalizedTranslate >= snap) {\n        prevSnapIndex = snapIndex;\n      }\n    });\n    if (typeof prevSnapIndex !== \"undefined\") {\n      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n    }\n  }\n  let prevIndex = 0;\n  if (typeof prevSnap !== \"undefined\") {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0)\n      prevIndex = swiper.activeIndex - 1;\n    if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n      prevIndex = prevIndex - swiper.slidesPerViewDynamic(\"previous\", true) + 1;\n      prevIndex = Math.max(prevIndex, 0);\n    }\n  }\n  if (params.rewind && swiper.isBeginning) {\n    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\nfunction slideReset(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\nfunction slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {\n  const swiper = this;\n  let index = swiper.activeIndex;\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  if (translate2 >= swiper.snapGrid[snapIndex]) {\n    const currentSnap = swiper.snapGrid[snapIndex];\n    const nextSnap = swiper.snapGrid[snapIndex + 1];\n    if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {\n      index += swiper.params.slidesPerGroup;\n    }\n  } else {\n    const prevSnap = swiper.snapGrid[snapIndex - 1];\n    const currentSnap = swiper.snapGrid[snapIndex];\n    if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {\n      index -= swiper.params.slidesPerGroup;\n    }\n  }\n  index = Math.max(index, 0);\n  index = Math.min(index, swiper.slidesGrid.length - 1);\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}\nfunction slideToClickedSlide() {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  let slideToIndex = swiper.clickedIndex;\n  let realIndex;\n  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n  if (params.loop) {\n    if (swiper.animating)\n      return;\n    realIndex = parseInt(swiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n    if (params.centeredSlides) {\n      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n        swiper.loopFix();\n        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n        nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n      nextTick(() => {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\nconst slide = {\n  slideTo,\n  slideToLoop,\n  slideNext,\n  slidePrev,\n  slideReset,\n  slideToClosest,\n  slideToClickedSlide\n};\nfunction loopCreate(slideRealIndex) {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)\n    return;\n  const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n  slides.forEach((el, index) => {\n    el.setAttribute(\"data-swiper-slide-index\", index);\n  });\n  swiper.loopFix({\n    slideRealIndex,\n    direction: params.centeredSlides ? void 0 : \"next\"\n  });\n}\nfunction loopFix({\n  slideRealIndex,\n  slideTo: slideTo2 = true,\n  direction,\n  setTranslate: setTranslate2,\n  activeSlideIndex,\n  byController,\n  byMousewheel\n} = {}) {\n  const swiper = this;\n  if (!swiper.params.loop)\n    return;\n  swiper.emit(\"beforeLoopFix\");\n  const {\n    slides,\n    allowSlidePrev,\n    allowSlideNext,\n    slidesEl,\n    params\n  } = swiper;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n  if (swiper.virtual && params.virtual.enabled) {\n    if (slideTo2) {\n      if (!params.centeredSlides && swiper.snapIndex === 0) {\n        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n      }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    swiper.emit(\"loopFix\");\n    return;\n  }\n  const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n  let loopedSlides = params.loopedSlides || slidesPerView;\n  if (loopedSlides % params.slidesPerGroup !== 0) {\n    loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n  }\n  swiper.loopedSlides = loopedSlides;\n  const prependSlidesIndexes = [];\n  const appendSlidesIndexes = [];\n  let activeIndex = swiper.activeIndex;\n  if (typeof activeSlideIndex === \"undefined\") {\n    activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter((el) => el.classList.contains(params.slideActiveClass))[0]);\n  } else {\n    activeIndex = activeSlideIndex;\n  }\n  const isNext = direction === \"next\" || !direction;\n  const isPrev = direction === \"prev\" || !direction;\n  let slidesPrepended = 0;\n  let slidesAppended = 0;\n  if (activeSlideIndex < loopedSlides) {\n    slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n    for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n      const index = i - Math.floor(i / slides.length) * slides.length;\n      prependSlidesIndexes.push(slides.length - index - 1);\n    }\n  } else if (activeSlideIndex > swiper.slides.length - loopedSlides * 2) {\n    slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);\n    for (let i = 0; i < slidesAppended; i += 1) {\n      const index = i - Math.floor(i / slides.length) * slides.length;\n      appendSlidesIndexes.push(index);\n    }\n  }\n  if (isPrev) {\n    prependSlidesIndexes.forEach((index) => {\n      swiper.slides[index].swiperLoopMoveDOM = true;\n      slidesEl.prepend(swiper.slides[index]);\n      swiper.slides[index].swiperLoopMoveDOM = false;\n    });\n  }\n  if (isNext) {\n    appendSlidesIndexes.forEach((index) => {\n      swiper.slides[index].swiperLoopMoveDOM = true;\n      slidesEl.append(swiper.slides[index]);\n      swiper.slides[index].swiperLoopMoveDOM = false;\n    });\n  }\n  swiper.recalcSlides();\n  if (params.slidesPerView === \"auto\") {\n    swiper.updateSlides();\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  if (slideTo2) {\n    if (prependSlidesIndexes.length > 0 && isPrev) {\n      if (typeof slideRealIndex === \"undefined\") {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n          if (setTranslate2) {\n            swiper.touches[swiper.isHorizontal() ? \"startX\" : \"startY\"] += diff;\n          }\n        }\n      } else {\n        if (setTranslate2) {\n          swiper.slideToLoop(slideRealIndex, 0, false, true);\n        }\n      }\n    } else if (appendSlidesIndexes.length > 0 && isNext) {\n      if (typeof slideRealIndex === \"undefined\") {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n          if (setTranslate2) {\n            swiper.touches[swiper.isHorizontal() ? \"startX\" : \"startY\"] += diff;\n          }\n        }\n      } else {\n        swiper.slideToLoop(slideRealIndex, 0, false, true);\n      }\n    }\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.controller && swiper.controller.control && !byController) {\n    const loopParams = {\n      slideRealIndex,\n      slideTo: false,\n      direction,\n      setTranslate: setTranslate2,\n      activeSlideIndex,\n      byController: true\n    };\n    if (Array.isArray(swiper.controller.control)) {\n      swiper.controller.control.forEach((c) => {\n        if (!c.destroyed && c.params.loop)\n          c.loopFix(loopParams);\n      });\n    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n      swiper.controller.control.loopFix(loopParams);\n    }\n  }\n  swiper.emit(\"loopFix\");\n}\nfunction loopDestroy() {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)\n    return;\n  swiper.recalcSlides();\n  const newSlidesOrder = [];\n  swiper.slides.forEach((slideEl) => {\n    const index = typeof slideEl.swiperSlideIndex === \"undefined\" ? slideEl.getAttribute(\"data-swiper-slide-index\") * 1 : slideEl.swiperSlideIndex;\n    newSlidesOrder[index] = slideEl;\n  });\n  swiper.slides.forEach((slideEl) => {\n    slideEl.removeAttribute(\"data-swiper-slide-index\");\n  });\n  newSlidesOrder.forEach((slideEl) => {\n    slidesEl.append(slideEl);\n  });\n  swiper.recalcSlides();\n  swiper.slideTo(swiper.realIndex, 0);\n}\nconst loop = {\n  loopCreate,\n  loopFix,\n  loopDestroy\n};\nfunction setGrabCursor(moving) {\n  const swiper = this;\n  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)\n    return;\n  const el = swiper.params.touchEventsTarget === \"container\" ? swiper.el : swiper.wrapperEl;\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  el.style.cursor = \"move\";\n  el.style.cursor = moving ? \"grabbing\" : \"grab\";\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\nfunction unsetGrabCursor() {\n  const swiper = this;\n  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n    return;\n  }\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  swiper[swiper.params.touchEventsTarget === \"container\" ? \"el\" : \"wrapperEl\"].style.cursor = \"\";\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\nconst grabCursor = {\n  setGrabCursor,\n  unsetGrabCursor\n};\nfunction closestElement(selector, base = this) {\n  function __closestFrom(el) {\n    if (!el || el === getDocument() || el === getWindow())\n      return null;\n    if (el.assignedSlot)\n      el = el.assignedSlot;\n    const found = el.closest(selector);\n    if (!found && !el.getRootNode) {\n      return null;\n    }\n    return found || __closestFrom(el.getRootNode().host);\n  }\n  return __closestFrom(base);\n}\nfunction onTouchStart(event2) {\n  const swiper = this;\n  const document2 = getDocument();\n  const window2 = getWindow();\n  const data = swiper.touchEventsData;\n  data.evCache.push(event2);\n  const {\n    params,\n    touches,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return;\n  if (!params.simulateTouch && event2.pointerType === \"mouse\")\n    return;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n  if (!swiper.animating && params.cssMode && params.loop) {\n    swiper.loopFix();\n  }\n  let e = event2;\n  if (e.originalEvent)\n    e = e.originalEvent;\n  let targetEl = e.target;\n  if (params.touchEventsTarget === \"wrapper\") {\n    if (!swiper.wrapperEl.contains(targetEl))\n      return;\n  }\n  if (\"which\" in e && e.which === 3)\n    return;\n  if (\"button\" in e && e.button > 0)\n    return;\n  if (data.isTouched && data.isMoved)\n    return;\n  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== \"\";\n  const eventPath = event2.composedPath ? event2.composedPath() : event2.path;\n  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n    targetEl = eventPath[0];\n  }\n  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n  const isTargetShadow = !!(e.target && e.target.shadowRoot);\n  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n    swiper.allowClick = true;\n    return;\n  }\n  if (params.swipeHandler) {\n    if (!targetEl.closest(params.swipeHandler))\n      return;\n  }\n  touches.currentX = e.pageX;\n  touches.currentY = e.pageY;\n  const startX = touches.currentX;\n  const startY = touches.currentY;\n  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {\n    if (edgeSwipeDetection === \"prevent\") {\n      event2.preventDefault();\n    } else {\n      return;\n    }\n  }\n  Object.assign(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: void 0,\n    startMoving: void 0\n  });\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = now();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = void 0;\n  if (params.threshold > 0)\n    data.allowThresholdMove = false;\n  let preventDefault = true;\n  if (targetEl.matches(data.focusableElements)) {\n    preventDefault = false;\n    if (targetEl.nodeName === \"SELECT\") {\n      data.isTouched = false;\n    }\n  }\n  if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl) {\n    document2.activeElement.blur();\n  }\n  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n    e.preventDefault();\n  }\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n    swiper.freeMode.onTouchStart();\n  }\n  swiper.emit(\"touchStart\", e);\n}\nfunction onTouchMove(event2) {\n  const document2 = getDocument();\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return;\n  if (!params.simulateTouch && event2.pointerType === \"mouse\")\n    return;\n  let e = event2;\n  if (e.originalEvent)\n    e = e.originalEvent;\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit(\"touchMoveOpposite\", e);\n    }\n    return;\n  }\n  const pointerIndex = data.evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n  if (pointerIndex >= 0)\n    data.evCache[pointerIndex] = e;\n  const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n  const pageX = targetTouch.pageX;\n  const pageY = targetTouch.pageY;\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    if (!e.target.matches(data.focusableElements)) {\n      swiper.allowClick = false;\n    }\n    if (data.isTouched) {\n      Object.assign(touches, {\n        startX: pageX,\n        startY: pageY,\n        prevX: swiper.touches.currentX,\n        prevY: swiper.touches.currentY,\n        currentX: pageX,\n        currentY: pageY\n      });\n      data.touchStartTime = now();\n    }\n    return;\n  }\n  if (params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n      return;\n    }\n  }\n  if (document2.activeElement) {\n    if (e.target === document2.activeElement && e.target.matches(data.focusableElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit(\"touchMove\", e);\n  }\n  if (e.targetTouches && e.targetTouches.length > 1)\n    return;\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n  const diffX = touches.currentX - touches.startX;\n  const diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)\n    return;\n  if (typeof data.isScrolling === \"undefined\") {\n    let touchAngle;\n    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n      data.isScrolling = false;\n    } else {\n      if (diffX * diffX + diffY * diffY >= 25) {\n        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit(\"touchMoveOpposite\", e);\n  }\n  if (typeof data.startMoving === \"undefined\") {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  if (!params.cssMode && e.cancelable) {\n    e.preventDefault();\n  }\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n  let diff = swiper.isHorizontal() ? diffX : diffY;\n  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n  if (params.oneWayMovement) {\n    diff = Math.abs(diff) * (rtl ? 1 : -1);\n    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n  }\n  touches.diff = diff;\n  diff *= params.touchRatio;\n  if (rtl) {\n    diff = -diff;\n    touchesDiff = -touchesDiff;\n  }\n  const prevTouchesDirection = swiper.touchesDirection;\n  swiper.swipeDirection = diff > 0 ? \"prev\" : \"next\";\n  swiper.touchesDirection = touchesDiff > 0 ? \"prev\" : \"next\";\n  const isLoop = swiper.params.loop && !params.cssMode;\n  if (!data.isMoved) {\n    if (isLoop) {\n      swiper.loopFix({\n        direction: swiper.swipeDirection\n      });\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      const evt = new window.CustomEvent(\"transitionend\", {\n        bubbles: true,\n        cancelable: true\n      });\n      swiper.wrapperEl.dispatchEvent(evt);\n    }\n    data.allowMomentumBounce = false;\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit(\"sliderFirstMove\", e);\n  }\n  let loopFixed;\n  if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {\n    swiper.loopFix({\n      direction: swiper.swipeDirection,\n      setTranslate: true\n    });\n    loopFixed = true;\n  }\n  swiper.emit(\"sliderMove\", e);\n  data.isMoved = true;\n  data.currentTranslate = diff + data.startTranslate;\n  let disableParentSwiper = true;\n  let resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if (diff > 0) {\n    if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {\n      swiper.loopFix({\n        direction: \"prev\",\n        setTranslate: true,\n        activeSlideIndex: 0\n      });\n    }\n    if (data.currentTranslate > swiper.minTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n      }\n    }\n  } else if (diff < 0) {\n    if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {\n      swiper.loopFix({\n        direction: \"next\",\n        setTranslate: true,\n        activeSlideIndex: swiper.slides.length - (params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n      });\n    }\n    if (data.currentTranslate < swiper.maxTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n      }\n    }\n  }\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n  if (!swiper.allowSlideNext && swiper.swipeDirection === \"next\" && data.currentTranslate < data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && swiper.swipeDirection === \"prev\" && data.currentTranslate > data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n  if (!params.followFinger || params.cssMode)\n    return;\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n    swiper.freeMode.onTouchMove();\n  }\n  swiper.updateProgress(data.currentTranslate);\n  swiper.setTranslate(data.currentTranslate);\n}\nfunction onTouchEnd(event2) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const pointerIndex = data.evCache.findIndex((cachedEv) => cachedEv.pointerId === event2.pointerId);\n  if (pointerIndex >= 0) {\n    data.evCache.splice(pointerIndex, 1);\n  }\n  if ([\"pointercancel\", \"pointerout\", \"pointerleave\"].includes(event2.type)) {\n    const proceed = event2.type === \"pointercancel\" && (swiper.browser.isSafari || swiper.browser.isWebView);\n    if (!proceed) {\n      return;\n    }\n  }\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    slidesGrid,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return;\n  if (!params.simulateTouch && event2.pointerType === \"mouse\")\n    return;\n  let e = event2;\n  if (e.originalEvent)\n    e = e.originalEvent;\n  if (data.allowTouchCallbacks) {\n    swiper.emit(\"touchEnd\", e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  }\n  const touchEndTime = now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n  if (swiper.allowClick) {\n    const pathTree = e.path || e.composedPath && e.composedPath();\n    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n    swiper.emit(\"tap click\", e);\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit(\"doubleTap doubleClick\", e);\n    }\n  }\n  data.lastClickTime = now();\n  nextTick(() => {\n    if (!swiper.destroyed)\n      swiper.allowClick = true;\n  });\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n  if (params.cssMode) {\n    return;\n  }\n  if (params.freeMode && params.freeMode.enabled) {\n    swiper.freeMode.onTouchEnd({\n      currentPos\n    });\n    return;\n  }\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (typeof slidesGrid[i + increment2] !== \"undefined\") {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment2] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n  let rewindFirstIndex = null;\n  let rewindLastIndex = null;\n  if (params.rewind) {\n    if (swiper.isBeginning) {\n      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    } else if (swiper.isEnd) {\n      rewindFirstIndex = 0;\n    }\n  }\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n  if (timeDiff > params.longSwipesMs) {\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === \"next\") {\n      if (ratio >= params.longSwipesRatio)\n        swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n      else\n        swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === \"prev\") {\n      if (ratio > 1 - params.longSwipesRatio) {\n        swiper.slideTo(stopIndex + increment);\n      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n        swiper.slideTo(rewindLastIndex);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  } else {\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === \"next\") {\n        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n      }\n      if (swiper.swipeDirection === \"prev\") {\n        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\nfunction onResize() {\n  const swiper = this;\n  const {\n    params,\n    el\n  } = swiper;\n  if (el && el.offsetWidth === 0)\n    return;\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n  const {\n    allowSlideNext,\n    allowSlidePrev,\n    snapGrid\n  } = swiper;\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n  swiper.updateSize();\n  swiper.updateSlides();\n  swiper.updateSlidesClasses();\n  const isVirtualLoop = isVirtual && params.loop;\n  if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n    swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n  } else {\n    if (swiper.params.loop && !isVirtual) {\n      swiper.slideToLoop(swiper.realIndex, 0, false, true);\n    } else {\n      swiper.slideTo(swiper.activeIndex, 0, false, true);\n    }\n  }\n  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n    clearTimeout(swiper.autoplay.resizeTimeout);\n    swiper.autoplay.resizeTimeout = setTimeout(() => {\n      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        swiper.autoplay.resume();\n      }\n    }, 500);\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\nfunction onClick(e) {\n  const swiper = this;\n  if (!swiper.enabled)\n    return;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks)\n      e.preventDefault();\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\nfunction onScroll() {\n  const swiper = this;\n  const {\n    wrapperEl,\n    rtlTranslate,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return;\n  swiper.previousTranslate = swiper.translate;\n  if (swiper.isHorizontal()) {\n    swiper.translate = -wrapperEl.scrollLeft;\n  } else {\n    swiper.translate = -wrapperEl.scrollTop;\n  }\n  if (swiper.translate === 0)\n    swiper.translate = 0;\n  swiper.updateActiveIndex();\n  swiper.updateSlidesClasses();\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== swiper.progress) {\n    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n  }\n  swiper.emit(\"setTranslate\", swiper.translate, false);\n}\nfunction onLoad(e) {\n  const swiper = this;\n  processLazyPreloader(swiper, e.target);\n  if (swiper.params.cssMode || swiper.params.slidesPerView !== \"auto\" && !swiper.params.autoHeight) {\n    return;\n  }\n  swiper.update();\n}\nlet dummyEventAttached = false;\nfunction dummyEventListener() {\n}\nconst events = (swiper, method) => {\n  const document2 = getDocument();\n  const {\n    params,\n    el,\n    wrapperEl,\n    device\n  } = swiper;\n  const capture = !!params.nested;\n  const domMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n  const swiperMethod = method;\n  el[domMethod](\"pointerdown\", swiper.onTouchStart, {\n    passive: false\n  });\n  document2[domMethod](\"pointermove\", swiper.onTouchMove, {\n    passive: false,\n    capture\n  });\n  document2[domMethod](\"pointerup\", swiper.onTouchEnd, {\n    passive: true\n  });\n  document2[domMethod](\"pointercancel\", swiper.onTouchEnd, {\n    passive: true\n  });\n  document2[domMethod](\"pointerout\", swiper.onTouchEnd, {\n    passive: true\n  });\n  document2[domMethod](\"pointerleave\", swiper.onTouchEnd, {\n    passive: true\n  });\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el[domMethod](\"click\", swiper.onClick, true);\n  }\n  if (params.cssMode) {\n    wrapperEl[domMethod](\"scroll\", swiper.onScroll);\n  }\n  if (params.updateOnWindowResize) {\n    swiper[swiperMethod](device.ios || device.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", onResize, true);\n  } else {\n    swiper[swiperMethod](\"observerUpdate\", onResize, true);\n  }\n  el[domMethod](\"load\", swiper.onLoad, {\n    capture: true\n  });\n};\nfunction attachEvents() {\n  const swiper = this;\n  const document2 = getDocument();\n  const {\n    params\n  } = swiper;\n  swiper.onTouchStart = onTouchStart.bind(swiper);\n  swiper.onTouchMove = onTouchMove.bind(swiper);\n  swiper.onTouchEnd = onTouchEnd.bind(swiper);\n  if (params.cssMode) {\n    swiper.onScroll = onScroll.bind(swiper);\n  }\n  swiper.onClick = onClick.bind(swiper);\n  swiper.onLoad = onLoad.bind(swiper);\n  if (!dummyEventAttached) {\n    document2.addEventListener(\"touchstart\", dummyEventListener);\n    dummyEventAttached = true;\n  }\n  events(swiper, \"on\");\n}\nfunction detachEvents() {\n  const swiper = this;\n  events(swiper, \"off\");\n}\nconst events$1 = {\n  attachEvents,\n  detachEvents\n};\nconst isGridEnabled = (swiper, params) => {\n  return swiper.grid && params.grid && params.grid.rows > 1;\n};\nfunction setBreakpoint() {\n  const swiper = this;\n  const {\n    realIndex,\n    initialized,\n    params,\n    el\n  } = swiper;\n  const breakpoints2 = params.breakpoints;\n  if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)\n    return;\n  const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);\n  if (!breakpoint || swiper.currentBreakpoint === breakpoint)\n    return;\n  const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;\n  const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n  const wasMultiRow = isGridEnabled(swiper, params);\n  const isMultiRow = isGridEnabled(swiper, breakpointParams);\n  const wasEnabled = params.enabled;\n  if (wasMultiRow && !isMultiRow) {\n    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n    swiper.emitContainerClasses();\n  } else if (!wasMultiRow && isMultiRow) {\n    el.classList.add(`${params.containerModifierClass}grid`);\n    if (breakpointParams.grid.fill && breakpointParams.grid.fill === \"column\" || !breakpointParams.grid.fill && params.grid.fill === \"column\") {\n      el.classList.add(`${params.containerModifierClass}grid-column`);\n    }\n    swiper.emitContainerClasses();\n  }\n  [\"navigation\", \"pagination\", \"scrollbar\"].forEach((prop) => {\n    if (typeof breakpointParams[prop] === \"undefined\")\n      return;\n    const wasModuleEnabled = params[prop] && params[prop].enabled;\n    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n    if (wasModuleEnabled && !isModuleEnabled) {\n      swiper[prop].disable();\n    }\n    if (!wasModuleEnabled && isModuleEnabled) {\n      swiper[prop].enable();\n    }\n  });\n  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n  if (directionChanged && initialized) {\n    swiper.changeDirection();\n  }\n  extend(swiper.params, breakpointParams);\n  const isEnabled = swiper.params.enabled;\n  Object.assign(swiper, {\n    allowTouchMove: swiper.params.allowTouchMove,\n    allowSlideNext: swiper.params.allowSlideNext,\n    allowSlidePrev: swiper.params.allowSlidePrev\n  });\n  if (wasEnabled && !isEnabled) {\n    swiper.disable();\n  } else if (!wasEnabled && isEnabled) {\n    swiper.enable();\n  }\n  swiper.currentBreakpoint = breakpoint;\n  swiper.emit(\"_beforeBreakpoint\", breakpointParams);\n  if (needsReLoop && initialized) {\n    swiper.loopDestroy();\n    swiper.loopCreate(realIndex);\n    swiper.updateSlides();\n  }\n  swiper.emit(\"breakpoint\", breakpointParams);\n}\nfunction getBreakpoint(breakpoints2, base = \"window\", containerEl) {\n  if (!breakpoints2 || base === \"container\" && !containerEl)\n    return void 0;\n  let breakpoint = false;\n  const window2 = getWindow();\n  const currentHeight = base === \"window\" ? window2.innerHeight : containerEl.clientHeight;\n  const points = Object.keys(breakpoints2).map((point) => {\n    if (typeof point === \"string\" && point.indexOf(\"@\") === 0) {\n      const minRatio = parseFloat(point.substr(1));\n      const value = currentHeight * minRatio;\n      return {\n        value,\n        point\n      };\n    }\n    return {\n      value: point,\n      point\n    };\n  });\n  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n  for (let i = 0; i < points.length; i += 1) {\n    const {\n      point,\n      value\n    } = points[i];\n    if (base === \"window\") {\n      if (window2.matchMedia(`(min-width: ${value}px)`).matches) {\n        breakpoint = point;\n      }\n    } else if (value <= containerEl.clientWidth) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || \"max\";\n}\nconst breakpoints = {\n  setBreakpoint,\n  getBreakpoint\n};\nfunction prepareClasses(entries, prefix) {\n  const resultClasses = [];\n  entries.forEach((item) => {\n    if (typeof item === \"object\") {\n      Object.keys(item).forEach((classNames) => {\n        if (item[classNames]) {\n          resultClasses.push(prefix + classNames);\n        }\n      });\n    } else if (typeof item === \"string\") {\n      resultClasses.push(prefix + item);\n    }\n  });\n  return resultClasses;\n}\nfunction addClasses() {\n  const swiper = this;\n  const {\n    classNames,\n    params,\n    rtl,\n    el,\n    device\n  } = swiper;\n  const suffixes = prepareClasses([\"initialized\", params.direction, {\n    \"free-mode\": swiper.params.freeMode && params.freeMode.enabled\n  }, {\n    \"autoheight\": params.autoHeight\n  }, {\n    \"rtl\": rtl\n  }, {\n    \"grid\": params.grid && params.grid.rows > 1\n  }, {\n    \"grid-column\": params.grid && params.grid.rows > 1 && params.grid.fill === \"column\"\n  }, {\n    \"android\": device.android\n  }, {\n    \"ios\": device.ios\n  }, {\n    \"css-mode\": params.cssMode\n  }, {\n    \"centered\": params.cssMode && params.centeredSlides\n  }, {\n    \"watch-progress\": params.watchSlidesProgress\n  }], params.containerModifierClass);\n  classNames.push(...suffixes);\n  el.classList.add(...classNames);\n  swiper.emitContainerClasses();\n}\nfunction removeClasses() {\n  const swiper = this;\n  const {\n    el,\n    classNames\n  } = swiper;\n  el.classList.remove(...classNames);\n  swiper.emitContainerClasses();\n}\nconst classes = {\n  addClasses,\n  removeClasses\n};\nfunction checkOverflow() {\n  const swiper = this;\n  const {\n    isLocked: wasLocked,\n    params\n  } = swiper;\n  const {\n    slidesOffsetBefore\n  } = params;\n  if (slidesOffsetBefore) {\n    const lastSlideIndex = swiper.slides.length - 1;\n    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n    swiper.isLocked = swiper.size > lastSlideRightEdge;\n  } else {\n    swiper.isLocked = swiper.snapGrid.length === 1;\n  }\n  if (params.allowSlideNext === true) {\n    swiper.allowSlideNext = !swiper.isLocked;\n  }\n  if (params.allowSlidePrev === true) {\n    swiper.allowSlidePrev = !swiper.isLocked;\n  }\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n  }\n  if (wasLocked !== swiper.isLocked) {\n    swiper.emit(swiper.isLocked ? \"lock\" : \"unlock\");\n  }\n}\nconst checkOverflow$1 = {\n  checkOverflow\n};\nconst defaults = {\n  init: true,\n  direction: \"horizontal\",\n  oneWayMovement: false,\n  touchEventsTarget: \"wrapper\",\n  initialSlide: 0,\n  speed: 300,\n  cssMode: false,\n  updateOnWindowResize: true,\n  resizeObserver: true,\n  nested: false,\n  createElements: false,\n  enabled: true,\n  focusableElements: \"input, select, option, textarea, button, video, label\",\n  // Overrides\n  width: null,\n  height: null,\n  //\n  preventInteractionOnTransition: false,\n  // ssr\n  userAgent: null,\n  url: null,\n  // To support iOS's swipe-to-go-back gesture (when being used in-app).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n  // Autoheight\n  autoHeight: false,\n  // Set wrapper width\n  setWrapperSize: false,\n  // Virtual Translate\n  virtualTranslate: false,\n  // Effects\n  effect: \"slide\",\n  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n  // Breakpoints\n  breakpoints: void 0,\n  breakpointsBase: \"window\",\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerGroup: 1,\n  slidesPerGroupSkip: 0,\n  slidesPerGroupAuto: false,\n  centeredSlides: false,\n  centeredSlidesBounds: false,\n  slidesOffsetBefore: 0,\n  // in px\n  slidesOffsetAfter: 0,\n  // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: true,\n  // Round length\n  roundLengths: false,\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 5,\n  touchMoveStopPropagation: false,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n  // Progress\n  watchSlidesProgress: false,\n  // Cursor\n  grabCursor: false,\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n  // loop\n  loop: false,\n  loopedSlides: null,\n  loopPreventsSliding: true,\n  // rewind\n  rewind: false,\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null,\n  // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: \"swiper-no-swiping\",\n  noSwipingSelector: null,\n  // Passive Listeners\n  passiveListeners: true,\n  maxBackfaceHiddenSlides: 10,\n  // NS\n  containerModifierClass: \"swiper-\",\n  // NEW\n  slideClass: \"swiper-slide\",\n  slideActiveClass: \"swiper-slide-active\",\n  slideVisibleClass: \"swiper-slide-visible\",\n  slideNextClass: \"swiper-slide-next\",\n  slidePrevClass: \"swiper-slide-prev\",\n  wrapperClass: \"swiper-wrapper\",\n  lazyPreloaderClass: \"swiper-lazy-preloader\",\n  lazyPreloadPrevNext: 0,\n  // Callbacks\n  runCallbacksOnInit: true,\n  // Internals\n  _emitClasses: false\n};\nfunction moduleExtendParams(params, allModulesParams) {\n  return function extendParams(obj = {}) {\n    const moduleParamName = Object.keys(obj)[0];\n    const moduleParams = obj[moduleParamName];\n    if (typeof moduleParams !== \"object\" || moduleParams === null) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if ([\"navigation\", \"pagination\", \"scrollbar\"].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {\n      params[moduleParamName] = {\n        auto: true\n      };\n    }\n    if (!(moduleParamName in params && \"enabled\" in moduleParams)) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if (params[moduleParamName] === true) {\n      params[moduleParamName] = {\n        enabled: true\n      };\n    }\n    if (typeof params[moduleParamName] === \"object\" && !(\"enabled\" in params[moduleParamName])) {\n      params[moduleParamName].enabled = true;\n    }\n    if (!params[moduleParamName])\n      params[moduleParamName] = {\n        enabled: false\n      };\n    extend(allModulesParams, obj);\n  };\n}\nconst prototypes = {\n  eventsEmitter,\n  update,\n  translate,\n  transition,\n  slide,\n  loop,\n  grabCursor,\n  events: events$1,\n  breakpoints,\n  checkOverflow: checkOverflow$1,\n  classes\n};\nconst extendedDefaults = {};\nclass Swiper {\n  constructor(...args) {\n    let el;\n    let params;\n    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === \"Object\") {\n      params = args[0];\n    } else {\n      [el, params] = args;\n    }\n    if (!params)\n      params = {};\n    params = extend({}, params);\n    if (el && !params.el)\n      params.el = el;\n    const document2 = getDocument();\n    if (params.el && typeof params.el === \"string\" && document2.querySelectorAll(params.el).length > 1) {\n      const swipers = [];\n      document2.querySelectorAll(params.el).forEach((containerEl) => {\n        const newParams = extend({}, params, {\n          el: containerEl\n        });\n        swipers.push(new Swiper(newParams));\n      });\n      return swipers;\n    }\n    const swiper = this;\n    swiper.__swiper__ = true;\n    swiper.support = getSupport();\n    swiper.device = getDevice({\n      userAgent: params.userAgent\n    });\n    swiper.browser = getBrowser();\n    swiper.eventsListeners = {};\n    swiper.eventsAnyListeners = [];\n    swiper.modules = [...swiper.__modules__];\n    if (params.modules && Array.isArray(params.modules)) {\n      swiper.modules.push(...params.modules);\n    }\n    const allModulesParams = {};\n    swiper.modules.forEach((mod) => {\n      mod({\n        params,\n        swiper,\n        extendParams: moduleExtendParams(params, allModulesParams),\n        on: swiper.on.bind(swiper),\n        once: swiper.once.bind(swiper),\n        off: swiper.off.bind(swiper),\n        emit: swiper.emit.bind(swiper)\n      });\n    });\n    const swiperParams = extend({}, defaults, allModulesParams);\n    swiper.params = extend({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = extend({}, swiper.params);\n    swiper.passedParams = extend({}, params);\n    if (swiper.params && swiper.params.on) {\n      Object.keys(swiper.params.on).forEach((eventName) => {\n        swiper.on(eventName, swiper.params.on[eventName]);\n      });\n    }\n    if (swiper.params && swiper.params.onAny) {\n      swiper.onAny(swiper.params.onAny);\n    }\n    Object.assign(swiper, {\n      enabled: swiper.params.enabled,\n      el,\n      // Classes\n      classNames: [],\n      // Slides\n      slides: [],\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n      // isDirection\n      isHorizontal() {\n        return swiper.params.direction === \"horizontal\";\n      },\n      isVertical() {\n        return swiper.params.direction === \"vertical\";\n      },\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n      //\n      isBeginning: true,\n      isEnd: false,\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n      cssOverflowAdjustment() {\n        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n      },\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n      // Touch Events\n      touchEventsData: {\n        isTouched: void 0,\n        isMoved: void 0,\n        allowTouchCallbacks: void 0,\n        touchStartTime: void 0,\n        isScrolling: void 0,\n        currentTranslate: void 0,\n        startTranslate: void 0,\n        allowThresholdMove: void 0,\n        // Form elements to match\n        focusableElements: swiper.params.focusableElements,\n        // Last click time\n        lastClickTime: 0,\n        clickTimeout: void 0,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: void 0,\n        startMoving: void 0,\n        evCache: []\n      },\n      // Clicks\n      allowClick: true,\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0\n      },\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0\n    });\n    swiper.emit(\"_swiper\");\n    if (swiper.params.init) {\n      swiper.init();\n    }\n    return swiper;\n  }\n  getSlideIndex(slideEl) {\n    const {\n      slidesEl,\n      params\n    } = this;\n    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    const firstSlideIndex = elementIndex(slides[0]);\n    return elementIndex(slideEl) - firstSlideIndex;\n  }\n  getSlideIndexByData(index) {\n    return this.getSlideIndex(this.slides.filter((slideEl) => slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === index)[0]);\n  }\n  recalcSlides() {\n    const swiper = this;\n    const {\n      slidesEl,\n      params\n    } = swiper;\n    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n  }\n  enable() {\n    const swiper = this;\n    if (swiper.enabled)\n      return;\n    swiper.enabled = true;\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n    swiper.emit(\"enable\");\n  }\n  disable() {\n    const swiper = this;\n    if (!swiper.enabled)\n      return;\n    swiper.enabled = false;\n    if (swiper.params.grabCursor) {\n      swiper.unsetGrabCursor();\n    }\n    swiper.emit(\"disable\");\n  }\n  setProgress(progress, speed) {\n    const swiper = this;\n    progress = Math.min(Math.max(progress, 0), 1);\n    const min = swiper.minTranslate();\n    const max = swiper.maxTranslate();\n    const current = (max - min) * progress + min;\n    swiper.translateTo(current, typeof speed === \"undefined\" ? 0 : speed);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  emitContainerClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el)\n      return;\n    const cls = swiper.el.className.split(\" \").filter((className) => {\n      return className.indexOf(\"swiper\") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n    });\n    swiper.emit(\"_containerClasses\", cls.join(\" \"));\n  }\n  getSlideClasses(slideEl) {\n    const swiper = this;\n    if (swiper.destroyed)\n      return \"\";\n    return slideEl.className.split(\" \").filter((className) => {\n      return className.indexOf(\"swiper-slide\") === 0 || className.indexOf(swiper.params.slideClass) === 0;\n    }).join(\" \");\n  }\n  emitSlidesClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el)\n      return;\n    const updates = [];\n    swiper.slides.forEach((slideEl) => {\n      const classNames = swiper.getSlideClasses(slideEl);\n      updates.push({\n        slideEl,\n        classNames\n      });\n      swiper.emit(\"_slideClass\", slideEl, classNames);\n    });\n    swiper.emit(\"_slideClasses\", updates);\n  }\n  slidesPerViewDynamic(view = \"current\", exact = false) {\n    const swiper = this;\n    const {\n      params,\n      slides,\n      slidesGrid,\n      slidesSizesGrid,\n      size: swiperSize,\n      activeIndex\n    } = swiper;\n    let spv = 1;\n    if (params.centeredSlides) {\n      let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;\n      let breakLoop;\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize)\n            breakLoop = true;\n        }\n      }\n      for (let i = activeIndex - 1; i >= 0; i -= 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize)\n            breakLoop = true;\n        }\n      }\n    } else {\n      if (view === \"current\") {\n        for (let i = activeIndex + 1; i < slides.length; i += 1) {\n          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      } else {\n        for (let i = activeIndex - 1; i >= 0; i -= 1) {\n          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      }\n    }\n    return spv;\n  }\n  update() {\n    const swiper = this;\n    if (!swiper || swiper.destroyed)\n      return;\n    const {\n      snapGrid,\n      params\n    } = swiper;\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach((imageEl) => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      }\n    });\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n    function setTranslate2() {\n      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    let translated;\n    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n      setTranslate2();\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n        translated = swiper.slideTo(slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate2();\n      }\n    }\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n    swiper.emit(\"update\");\n  }\n  changeDirection(newDirection, needUpdate = true) {\n    const swiper = this;\n    const currentDirection = swiper.params.direction;\n    if (!newDirection) {\n      newDirection = currentDirection === \"horizontal\" ? \"vertical\" : \"horizontal\";\n    }\n    if (newDirection === currentDirection || newDirection !== \"horizontal\" && newDirection !== \"vertical\") {\n      return swiper;\n    }\n    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n    swiper.emitContainerClasses();\n    swiper.params.direction = newDirection;\n    swiper.slides.forEach((slideEl) => {\n      if (newDirection === \"vertical\") {\n        slideEl.style.width = \"\";\n      } else {\n        slideEl.style.height = \"\";\n      }\n    });\n    swiper.emit(\"changeDirection\");\n    if (needUpdate)\n      swiper.update();\n    return swiper;\n  }\n  changeLanguageDirection(direction) {\n    const swiper = this;\n    if (swiper.rtl && direction === \"rtl\" || !swiper.rtl && direction === \"ltr\")\n      return;\n    swiper.rtl = direction === \"rtl\";\n    swiper.rtlTranslate = swiper.params.direction === \"horizontal\" && swiper.rtl;\n    if (swiper.rtl) {\n      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = \"rtl\";\n    } else {\n      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = \"ltr\";\n    }\n    swiper.update();\n  }\n  mount(element) {\n    const swiper = this;\n    if (swiper.mounted)\n      return true;\n    let el = element || swiper.params.el;\n    if (typeof el === \"string\") {\n      el = document.querySelector(el);\n    }\n    if (!el) {\n      return false;\n    }\n    el.swiper = swiper;\n    if (el.shadowEl) {\n      swiper.isElement = true;\n    }\n    const getWrapperSelector = () => {\n      return `.${(swiper.params.wrapperClass || \"\").trim().split(\" \").join(\".\")}`;\n    };\n    const getWrapper = () => {\n      if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n        const res = el.shadowRoot.querySelector(getWrapperSelector());\n        return res;\n      }\n      return elementChildren(el, getWrapperSelector())[0];\n    };\n    let wrapperEl = getWrapper();\n    if (!wrapperEl && swiper.params.createElements) {\n      wrapperEl = createElement(\"div\", swiper.params.wrapperClass);\n      el.append(wrapperEl);\n      elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl) => {\n        wrapperEl.append(slideEl);\n      });\n    }\n    Object.assign(swiper, {\n      el,\n      wrapperEl,\n      slidesEl: swiper.isElement ? el : wrapperEl,\n      mounted: true,\n      // RTL\n      rtl: el.dir.toLowerCase() === \"rtl\" || elementStyle(el, \"direction\") === \"rtl\",\n      rtlTranslate: swiper.params.direction === \"horizontal\" && (el.dir.toLowerCase() === \"rtl\" || elementStyle(el, \"direction\") === \"rtl\"),\n      wrongRTL: elementStyle(wrapperEl, \"display\") === \"-webkit-box\"\n    });\n    return true;\n  }\n  init(el) {\n    const swiper = this;\n    if (swiper.initialized)\n      return swiper;\n    const mounted = swiper.mount(el);\n    if (mounted === false)\n      return swiper;\n    swiper.emit(\"beforeInit\");\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    swiper.addClasses();\n    swiper.updateSize();\n    swiper.updateSlides();\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    }\n    if (swiper.params.grabCursor && swiper.enabled) {\n      swiper.setGrabCursor();\n    }\n    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n    }\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    }\n    swiper.attachEvents();\n    [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach((imageEl) => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      } else {\n        imageEl.addEventListener(\"load\", (e) => {\n          processLazyPreloader(swiper, e.target);\n        });\n      }\n    });\n    preload(swiper);\n    swiper.initialized = true;\n    preload(swiper);\n    swiper.emit(\"init\");\n    swiper.emit(\"afterInit\");\n    return swiper;\n  }\n  destroy(deleteInstance = true, cleanStyles = true) {\n    const swiper = this;\n    const {\n      params,\n      el,\n      wrapperEl,\n      slides\n    } = swiper;\n    if (typeof swiper.params === \"undefined\" || swiper.destroyed) {\n      return null;\n    }\n    swiper.emit(\"beforeDestroy\");\n    swiper.initialized = false;\n    swiper.detachEvents();\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n    if (cleanStyles) {\n      swiper.removeClasses();\n      el.removeAttribute(\"style\");\n      wrapperEl.removeAttribute(\"style\");\n      if (slides && slides.length) {\n        slides.forEach((slideEl) => {\n          slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n          slideEl.removeAttribute(\"style\");\n          slideEl.removeAttribute(\"data-swiper-slide-index\");\n        });\n      }\n    }\n    swiper.emit(\"destroy\");\n    Object.keys(swiper.eventsListeners).forEach((eventName) => {\n      swiper.off(eventName);\n    });\n    if (deleteInstance !== false) {\n      swiper.el.swiper = null;\n      deleteProps(swiper);\n    }\n    swiper.destroyed = true;\n    return null;\n  }\n  static extendDefaults(newDefaults) {\n    extend(extendedDefaults, newDefaults);\n  }\n  static get extendedDefaults() {\n    return extendedDefaults;\n  }\n  static get defaults() {\n    return defaults;\n  }\n  static installModule(mod) {\n    if (!Swiper.prototype.__modules__)\n      Swiper.prototype.__modules__ = [];\n    const modules = Swiper.prototype.__modules__;\n    if (typeof mod === \"function\" && modules.indexOf(mod) < 0) {\n      modules.push(mod);\n    }\n  }\n  static use(module) {\n    if (Array.isArray(module)) {\n      module.forEach((m) => Swiper.installModule(m));\n      return Swiper;\n    }\n    Swiper.installModule(module);\n    return Swiper;\n  }\n}\nObject.keys(prototypes).forEach((prototypeGroup) => {\n  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n  });\n});\nSwiper.use([Resize, Observer]);\nfunction Virtual({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  extendParams({\n    virtual: {\n      enabled: false,\n      slides: [],\n      cache: true,\n      renderSlide: null,\n      renderExternal: null,\n      renderExternalUpdate: true,\n      addSlidesBefore: 0,\n      addSlidesAfter: 0\n    }\n  });\n  let cssModeTimeout;\n  const document2 = getDocument();\n  swiper.virtual = {\n    cache: {},\n    from: void 0,\n    to: void 0,\n    slides: [],\n    offset: 0,\n    slidesGrid: []\n  };\n  const tempDOM = document2.createElement(\"div\");\n  function renderSlide(slide2, index) {\n    const params = swiper.params.virtual;\n    if (params.cache && swiper.virtual.cache[index]) {\n      return swiper.virtual.cache[index];\n    }\n    let slideEl;\n    if (params.renderSlide) {\n      slideEl = params.renderSlide.call(swiper, slide2, index);\n      if (typeof slideEl === \"string\") {\n        tempDOM.innerHTML = slideEl;\n        slideEl = tempDOM.children[0];\n      }\n    } else if (swiper.isElement) {\n      slideEl = createElement(\"swiper-slide\");\n    } else {\n      slideEl = createElement(\"div\", swiper.params.slideClass);\n    }\n    slideEl.setAttribute(\"data-swiper-slide-index\", index);\n    if (!params.renderSlide) {\n      slideEl.innerHTML = slide2;\n    }\n    if (params.cache)\n      swiper.virtual.cache[index] = slideEl;\n    return slideEl;\n  }\n  function update2(force) {\n    const {\n      slidesPerView,\n      slidesPerGroup,\n      centeredSlides,\n      loop: isLoop\n    } = swiper.params;\n    const {\n      addSlidesBefore,\n      addSlidesAfter\n    } = swiper.params.virtual;\n    const {\n      from: previousFrom,\n      to: previousTo,\n      slides,\n      slidesGrid: previousSlidesGrid,\n      offset: previousOffset\n    } = swiper.virtual;\n    if (!swiper.params.cssMode) {\n      swiper.updateActiveIndex();\n    }\n    const activeIndex = swiper.activeIndex || 0;\n    let offsetProp;\n    if (swiper.rtlTranslate)\n      offsetProp = \"right\";\n    else\n      offsetProp = swiper.isHorizontal() ? \"left\" : \"top\";\n    let slidesAfter;\n    let slidesBefore;\n    if (centeredSlides) {\n      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n    } else {\n      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n      slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n    }\n    let from = activeIndex - slidesBefore;\n    let to = activeIndex + slidesAfter;\n    if (!isLoop) {\n      from = Math.max(from, 0);\n      to = Math.min(to, slides.length - 1);\n    }\n    let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n    if (isLoop && activeIndex >= slidesBefore) {\n      from -= slidesBefore;\n      if (!centeredSlides)\n        offset += swiper.slidesGrid[0];\n    } else if (isLoop && activeIndex < slidesBefore) {\n      from = -slidesBefore;\n      if (centeredSlides)\n        offset += swiper.slidesGrid[0];\n    }\n    Object.assign(swiper.virtual, {\n      from,\n      to,\n      offset,\n      slidesGrid: swiper.slidesGrid,\n      slidesBefore,\n      slidesAfter\n    });\n    function onRendered() {\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n      emit(\"virtualUpdate\");\n    }\n    if (previousFrom === from && previousTo === to && !force) {\n      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n        swiper.slides.forEach((slideEl) => {\n          slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n        });\n      }\n      swiper.updateProgress();\n      emit(\"virtualUpdate\");\n      return;\n    }\n    if (swiper.params.virtual.renderExternal) {\n      swiper.params.virtual.renderExternal.call(swiper, {\n        offset,\n        from,\n        to,\n        slides: function getSlides() {\n          const slidesToRender = [];\n          for (let i = from; i <= to; i += 1) {\n            slidesToRender.push(slides[i]);\n          }\n          return slidesToRender;\n        }()\n      });\n      if (swiper.params.virtual.renderExternalUpdate) {\n        onRendered();\n      } else {\n        emit(\"virtualUpdate\");\n      }\n      return;\n    }\n    const prependIndexes = [];\n    const appendIndexes = [];\n    const getSlideIndex = (index) => {\n      let slideIndex = index;\n      if (index < 0) {\n        slideIndex = slides.length + index;\n      } else if (slideIndex >= slides.length) {\n        slideIndex = slideIndex - slides.length;\n      }\n      return slideIndex;\n    };\n    if (force) {\n      swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`).forEach((slideEl) => {\n        slideEl.remove();\n      });\n    } else {\n      for (let i = previousFrom; i <= previousTo; i += 1) {\n        if (i < from || i > to) {\n          const slideIndex = getSlideIndex(i);\n          swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`).forEach((slideEl) => {\n            slideEl.remove();\n          });\n        }\n      }\n    }\n    const loopFrom = isLoop ? -slides.length : 0;\n    const loopTo = isLoop ? slides.length * 2 : slides.length;\n    for (let i = loopFrom; i < loopTo; i += 1) {\n      if (i >= from && i <= to) {\n        const slideIndex = getSlideIndex(i);\n        if (typeof previousTo === \"undefined\" || force) {\n          appendIndexes.push(slideIndex);\n        } else {\n          if (i > previousTo)\n            appendIndexes.push(slideIndex);\n          if (i < previousFrom)\n            prependIndexes.push(slideIndex);\n        }\n      }\n    }\n    appendIndexes.forEach((index) => {\n      swiper.slidesEl.append(renderSlide(slides[index], index));\n    });\n    if (isLoop) {\n      for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n        const index = prependIndexes[i];\n        swiper.slidesEl.prepend(renderSlide(slides[index], index));\n      }\n    } else {\n      prependIndexes.sort((a, b) => b - a);\n      prependIndexes.forEach((index) => {\n        swiper.slidesEl.prepend(renderSlide(slides[index], index));\n      });\n    }\n    elementChildren(swiper.slidesEl, \".swiper-slide, swiper-slide\").forEach((slideEl) => {\n      slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n    });\n    onRendered();\n  }\n  function appendSlide2(slides) {\n    if (typeof slides === \"object\" && \"length\" in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i])\n          swiper.virtual.slides.push(slides[i]);\n      }\n    } else {\n      swiper.virtual.slides.push(slides);\n    }\n    update2(true);\n  }\n  function prependSlide2(slides) {\n    const activeIndex = swiper.activeIndex;\n    let newActiveIndex = activeIndex + 1;\n    let numberOfNewSlides = 1;\n    if (Array.isArray(slides)) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i])\n          swiper.virtual.slides.unshift(slides[i]);\n      }\n      newActiveIndex = activeIndex + slides.length;\n      numberOfNewSlides = slides.length;\n    } else {\n      swiper.virtual.slides.unshift(slides);\n    }\n    if (swiper.params.virtual.cache) {\n      const cache = swiper.virtual.cache;\n      const newCache = {};\n      Object.keys(cache).forEach((cachedIndex) => {\n        const cachedEl = cache[cachedIndex];\n        const cachedElIndex = cachedEl.getAttribute(\"data-swiper-slide-index\");\n        if (cachedElIndex) {\n          cachedEl.setAttribute(\"data-swiper-slide-index\", parseInt(cachedElIndex, 10) + numberOfNewSlides);\n        }\n        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n      });\n      swiper.virtual.cache = newCache;\n    }\n    update2(true);\n    swiper.slideTo(newActiveIndex, 0);\n  }\n  function removeSlide2(slidesIndexes) {\n    if (typeof slidesIndexes === \"undefined\" || slidesIndexes === null)\n      return;\n    let activeIndex = swiper.activeIndex;\n    if (Array.isArray(slidesIndexes)) {\n      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n        swiper.virtual.slides.splice(slidesIndexes[i], 1);\n        if (swiper.params.virtual.cache) {\n          delete swiper.virtual.cache[slidesIndexes[i]];\n        }\n        if (slidesIndexes[i] < activeIndex)\n          activeIndex -= 1;\n        activeIndex = Math.max(activeIndex, 0);\n      }\n    } else {\n      swiper.virtual.slides.splice(slidesIndexes, 1);\n      if (swiper.params.virtual.cache) {\n        delete swiper.virtual.cache[slidesIndexes];\n      }\n      if (slidesIndexes < activeIndex)\n        activeIndex -= 1;\n      activeIndex = Math.max(activeIndex, 0);\n    }\n    update2(true);\n    swiper.slideTo(activeIndex, 0);\n  }\n  function removeAllSlides2() {\n    swiper.virtual.slides = [];\n    if (swiper.params.virtual.cache) {\n      swiper.virtual.cache = {};\n    }\n    update2(true);\n    swiper.slideTo(0, 0);\n  }\n  on(\"beforeInit\", () => {\n    if (!swiper.params.virtual.enabled)\n      return;\n    let domSlidesAssigned;\n    if (typeof swiper.passedParams.virtual.slides === \"undefined\") {\n      const slides = [...swiper.slidesEl.children].filter((el) => el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n      if (slides && slides.length) {\n        swiper.virtual.slides = [...slides];\n        domSlidesAssigned = true;\n        slides.forEach((slideEl, slideIndex) => {\n          slideEl.setAttribute(\"data-swiper-slide-index\", slideIndex);\n          swiper.virtual.cache[slideIndex] = slideEl;\n          slideEl.remove();\n        });\n      }\n    }\n    if (!domSlidesAssigned) {\n      swiper.virtual.slides = swiper.params.virtual.slides;\n    }\n    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n    swiper.params.watchSlidesProgress = true;\n    swiper.originalParams.watchSlidesProgress = true;\n    if (!swiper.params.initialSlide) {\n      update2();\n    }\n  });\n  on(\"setTranslate\", () => {\n    if (!swiper.params.virtual.enabled)\n      return;\n    if (swiper.params.cssMode && !swiper._immediateVirtual) {\n      clearTimeout(cssModeTimeout);\n      cssModeTimeout = setTimeout(() => {\n        update2();\n      }, 100);\n    } else {\n      update2();\n    }\n  });\n  on(\"init update resize\", () => {\n    if (!swiper.params.virtual.enabled)\n      return;\n    if (swiper.params.cssMode) {\n      setCSSProperty(swiper.wrapperEl, \"--swiper-virtual-size\", `${swiper.virtualSize}px`);\n    }\n  });\n  Object.assign(swiper.virtual, {\n    appendSlide: appendSlide2,\n    prependSlide: prependSlide2,\n    removeSlide: removeSlide2,\n    removeAllSlides: removeAllSlides2,\n    update: update2\n  });\n}\nfunction Keyboard({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const document2 = getDocument();\n  const window2 = getWindow();\n  swiper.keyboard = {\n    enabled: false\n  };\n  extendParams({\n    keyboard: {\n      enabled: false,\n      onlyInViewport: true,\n      pageUpDown: true\n    }\n  });\n  function handle(event2) {\n    if (!swiper.enabled)\n      return;\n    const {\n      rtlTranslate: rtl\n    } = swiper;\n    let e = event2;\n    if (e.originalEvent)\n      e = e.originalEvent;\n    const kc = e.keyCode || e.charCode;\n    const pageUpDown = swiper.params.keyboard.pageUpDown;\n    const isPageUp = pageUpDown && kc === 33;\n    const isPageDown = pageUpDown && kc === 34;\n    const isArrowLeft = kc === 37;\n    const isArrowRight = kc === 39;\n    const isArrowUp = kc === 38;\n    const isArrowDown = kc === 40;\n    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {\n      return false;\n    }\n    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n      return void 0;\n    }\n    if (document2.activeElement && document2.activeElement.nodeName && (document2.activeElement.nodeName.toLowerCase() === \"input\" || document2.activeElement.nodeName.toLowerCase() === \"textarea\")) {\n      return void 0;\n    }\n    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n      let inView = false;\n      if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {\n        return void 0;\n      }\n      const el = swiper.el;\n      const swiperWidth = el.clientWidth;\n      const swiperHeight = el.clientHeight;\n      const windowWidth = window2.innerWidth;\n      const windowHeight = window2.innerHeight;\n      const swiperOffset = elementOffset(el);\n      if (rtl)\n        swiperOffset.left -= el.scrollLeft;\n      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];\n      for (let i = 0; i < swiperCoord.length; i += 1) {\n        const point = swiperCoord[i];\n        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n          if (point[0] === 0 && point[1] === 0)\n            continue;\n          inView = true;\n        }\n      }\n      if (!inView)\n        return void 0;\n    }\n    if (swiper.isHorizontal()) {\n      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n      }\n      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl)\n        swiper.slideNext();\n      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl)\n        swiper.slidePrev();\n    } else {\n      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n      }\n      if (isPageDown || isArrowDown)\n        swiper.slideNext();\n      if (isPageUp || isArrowUp)\n        swiper.slidePrev();\n    }\n    emit(\"keyPress\", kc);\n    return void 0;\n  }\n  function enable() {\n    if (swiper.keyboard.enabled)\n      return;\n    document2.addEventListener(\"keydown\", handle);\n    swiper.keyboard.enabled = true;\n  }\n  function disable() {\n    if (!swiper.keyboard.enabled)\n      return;\n    document2.removeEventListener(\"keydown\", handle);\n    swiper.keyboard.enabled = false;\n  }\n  on(\"init\", () => {\n    if (swiper.params.keyboard.enabled) {\n      enable();\n    }\n  });\n  on(\"destroy\", () => {\n    if (swiper.keyboard.enabled) {\n      disable();\n    }\n  });\n  Object.assign(swiper.keyboard, {\n    enable,\n    disable\n  });\n}\nfunction Mousewheel({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const window2 = getWindow();\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: \"container\",\n      thresholdDelta: null,\n      thresholdTime: null,\n      noMousewheelClass: \"swiper-no-mousewheel\"\n    }\n  });\n  swiper.mousewheel = {\n    enabled: false\n  };\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n  function normalize(e) {\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0;\n    let sY = 0;\n    let pX = 0;\n    let pY = 0;\n    if (\"detail\" in e) {\n      sY = e.detail;\n    }\n    if (\"wheelDelta\" in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if (\"wheelDeltaY\" in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if (\"wheelDeltaX\" in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n    if (\"axis\" in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n    if (\"deltaY\" in e) {\n      pY = e.deltaY;\n    }\n    if (\"deltaX\" in e) {\n      pX = e.deltaX;\n    }\n    if (e.shiftKey && !pX) {\n      pX = pY;\n      pY = 0;\n    }\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled)\n      return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled)\n      return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n      return false;\n    }\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n      return false;\n    }\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      return true;\n    }\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit(\"scroll\", newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit(\"scroll\", newEvent.raw);\n    }\n    lastScrollTime = new window2.Date().getTime();\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      return true;\n    }\n    return false;\n  }\n  function handle(event2) {\n    let e = event2;\n    let disableParentSwiper = true;\n    if (!swiper.enabled)\n      return;\n    if (event2.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`))\n      return;\n    const params = swiper.params.mousewheel;\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== \"container\") {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges)\n      return true;\n    if (e.originalEvent)\n      e = e.originalEvent;\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    const data = normalize(e);\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY))\n          delta = -data.pixelX * rtlFactor;\n        else\n          return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX))\n        delta = -data.pixelY;\n      else\n        return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n    if (delta === 0)\n      return true;\n    if (params.invert)\n      delta = -delta;\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate())\n      positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate())\n      positions = swiper.maxTranslate();\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested)\n      e.stopPropagation();\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event2\n      };\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift();\n      }\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;\n      recentWheelEvents.push(newEvent);\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = void 0;\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate())\n          position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate())\n          position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? \"next\" : \"prev\",\n            byMousewheel: true\n          });\n        }\n        if (swiper.params.freeMode.sticky) {\n          clearTimeout(timeout);\n          timeout = void 0;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift();\n          }\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);\n            }, 0);\n          }\n          if (!timeout) {\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);\n            }, 500);\n          }\n        }\n        if (!ignoreWheelEvents)\n          emit(\"scroll\", e);\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction)\n          swiper.autoplay.stop();\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate())\n          return true;\n      }\n    }\n    if (e.preventDefault)\n      e.preventDefault();\n    else\n      e.returnValue = false;\n    return false;\n  }\n  function events2(method) {\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== \"container\") {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    targetEl[method](\"mouseenter\", handleMouseEnter);\n    targetEl[method](\"mouseleave\", handleMouseLeave);\n    targetEl[method](\"wheel\", handle);\n  }\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener(\"wheel\", handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled)\n      return false;\n    events2(\"addEventListener\");\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled)\n      return false;\n    events2(\"removeEventListener\");\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n  on(\"init\", () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled)\n      enable();\n  });\n  on(\"destroy\", () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled)\n      disable();\n  });\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable\n  });\n}\nfunction createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n  if (swiper.params.createElements) {\n    Object.keys(checkProps).forEach((key) => {\n      if (!params[key] && params.auto === true) {\n        let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n        if (!element) {\n          element = createElement(\"div\", checkProps[key]);\n          element.className = checkProps[key];\n          swiper.el.append(element);\n        }\n        params[key] = element;\n        originalParams[key] = element;\n      }\n    });\n  }\n  return params;\n}\nfunction Navigation({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  extendParams({\n    navigation: {\n      nextEl: null,\n      prevEl: null,\n      hideOnClick: false,\n      disabledClass: \"swiper-button-disabled\",\n      hiddenClass: \"swiper-button-hidden\",\n      lockClass: \"swiper-button-lock\",\n      navigationDisabledClass: \"swiper-navigation-disabled\"\n    }\n  });\n  swiper.navigation = {\n    nextEl: null,\n    prevEl: null\n  };\n  const makeElementsArray = (el) => {\n    if (!Array.isArray(el))\n      el = [el].filter((e) => !!e);\n    return el;\n  };\n  function getEl(el) {\n    let res;\n    if (el && typeof el === \"string\" && swiper.isElement) {\n      res = swiper.el.shadowRoot.querySelector(el);\n      if (res)\n        return res;\n    }\n    if (el) {\n      if (typeof el === \"string\")\n        res = [...document.querySelectorAll(el)];\n      if (swiper.params.uniqueNavElements && typeof el === \"string\" && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {\n        res = swiper.el.querySelector(el);\n      }\n    }\n    if (el && !res)\n      return el;\n    return res;\n  }\n  function toggleEl(el, disabled) {\n    const params = swiper.params.navigation;\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      if (subEl) {\n        subEl.classList[disabled ? \"add\" : \"remove\"](...params.disabledClass.split(\" \"));\n        if (subEl.tagName === \"BUTTON\")\n          subEl.disabled = disabled;\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](params.lockClass);\n        }\n      }\n    });\n  }\n  function update2() {\n    const {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    if (swiper.params.loop) {\n      toggleEl(prevEl, false);\n      toggleEl(nextEl, false);\n      return;\n    }\n    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n  }\n  function onPrevClick(e) {\n    e.preventDefault();\n    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind)\n      return;\n    swiper.slidePrev();\n    emit(\"navigationPrev\");\n  }\n  function onNextClick(e) {\n    e.preventDefault();\n    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind)\n      return;\n    swiper.slideNext();\n    emit(\"navigationNext\");\n  }\n  function init() {\n    const params = swiper.params.navigation;\n    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n      nextEl: \"swiper-button-next\",\n      prevEl: \"swiper-button-prev\"\n    });\n    if (!(params.nextEl || params.prevEl))\n      return;\n    let nextEl = getEl(params.nextEl);\n    let prevEl = getEl(params.prevEl);\n    Object.assign(swiper.navigation, {\n      nextEl,\n      prevEl\n    });\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const initButton = (el, dir) => {\n      if (el) {\n        el.addEventListener(\"click\", dir === \"next\" ? onNextClick : onPrevClick);\n      }\n      if (!swiper.enabled && el) {\n        el.classList.add(...params.lockClass.split(\" \"));\n      }\n    };\n    nextEl.forEach((el) => initButton(el, \"next\"));\n    prevEl.forEach((el) => initButton(el, \"prev\"));\n  }\n  function destroy() {\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const destroyButton = (el, dir) => {\n      el.removeEventListener(\"click\", dir === \"next\" ? onNextClick : onPrevClick);\n      el.classList.remove(...swiper.params.navigation.disabledClass.split(\" \"));\n    };\n    nextEl.forEach((el) => destroyButton(el, \"next\"));\n    prevEl.forEach((el) => destroyButton(el, \"prev\"));\n  }\n  on(\"init\", () => {\n    if (swiper.params.navigation.enabled === false) {\n      disable();\n    } else {\n      init();\n      update2();\n    }\n  });\n  on(\"toEdge fromEdge lock unlock\", () => {\n    update2();\n  });\n  on(\"destroy\", () => {\n    destroy();\n  });\n  on(\"enable disable\", () => {\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.navigation.lockClass));\n  });\n  on(\"click\", (_s, e) => {\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const targetEl = e.target;\n    if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {\n      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl)))\n        return;\n      let isHidden;\n      if (nextEl.length) {\n        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n      } else if (prevEl.length) {\n        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n      }\n      if (isHidden === true) {\n        emit(\"navigationShow\");\n      } else {\n        emit(\"navigationHide\");\n      }\n      [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.toggle(swiper.params.navigation.hiddenClass));\n    }\n  });\n  const enable = () => {\n    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(\" \"));\n    init();\n    update2();\n  };\n  const disable = () => {\n    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(\" \"));\n    destroy();\n  };\n  Object.assign(swiper.navigation, {\n    enable,\n    disable,\n    update: update2,\n    init,\n    destroy\n  });\n}\nfunction classesToSelector(classes2 = \"\") {\n  return `.${classes2.trim().replace(/([\\.:!+\\/])/g, \"\\\\$1\").replace(/ /g, \".\")}`;\n}\nfunction Pagination({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const pfx = \"swiper-pagination\";\n  extendParams({\n    pagination: {\n      el: null,\n      bulletElement: \"span\",\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: \"bullets\",\n      // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: (number) => number,\n      formatFractionTotal: (number) => number,\n      bulletClass: `${pfx}-bullet`,\n      bulletActiveClass: `${pfx}-bullet-active`,\n      modifierClass: `${pfx}-`,\n      currentClass: `${pfx}-current`,\n      totalClass: `${pfx}-total`,\n      hiddenClass: `${pfx}-hidden`,\n      progressbarFillClass: `${pfx}-progressbar-fill`,\n      progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n      clickableClass: `${pfx}-clickable`,\n      lockClass: `${pfx}-lock`,\n      horizontalClass: `${pfx}-horizontal`,\n      verticalClass: `${pfx}-vertical`,\n      paginationDisabledClass: `${pfx}-disabled`\n    }\n  });\n  swiper.pagination = {\n    el: null,\n    bullets: []\n  };\n  let bulletSize;\n  let dynamicBulletIndex = 0;\n  const makeElementsArray = (el) => {\n    if (!Array.isArray(el))\n      el = [el].filter((e) => !!e);\n    return el;\n  };\n  function isPaginationDisabled() {\n    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n  }\n  function setSideBullets(bulletEl, position) {\n    const {\n      bulletActiveClass\n    } = swiper.params.pagination;\n    if (!bulletEl)\n      return;\n    bulletEl = bulletEl[`${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`];\n    if (bulletEl) {\n      bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n      bulletEl = bulletEl[`${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`];\n      if (bulletEl) {\n        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n      }\n    }\n  }\n  function onBulletClick(e) {\n    const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n    if (!bulletEl) {\n      return;\n    }\n    e.preventDefault();\n    const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n    if (swiper.params.loop) {\n      if (swiper.realIndex === index)\n        return;\n      const newSlideIndex = swiper.getSlideIndexByData(index);\n      const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);\n      if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {\n        swiper.loopFix({\n          direction: newSlideIndex > currentSlideIndex ? \"next\" : \"prev\",\n          activeSlideIndex: newSlideIndex,\n          slideTo: false\n        });\n      }\n      swiper.slideToLoop(index);\n    } else {\n      swiper.slideTo(index);\n    }\n  }\n  function update2() {\n    const rtl = swiper.rtl;\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled())\n      return;\n    let el = swiper.pagination.el;\n    el = makeElementsArray(el);\n    let current;\n    let previousIndex;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n    if (swiper.params.loop) {\n      previousIndex = swiper.previousRealIndex || 0;\n      current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n    } else if (typeof swiper.snapIndex !== \"undefined\") {\n      current = swiper.snapIndex;\n      previousIndex = swiper.previousSnapIndex;\n    } else {\n      previousIndex = swiper.previousIndex || 0;\n      current = swiper.activeIndex || 0;\n    }\n    if (params.type === \"bullets\" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n      const bullets = swiper.pagination.bullets;\n      let firstIndex;\n      let lastIndex;\n      let midIndex;\n      if (params.dynamicBullets) {\n        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? \"width\" : \"height\", true);\n        el.forEach((subEl) => {\n          subEl.style[swiper.isHorizontal() ? \"width\" : \"height\"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n        });\n        if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {\n          dynamicBulletIndex += current - (previousIndex || 0);\n          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n            dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (dynamicBulletIndex < 0) {\n            dynamicBulletIndex = 0;\n          }\n        }\n        firstIndex = Math.max(current - dynamicBulletIndex, 0);\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n      bullets.forEach((bulletEl) => {\n        const classesToRemove = [...[\"\", \"-next\", \"-next-next\", \"-prev\", \"-prev-prev\", \"-main\"].map((suffix) => `${params.bulletActiveClass}${suffix}`)].map((s) => typeof s === \"string\" && s.includes(\" \") ? s.split(\" \") : s).flat();\n        bulletEl.classList.remove(...classesToRemove);\n      });\n      if (el.length > 1) {\n        bullets.forEach((bullet) => {\n          const bulletIndex = elementIndex(bullet);\n          if (bulletIndex === current) {\n            bullet.classList.add(...params.bulletActiveClass.split(\" \"));\n          } else if (swiper.isElement) {\n            bullet.setAttribute(\"part\", \"bullet\");\n          }\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(\" \"));\n            }\n            if (bulletIndex === firstIndex) {\n              setSideBullets(bullet, \"prev\");\n            }\n            if (bulletIndex === lastIndex) {\n              setSideBullets(bullet, \"next\");\n            }\n          }\n        });\n      } else {\n        const bullet = bullets[current];\n        if (bullet) {\n          bullet.classList.add(...params.bulletActiveClass.split(\" \"));\n        }\n        if (swiper.isElement) {\n          bullets.forEach((bulletEl, bulletIndex) => {\n            bulletEl.setAttribute(\"part\", bulletIndex === current ? \"bullet-active\" : \"bullet\");\n          });\n        }\n        if (params.dynamicBullets) {\n          const firstDisplayedBullet = bullets[firstIndex];\n          const lastDisplayedBullet = bullets[lastIndex];\n          for (let i = firstIndex; i <= lastIndex; i += 1) {\n            if (bullets[i]) {\n              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(\" \"));\n            }\n          }\n          setSideBullets(firstDisplayedBullet, \"prev\");\n          setSideBullets(lastDisplayedBullet, \"next\");\n        }\n      }\n      if (params.dynamicBullets) {\n        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n        const offsetProp = rtl ? \"right\" : \"left\";\n        bullets.forEach((bullet) => {\n          bullet.style[swiper.isHorizontal() ? offsetProp : \"top\"] = `${bulletsOffset}px`;\n        });\n      }\n    }\n    el.forEach((subEl, subElIndex) => {\n      if (params.type === \"fraction\") {\n        subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl) => {\n          fractionEl.textContent = params.formatFractionCurrent(current + 1);\n        });\n        subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl) => {\n          totalEl.textContent = params.formatFractionTotal(total);\n        });\n      }\n      if (params.type === \"progressbar\") {\n        let progressbarDirection;\n        if (params.progressbarOpposite) {\n          progressbarDirection = swiper.isHorizontal() ? \"vertical\" : \"horizontal\";\n        } else {\n          progressbarDirection = swiper.isHorizontal() ? \"horizontal\" : \"vertical\";\n        }\n        const scale = (current + 1) / total;\n        let scaleX = 1;\n        let scaleY = 1;\n        if (progressbarDirection === \"horizontal\") {\n          scaleX = scale;\n        } else {\n          scaleY = scale;\n        }\n        subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl) => {\n          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n          progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n        });\n      }\n      if (params.type === \"custom\" && params.renderCustom) {\n        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n        if (subElIndex === 0)\n          emit(\"paginationRender\", subEl);\n      } else {\n        if (subElIndex === 0)\n          emit(\"paginationRender\", subEl);\n        emit(\"paginationUpdate\", subEl);\n      }\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](params.lockClass);\n      }\n    });\n  }\n  function render() {\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled())\n      return;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    let el = swiper.pagination.el;\n    el = makeElementsArray(el);\n    let paginationHTML = \"\";\n    if (params.type === \"bullets\") {\n      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {\n        numberOfBullets = slidesLength;\n      }\n      for (let i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : \"\"} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n        }\n      }\n    }\n    if (params.type === \"fraction\") {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML = `<span class=\"${params.currentClass}\"></span> / <span class=\"${params.totalClass}\"></span>`;\n      }\n    }\n    if (params.type === \"progressbar\") {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n      }\n    }\n    swiper.pagination.bullets = [];\n    el.forEach((subEl) => {\n      if (params.type !== \"custom\") {\n        subEl.innerHTML = paginationHTML || \"\";\n      }\n      if (params.type === \"bullets\") {\n        swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n      }\n    });\n    if (params.type !== \"custom\") {\n      emit(\"paginationRender\", el[0]);\n    }\n  }\n  function init() {\n    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n      el: \"swiper-pagination\"\n    });\n    const params = swiper.params.pagination;\n    if (!params.el)\n      return;\n    let el;\n    if (typeof params.el === \"string\" && swiper.isElement) {\n      el = swiper.el.shadowRoot.querySelector(params.el);\n    }\n    if (!el && typeof params.el === \"string\") {\n      el = [...document.querySelectorAll(params.el)];\n    }\n    if (!el) {\n      el = params.el;\n    }\n    if (!el || el.length === 0)\n      return;\n    if (swiper.params.uniqueNavElements && typeof params.el === \"string\" && Array.isArray(el) && el.length > 1) {\n      el = [...swiper.el.querySelectorAll(params.el)];\n      if (el.length > 1) {\n        el = el.filter((subEl) => {\n          if (elementParents(subEl, \".swiper\")[0] !== swiper.el)\n            return false;\n          return true;\n        })[0];\n      }\n    }\n    if (Array.isArray(el) && el.length === 1)\n      el = el[0];\n    Object.assign(swiper.pagination, {\n      el\n    });\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      if (params.type === \"bullets\" && params.clickable) {\n        subEl.classList.add(params.clickableClass);\n      }\n      subEl.classList.add(params.modifierClass + params.type);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      if (params.type === \"bullets\" && params.dynamicBullets) {\n        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n        dynamicBulletIndex = 0;\n        if (params.dynamicMainBullets < 1) {\n          params.dynamicMainBullets = 1;\n        }\n      }\n      if (params.type === \"progressbar\" && params.progressbarOpposite) {\n        subEl.classList.add(params.progressbarOppositeClass);\n      }\n      if (params.clickable) {\n        subEl.addEventListener(\"click\", onBulletClick);\n      }\n      if (!swiper.enabled) {\n        subEl.classList.add(params.lockClass);\n      }\n    });\n  }\n  function destroy() {\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled())\n      return;\n    let el = swiper.pagination.el;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) => {\n        subEl.classList.remove(params.hiddenClass);\n        subEl.classList.remove(params.modifierClass + params.type);\n        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        if (params.clickable) {\n          subEl.removeEventListener(\"click\", onBulletClick);\n        }\n      });\n    }\n    if (swiper.pagination.bullets)\n      swiper.pagination.bullets.forEach((subEl) => subEl.classList.remove(...params.bulletActiveClass.split(\" \")));\n  }\n  on(\"changeDirection\", () => {\n    if (!swiper.pagination || !swiper.pagination.el)\n      return;\n    const params = swiper.params.pagination;\n    let {\n      el\n    } = swiper.pagination;\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.classList.remove(params.horizontalClass, params.verticalClass);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    });\n  });\n  on(\"init\", () => {\n    if (swiper.params.pagination.enabled === false) {\n      disable();\n    } else {\n      init();\n      render();\n      update2();\n    }\n  });\n  on(\"activeIndexChange\", () => {\n    if (typeof swiper.snapIndex === \"undefined\") {\n      update2();\n    }\n  });\n  on(\"snapIndexChange\", () => {\n    update2();\n  });\n  on(\"snapGridLengthChange\", () => {\n    render();\n    update2();\n  });\n  on(\"destroy\", () => {\n    destroy();\n  });\n  on(\"enable disable\", () => {\n    let {\n      el\n    } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) => subEl.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.pagination.lockClass));\n    }\n  });\n  on(\"lock unlock\", () => {\n    update2();\n  });\n  on(\"click\", (_s, e) => {\n    const targetEl = e.target;\n    let {\n      el\n    } = swiper.pagination;\n    if (!Array.isArray(el))\n      el = [el].filter((element) => !!element);\n    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))\n        return;\n      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n      if (isHidden === true) {\n        emit(\"paginationShow\");\n      } else {\n        emit(\"paginationHide\");\n      }\n      el.forEach((subEl) => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n    }\n  });\n  const enable = () => {\n    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n    let {\n      el\n    } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n    }\n    init();\n    render();\n    update2();\n  };\n  const disable = () => {\n    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n    let {\n      el\n    } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach((subEl) => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n    }\n    destroy();\n  };\n  Object.assign(swiper.pagination, {\n    enable,\n    disable,\n    render,\n    update: update2,\n    init,\n    destroy\n  });\n}\nfunction Scrollbar({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const document2 = getDocument();\n  let isTouched = false;\n  let timeout = null;\n  let dragTimeout = null;\n  let dragStartPos;\n  let dragSize;\n  let trackSize;\n  let divider;\n  extendParams({\n    scrollbar: {\n      el: null,\n      dragSize: \"auto\",\n      hide: false,\n      draggable: false,\n      snapOnRelease: true,\n      lockClass: \"swiper-scrollbar-lock\",\n      dragClass: \"swiper-scrollbar-drag\",\n      scrollbarDisabledClass: \"swiper-scrollbar-disabled\",\n      horizontalClass: `swiper-scrollbar-horizontal`,\n      verticalClass: `swiper-scrollbar-vertical`\n    }\n  });\n  swiper.scrollbar = {\n    el: null,\n    dragEl: null\n  };\n  function setTranslate2() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)\n      return;\n    const {\n      scrollbar,\n      rtlTranslate: rtl\n    } = swiper;\n    const {\n      dragEl,\n      el\n    } = scrollbar;\n    const params = swiper.params.scrollbar;\n    const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n    let newSize = dragSize;\n    let newPos = (trackSize - dragSize) * progress;\n    if (rtl) {\n      newPos = -newPos;\n      if (newPos > 0) {\n        newSize = dragSize - newPos;\n        newPos = 0;\n      } else if (-newPos + dragSize > trackSize) {\n        newSize = trackSize + newPos;\n      }\n    } else if (newPos < 0) {\n      newSize = dragSize + newPos;\n      newPos = 0;\n    } else if (newPos + dragSize > trackSize) {\n      newSize = trackSize - newPos;\n    }\n    if (swiper.isHorizontal()) {\n      dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n      dragEl.style.width = `${newSize}px`;\n    } else {\n      dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n      dragEl.style.height = `${newSize}px`;\n    }\n    if (params.hide) {\n      clearTimeout(timeout);\n      el.style.opacity = 1;\n      timeout = setTimeout(() => {\n        el.style.opacity = 0;\n        el.style.transitionDuration = \"400ms\";\n      }, 1e3);\n    }\n  }\n  function setTransition2(duration) {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)\n      return;\n    swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n  }\n  function updateSize2() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)\n      return;\n    const {\n      scrollbar\n    } = swiper;\n    const {\n      dragEl,\n      el\n    } = scrollbar;\n    dragEl.style.width = \"\";\n    dragEl.style.height = \"\";\n    trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n    if (swiper.params.scrollbar.dragSize === \"auto\") {\n      dragSize = trackSize * divider;\n    } else {\n      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n    }\n    if (swiper.isHorizontal()) {\n      dragEl.style.width = `${dragSize}px`;\n    } else {\n      dragEl.style.height = `${dragSize}px`;\n    }\n    if (divider >= 1) {\n      el.style.display = \"none\";\n    } else {\n      el.style.display = \"\";\n    }\n    if (swiper.params.scrollbar.hide) {\n      el.style.opacity = 0;\n    }\n    if (swiper.params.watchOverflow && swiper.enabled) {\n      scrollbar.el.classList[swiper.isLocked ? \"add\" : \"remove\"](swiper.params.scrollbar.lockClass);\n    }\n  }\n  function getPointerPosition(e) {\n    return swiper.isHorizontal() ? e.clientX : e.clientY;\n  }\n  function setDragPosition(e) {\n    const {\n      scrollbar,\n      rtlTranslate: rtl\n    } = swiper;\n    const {\n      el\n    } = scrollbar;\n    let positionRatio;\n    positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? \"left\" : \"top\"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n    positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n    if (rtl) {\n      positionRatio = 1 - positionRatio;\n    }\n    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n    swiper.updateProgress(position);\n    swiper.setTranslate(position);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  function onDragStart(e) {\n    const params = swiper.params.scrollbar;\n    const {\n      scrollbar,\n      wrapperEl\n    } = swiper;\n    const {\n      el,\n      dragEl\n    } = scrollbar;\n    isTouched = true;\n    dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? \"left\" : \"top\"] : null;\n    e.preventDefault();\n    e.stopPropagation();\n    wrapperEl.style.transitionDuration = \"100ms\";\n    dragEl.style.transitionDuration = \"100ms\";\n    setDragPosition(e);\n    clearTimeout(dragTimeout);\n    el.style.transitionDuration = \"0ms\";\n    if (params.hide) {\n      el.style.opacity = 1;\n    }\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style[\"scroll-snap-type\"] = \"none\";\n    }\n    emit(\"scrollbarDragStart\", e);\n  }\n  function onDragMove(e) {\n    const {\n      scrollbar,\n      wrapperEl\n    } = swiper;\n    const {\n      el,\n      dragEl\n    } = scrollbar;\n    if (!isTouched)\n      return;\n    if (e.preventDefault)\n      e.preventDefault();\n    else\n      e.returnValue = false;\n    setDragPosition(e);\n    wrapperEl.style.transitionDuration = \"0ms\";\n    el.style.transitionDuration = \"0ms\";\n    dragEl.style.transitionDuration = \"0ms\";\n    emit(\"scrollbarDragMove\", e);\n  }\n  function onDragEnd(e) {\n    const params = swiper.params.scrollbar;\n    const {\n      scrollbar,\n      wrapperEl\n    } = swiper;\n    const {\n      el\n    } = scrollbar;\n    if (!isTouched)\n      return;\n    isTouched = false;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style[\"scroll-snap-type\"] = \"\";\n      wrapperEl.style.transitionDuration = \"\";\n    }\n    if (params.hide) {\n      clearTimeout(dragTimeout);\n      dragTimeout = nextTick(() => {\n        el.style.opacity = 0;\n        el.style.transitionDuration = \"400ms\";\n      }, 1e3);\n    }\n    emit(\"scrollbarDragEnd\", e);\n    if (params.snapOnRelease) {\n      swiper.slideToClosest();\n    }\n  }\n  function events2(method) {\n    const {\n      scrollbar,\n      params\n    } = swiper;\n    const el = scrollbar.el;\n    if (!el)\n      return;\n    const target = el;\n    const activeListener = params.passiveListeners ? {\n      passive: false,\n      capture: false\n    } : false;\n    const passiveListener = params.passiveListeners ? {\n      passive: true,\n      capture: false\n    } : false;\n    if (!target)\n      return;\n    const eventMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n    target[eventMethod](\"pointerdown\", onDragStart, activeListener);\n    document2[eventMethod](\"pointermove\", onDragMove, activeListener);\n    document2[eventMethod](\"pointerup\", onDragEnd, passiveListener);\n  }\n  function enableDraggable() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)\n      return;\n    events2(\"on\");\n  }\n  function disableDraggable() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)\n      return;\n    events2(\"off\");\n  }\n  function init() {\n    const {\n      scrollbar,\n      el: swiperEl\n    } = swiper;\n    swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n      el: \"swiper-scrollbar\"\n    });\n    const params = swiper.params.scrollbar;\n    if (!params.el)\n      return;\n    let el;\n    if (typeof params.el === \"string\" && swiper.isElement) {\n      el = swiper.el.shadowRoot.querySelector(params.el);\n    }\n    if (!el && typeof params.el === \"string\") {\n      el = document2.querySelectorAll(params.el);\n    } else if (!el) {\n      el = params.el;\n    }\n    if (swiper.params.uniqueNavElements && typeof params.el === \"string\" && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {\n      el = swiperEl.querySelector(params.el);\n    }\n    if (el.length > 0)\n      el = el[0];\n    el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    let dragEl;\n    if (el) {\n      dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n      if (!dragEl) {\n        dragEl = createElement(\"div\", swiper.params.scrollbar.dragClass);\n        el.append(dragEl);\n      }\n    }\n    Object.assign(scrollbar, {\n      el,\n      dragEl\n    });\n    if (params.draggable) {\n      enableDraggable();\n    }\n    if (el) {\n      el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.scrollbar.lockClass);\n    }\n  }\n  function destroy() {\n    const params = swiper.params.scrollbar;\n    const el = swiper.scrollbar.el;\n    if (el) {\n      el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    }\n    disableDraggable();\n  }\n  on(\"init\", () => {\n    if (swiper.params.scrollbar.enabled === false) {\n      disable();\n    } else {\n      init();\n      updateSize2();\n      setTranslate2();\n    }\n  });\n  on(\"update resize observerUpdate lock unlock\", () => {\n    updateSize2();\n  });\n  on(\"setTranslate\", () => {\n    setTranslate2();\n  });\n  on(\"setTransition\", (_s, duration) => {\n    setTransition2(duration);\n  });\n  on(\"enable disable\", () => {\n    const {\n      el\n    } = swiper.scrollbar;\n    if (el) {\n      el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.scrollbar.lockClass);\n    }\n  });\n  on(\"destroy\", () => {\n    destroy();\n  });\n  const enable = () => {\n    swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n    if (swiper.scrollbar.el) {\n      swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n    }\n    init();\n    updateSize2();\n    setTranslate2();\n  };\n  const disable = () => {\n    swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n    if (swiper.scrollbar.el) {\n      swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n    }\n    destroy();\n  };\n  Object.assign(swiper.scrollbar, {\n    enable,\n    disable,\n    updateSize: updateSize2,\n    setTranslate: setTranslate2,\n    init,\n    destroy\n  });\n}\nfunction Parallax({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    parallax: {\n      enabled: false\n    }\n  });\n  const setTransform = (el, progress) => {\n    const {\n      rtl\n    } = swiper;\n    const rtlFactor = rtl ? -1 : 1;\n    const p = el.getAttribute(\"data-swiper-parallax\") || \"0\";\n    let x = el.getAttribute(\"data-swiper-parallax-x\");\n    let y = el.getAttribute(\"data-swiper-parallax-y\");\n    const scale = el.getAttribute(\"data-swiper-parallax-scale\");\n    const opacity = el.getAttribute(\"data-swiper-parallax-opacity\");\n    const rotate = el.getAttribute(\"data-swiper-parallax-rotate\");\n    if (x || y) {\n      x = x || \"0\";\n      y = y || \"0\";\n    } else if (swiper.isHorizontal()) {\n      x = p;\n      y = \"0\";\n    } else {\n      y = p;\n      x = \"0\";\n    }\n    if (x.indexOf(\"%\") >= 0) {\n      x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n    } else {\n      x = `${x * progress * rtlFactor}px`;\n    }\n    if (y.indexOf(\"%\") >= 0) {\n      y = `${parseInt(y, 10) * progress}%`;\n    } else {\n      y = `${y * progress}px`;\n    }\n    if (typeof opacity !== \"undefined\" && opacity !== null) {\n      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n      el.style.opacity = currentOpacity;\n    }\n    let transform = `translate3d(${x}, ${y}, 0px)`;\n    if (typeof scale !== \"undefined\" && scale !== null) {\n      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n      transform += ` scale(${currentScale})`;\n    }\n    if (rotate && typeof rotate !== \"undefined\" && rotate !== null) {\n      const currentRotate = rotate * progress * -1;\n      transform += ` rotate(${currentRotate}deg)`;\n    }\n    el.style.transform = transform;\n  };\n  const setTranslate2 = () => {\n    const {\n      el,\n      slides,\n      progress,\n      snapGrid\n    } = swiper;\n    elementChildren(el, \"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").forEach((subEl) => {\n      setTransform(subEl, progress);\n    });\n    slides.forEach((slideEl, slideIndex) => {\n      let slideProgress = slideEl.progress;\n      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== \"auto\") {\n        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n      }\n      slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n      slideEl.querySelectorAll(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]\").forEach((subEl) => {\n        setTransform(subEl, slideProgress);\n      });\n    });\n  };\n  const setTransition2 = (duration = swiper.params.speed) => {\n    const {\n      el\n    } = swiper;\n    el.querySelectorAll(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").forEach((parallaxEl) => {\n      let parallaxDuration = parseInt(parallaxEl.getAttribute(\"data-swiper-parallax-duration\"), 10) || duration;\n      if (duration === 0)\n        parallaxDuration = 0;\n      parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n    });\n  };\n  on(\"beforeInit\", () => {\n    if (!swiper.params.parallax.enabled)\n      return;\n    swiper.params.watchSlidesProgress = true;\n    swiper.originalParams.watchSlidesProgress = true;\n  });\n  on(\"init\", () => {\n    if (!swiper.params.parallax.enabled)\n      return;\n    setTranslate2();\n  });\n  on(\"setTranslate\", () => {\n    if (!swiper.params.parallax.enabled)\n      return;\n    setTranslate2();\n  });\n  on(\"setTransition\", (_swiper, duration) => {\n    if (!swiper.params.parallax.enabled)\n      return;\n    setTransition2(duration);\n  });\n}\nfunction Zoom({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const window2 = getWindow();\n  extendParams({\n    zoom: {\n      enabled: false,\n      maxRatio: 3,\n      minRatio: 1,\n      toggle: true,\n      containerClass: \"swiper-zoom-container\",\n      zoomedSlideClass: \"swiper-slide-zoomed\"\n    }\n  });\n  swiper.zoom = {\n    enabled: false\n  };\n  let currentScale = 1;\n  let isScaling = false;\n  let fakeGestureTouched;\n  let fakeGestureMoved;\n  const evCache = [];\n  const gesture = {\n    originX: 0,\n    originY: 0,\n    slideEl: void 0,\n    slideWidth: void 0,\n    slideHeight: void 0,\n    imageEl: void 0,\n    imageWrapEl: void 0,\n    maxRatio: 3\n  };\n  const image = {\n    isTouched: void 0,\n    isMoved: void 0,\n    currentX: void 0,\n    currentY: void 0,\n    minX: void 0,\n    minY: void 0,\n    maxX: void 0,\n    maxY: void 0,\n    width: void 0,\n    height: void 0,\n    startX: void 0,\n    startY: void 0,\n    touchesStart: {},\n    touchesCurrent: {}\n  };\n  const velocity = {\n    x: void 0,\n    y: void 0,\n    prevPositionX: void 0,\n    prevPositionY: void 0,\n    prevTime: void 0\n  };\n  let scale = 1;\n  Object.defineProperty(swiper.zoom, \"scale\", {\n    get() {\n      return scale;\n    },\n    set(value) {\n      if (scale !== value) {\n        const imageEl = gesture.imageEl;\n        const slideEl = gesture.slideEl;\n        emit(\"zoomChange\", value, imageEl, slideEl);\n      }\n      scale = value;\n    }\n  });\n  function getDistanceBetweenTouches() {\n    if (evCache.length < 2)\n      return 1;\n    const x1 = evCache[0].pageX;\n    const y1 = evCache[0].pageY;\n    const x2 = evCache[1].pageX;\n    const y2 = evCache[1].pageY;\n    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n    return distance;\n  }\n  function getScaleOrigin() {\n    if (evCache.length < 2)\n      return {\n        x: null,\n        y: null\n      };\n    const box = gesture.imageEl.getBoundingClientRect();\n    return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale];\n  }\n  function getSlideSelector() {\n    return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n  }\n  function eventWithinSlide(e) {\n    const slideSelector = getSlideSelector();\n    if (e.target.matches(slideSelector))\n      return true;\n    if (swiper.slides.filter((slideEl) => slideEl.contains(e.target)).length > 0)\n      return true;\n    return false;\n  }\n  function eventWithinZoomContainer(e) {\n    const selector = `.${swiper.params.zoom.containerClass}`;\n    if (e.target.matches(selector))\n      return true;\n    if ([...swiper.el.querySelectorAll(selector)].filter((containerEl) => containerEl.contains(e.target)).length > 0)\n      return true;\n    return false;\n  }\n  function onGestureStart(e) {\n    if (e.pointerType === \"mouse\") {\n      evCache.splice(0, evCache.length);\n    }\n    if (!eventWithinSlide(e))\n      return;\n    const params = swiper.params.zoom;\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    evCache.push(e);\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureTouched = true;\n    gesture.scaleStart = getDistanceBetweenTouches();\n    if (!gesture.slideEl) {\n      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      if (!gesture.slideEl)\n        gesture.slideEl = swiper.slides[swiper.activeIndex];\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = void 0;\n      }\n      if (!gesture.imageWrapEl) {\n        gesture.imageEl = void 0;\n        return;\n      }\n      gesture.maxRatio = gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n    }\n    if (gesture.imageEl) {\n      const [originX, originY] = getScaleOrigin();\n      gesture.originX = originX;\n      gesture.originY = originY;\n      gesture.imageEl.style.transitionDuration = \"0ms\";\n    }\n    isScaling = true;\n  }\n  function onGestureChange(e) {\n    if (!eventWithinSlide(e))\n      return;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0)\n      evCache[pointerIndex] = e;\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureMoved = true;\n    gesture.scaleMove = getDistanceBetweenTouches();\n    if (!gesture.imageEl) {\n      return;\n    }\n    zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n    if (zoom.scale > gesture.maxRatio) {\n      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n    }\n    if (zoom.scale < params.minRatio) {\n      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n    }\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function onGestureEnd(e) {\n    if (!eventWithinSlide(e))\n      return;\n    if (e.pointerType === \"mouse\" && e.type === \"pointerout\")\n      return;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0)\n      evCache.splice(pointerIndex, 1);\n    if (!fakeGestureTouched || !fakeGestureMoved) {\n      return;\n    }\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    if (!gesture.imageEl)\n      return;\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n    currentScale = zoom.scale;\n    isScaling = false;\n    if (zoom.scale > 1 && gesture.slideEl) {\n      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n    } else if (zoom.scale <= 1 && gesture.slideEl) {\n      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    }\n    if (zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n      gesture.slideEl = void 0;\n    }\n  }\n  function onTouchStart2(e) {\n    const device = swiper.device;\n    if (!gesture.imageEl)\n      return;\n    if (image.isTouched)\n      return;\n    if (device.android && e.cancelable)\n      e.preventDefault();\n    image.isTouched = true;\n    const event2 = evCache.length > 0 ? evCache[0] : e;\n    image.touchesStart.x = event2.pageX;\n    image.touchesStart.y = event2.pageY;\n  }\n  function onTouchMove2(e) {\n    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e))\n      return;\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl)\n      return;\n    if (!image.isTouched || !gesture.slideEl)\n      return;\n    if (!image.isMoved) {\n      image.width = gesture.imageEl.offsetWidth;\n      image.height = gesture.imageEl.offsetHeight;\n      image.startX = getTranslate(gesture.imageWrapEl, \"x\") || 0;\n      image.startY = getTranslate(gesture.imageWrapEl, \"y\") || 0;\n      gesture.slideWidth = gesture.slideEl.offsetWidth;\n      gesture.slideHeight = gesture.slideEl.offsetHeight;\n      gesture.imageWrapEl.style.transitionDuration = \"0ms\";\n    }\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight)\n      return;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n    const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n    if (touchesDiff > 5) {\n      swiper.allowClick = false;\n    }\n    if (!image.isMoved && !isScaling) {\n      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n        image.isTouched = false;\n        return;\n      }\n      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n        image.isTouched = false;\n        return;\n      }\n    }\n    if (e.cancelable) {\n      e.preventDefault();\n    }\n    e.stopPropagation();\n    image.isMoved = true;\n    const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n    const {\n      originX,\n      originY\n    } = gesture;\n    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n    if (image.currentX < image.minX) {\n      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n    }\n    if (image.currentX > image.maxX) {\n      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n    }\n    if (image.currentY < image.minY) {\n      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n    }\n    if (image.currentY > image.maxY) {\n      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n    }\n    if (!velocity.prevPositionX)\n      velocity.prevPositionX = image.touchesCurrent.x;\n    if (!velocity.prevPositionY)\n      velocity.prevPositionY = image.touchesCurrent.y;\n    if (!velocity.prevTime)\n      velocity.prevTime = Date.now();\n    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2)\n      velocity.x = 0;\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2)\n      velocity.y = 0;\n    velocity.prevPositionX = image.touchesCurrent.x;\n    velocity.prevPositionY = image.touchesCurrent.y;\n    velocity.prevTime = Date.now();\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTouchEnd2() {\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl)\n      return;\n    if (!image.isTouched || !image.isMoved) {\n      image.isTouched = false;\n      image.isMoved = false;\n      return;\n    }\n    image.isTouched = false;\n    image.isMoved = false;\n    let momentumDurationX = 300;\n    let momentumDurationY = 300;\n    const momentumDistanceX = velocity.x * momentumDurationX;\n    const newPositionX = image.currentX + momentumDistanceX;\n    const momentumDistanceY = velocity.y * momentumDurationY;\n    const newPositionY = image.currentY + momentumDistanceY;\n    if (velocity.x !== 0)\n      momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n    if (velocity.y !== 0)\n      momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n    image.currentX = newPositionX;\n    image.currentY = newPositionY;\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTransitionEnd() {\n    const zoom = swiper.zoom;\n    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n      if (gesture.imageEl) {\n        gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n      }\n      if (gesture.imageWrapEl) {\n        gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n      }\n      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n      zoom.scale = 1;\n      currentScale = 1;\n      gesture.slideEl = void 0;\n      gesture.imageEl = void 0;\n      gesture.imageWrapEl = void 0;\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n  }\n  function zoomIn(e) {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    if (!gesture.slideEl) {\n      if (e && e.target) {\n        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      }\n      if (!gesture.slideEl) {\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n          gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n        } else {\n          gesture.slideEl = swiper.slides[swiper.activeIndex];\n        }\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = void 0;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl)\n      return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = \"hidden\";\n      swiper.wrapperEl.style.touchAction = \"none\";\n    }\n    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n    let touchX;\n    let touchY;\n    let offsetX;\n    let offsetY;\n    let diffX;\n    let diffY;\n    let translateX;\n    let translateY;\n    let imageWidth;\n    let imageHeight;\n    let scaledWidth;\n    let scaledHeight;\n    let translateMinX;\n    let translateMinY;\n    let translateMaxX;\n    let translateMaxY;\n    let slideWidth;\n    let slideHeight;\n    if (typeof image.touchesStart.x === \"undefined\" && e) {\n      touchX = e.pageX;\n      touchY = e.pageY;\n    } else {\n      touchX = image.touchesStart.x;\n      touchY = image.touchesStart.y;\n    }\n    const forceZoomRatio = typeof e === \"number\" ? e : null;\n    if (currentScale === 1 && forceZoomRatio) {\n      touchX = void 0;\n      touchY = void 0;\n    }\n    zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n    currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n    if (e && !(currentScale === 1 && forceZoomRatio)) {\n      slideWidth = gesture.slideEl.offsetWidth;\n      slideHeight = gesture.slideEl.offsetHeight;\n      offsetX = elementOffset(gesture.slideEl).left + window2.scrollX;\n      offsetY = elementOffset(gesture.slideEl).top + window2.scrollY;\n      diffX = offsetX + slideWidth / 2 - touchX;\n      diffY = offsetY + slideHeight / 2 - touchY;\n      imageWidth = gesture.imageEl.offsetWidth;\n      imageHeight = gesture.imageEl.offsetHeight;\n      scaledWidth = imageWidth * zoom.scale;\n      scaledHeight = imageHeight * zoom.scale;\n      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n      translateMaxX = -translateMinX;\n      translateMaxY = -translateMinY;\n      translateX = diffX * zoom.scale;\n      translateY = diffY * zoom.scale;\n      if (translateX < translateMinX) {\n        translateX = translateMinX;\n      }\n      if (translateX > translateMaxX) {\n        translateX = translateMaxX;\n      }\n      if (translateY < translateMinY) {\n        translateY = translateMinY;\n      }\n      if (translateY > translateMaxY) {\n        translateY = translateMaxY;\n      }\n    } else {\n      translateX = 0;\n      translateY = 0;\n    }\n    if (forceZoomRatio && zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n    gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n    gesture.imageEl.style.transitionDuration = \"300ms\";\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function zoomOut() {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    if (!gesture.slideEl) {\n      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n        gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n      } else {\n        gesture.slideEl = swiper.slides[swiper.activeIndex];\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = void 0;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl)\n      return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = \"\";\n      swiper.wrapperEl.style.touchAction = \"\";\n    }\n    zoom.scale = 1;\n    currentScale = 1;\n    gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n    gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n    gesture.imageEl.style.transitionDuration = \"300ms\";\n    gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    gesture.slideEl = void 0;\n    gesture.originX = 0;\n    gesture.originY = 0;\n  }\n  function zoomToggle(e) {\n    const zoom = swiper.zoom;\n    if (zoom.scale && zoom.scale !== 1) {\n      zoomOut();\n    } else {\n      zoomIn(e);\n    }\n  }\n  function getListeners() {\n    const passiveListener = swiper.params.passiveListeners ? {\n      passive: true,\n      capture: false\n    } : false;\n    const activeListenerWithCapture = swiper.params.passiveListeners ? {\n      passive: false,\n      capture: true\n    } : true;\n    return {\n      passiveListener,\n      activeListenerWithCapture\n    };\n  }\n  function enable() {\n    const zoom = swiper.zoom;\n    if (zoom.enabled)\n      return;\n    zoom.enabled = true;\n    const {\n      passiveListener,\n      activeListenerWithCapture\n    } = getListeners();\n    swiper.wrapperEl.addEventListener(\"pointerdown\", onGestureStart, passiveListener);\n    swiper.wrapperEl.addEventListener(\"pointermove\", onGestureChange, activeListenerWithCapture);\n    [\"pointerup\", \"pointercancel\", \"pointerout\"].forEach((eventName) => {\n      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n    });\n    swiper.wrapperEl.addEventListener(\"pointermove\", onTouchMove2, activeListenerWithCapture);\n  }\n  function disable() {\n    const zoom = swiper.zoom;\n    if (!zoom.enabled)\n      return;\n    zoom.enabled = false;\n    const {\n      passiveListener,\n      activeListenerWithCapture\n    } = getListeners();\n    swiper.wrapperEl.removeEventListener(\"pointerdown\", onGestureStart, passiveListener);\n    swiper.wrapperEl.removeEventListener(\"pointermove\", onGestureChange, activeListenerWithCapture);\n    [\"pointerup\", \"pointercancel\", \"pointerout\"].forEach((eventName) => {\n      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n    });\n    swiper.wrapperEl.removeEventListener(\"pointermove\", onTouchMove2, activeListenerWithCapture);\n  }\n  on(\"init\", () => {\n    if (swiper.params.zoom.enabled) {\n      enable();\n    }\n  });\n  on(\"destroy\", () => {\n    disable();\n  });\n  on(\"touchStart\", (_s, e) => {\n    if (!swiper.zoom.enabled)\n      return;\n    onTouchStart2(e);\n  });\n  on(\"touchEnd\", (_s, e) => {\n    if (!swiper.zoom.enabled)\n      return;\n    onTouchEnd2(e);\n  });\n  on(\"doubleTap\", (_s, e) => {\n    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n      zoomToggle(e);\n    }\n  });\n  on(\"transitionEnd\", () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n      onTransitionEnd();\n    }\n  });\n  on(\"slideChange\", () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n      onTransitionEnd();\n    }\n  });\n  Object.assign(swiper.zoom, {\n    enable,\n    disable,\n    in: zoomIn,\n    out: zoomOut,\n    toggle: zoomToggle\n  });\n}\nfunction Controller({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    controller: {\n      control: void 0,\n      inverse: false,\n      by: \"slide\"\n      // or 'container'\n    }\n  });\n  swiper.controller = {\n    control: void 0\n  };\n  function LinearSpline(x, y) {\n    const binarySearch = function search() {\n      let maxIndex;\n      let minIndex;\n      let guess;\n      return (array, val) => {\n        minIndex = -1;\n        maxIndex = array.length;\n        while (maxIndex - minIndex > 1) {\n          guess = maxIndex + minIndex >> 1;\n          if (array[guess] <= val) {\n            minIndex = guess;\n          } else {\n            maxIndex = guess;\n          }\n        }\n        return maxIndex;\n      };\n    }();\n    this.x = x;\n    this.y = y;\n    this.lastIndex = x.length - 1;\n    let i1;\n    let i3;\n    this.interpolate = function interpolate(x2) {\n      if (!x2)\n        return 0;\n      i3 = binarySearch(this.x, x2);\n      i1 = i3 - 1;\n      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n    };\n    return this;\n  }\n  function getInterpolateFunction(c) {\n    swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n  }\n  function setTranslate2(_t, byController) {\n    const controlled = swiper.controller.control;\n    let multiplier;\n    let controlledTranslate;\n    const Swiper2 = swiper.constructor;\n    function setControlledTranslate(c) {\n      if (c.destroyed)\n        return;\n      const translate2 = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n      if (swiper.params.controller.by === \"slide\") {\n        getInterpolateFunction(c);\n        controlledTranslate = -swiper.controller.spline.interpolate(-translate2);\n      }\n      if (!controlledTranslate || swiper.params.controller.by === \"container\") {\n        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n        if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {\n          multiplier = 1;\n        }\n        controlledTranslate = (translate2 - swiper.minTranslate()) * multiplier + c.minTranslate();\n      }\n      if (swiper.params.controller.inverse) {\n        controlledTranslate = c.maxTranslate() - controlledTranslate;\n      }\n      c.updateProgress(controlledTranslate);\n      c.setTranslate(controlledTranslate, swiper);\n      c.updateActiveIndex();\n      c.updateSlidesClasses();\n    }\n    if (Array.isArray(controlled)) {\n      for (let i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper2) {\n          setControlledTranslate(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper2 && byController !== controlled) {\n      setControlledTranslate(controlled);\n    }\n  }\n  function setTransition2(duration, byController) {\n    const Swiper2 = swiper.constructor;\n    const controlled = swiper.controller.control;\n    let i;\n    function setControlledTransition(c) {\n      if (c.destroyed)\n        return;\n      c.setTransition(duration, swiper);\n      if (duration !== 0) {\n        c.transitionStart();\n        if (c.params.autoHeight) {\n          nextTick(() => {\n            c.updateAutoHeight();\n          });\n        }\n        elementTransitionEnd(c.wrapperEl, () => {\n          if (!controlled)\n            return;\n          c.transitionEnd();\n        });\n      }\n    }\n    if (Array.isArray(controlled)) {\n      for (i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper2) {\n          setControlledTransition(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper2 && byController !== controlled) {\n      setControlledTransition(controlled);\n    }\n  }\n  function removeSpline() {\n    if (!swiper.controller.control)\n      return;\n    if (swiper.controller.spline) {\n      swiper.controller.spline = void 0;\n      delete swiper.controller.spline;\n    }\n  }\n  on(\"beforeInit\", () => {\n    if (typeof window !== \"undefined\" && // eslint-disable-line\n    (typeof swiper.params.controller.control === \"string\" || swiper.params.controller.control instanceof HTMLElement)) {\n      const controlElement = document.querySelector(swiper.params.controller.control);\n      if (controlElement && controlElement.swiper) {\n        swiper.controller.control = controlElement.swiper;\n      } else if (controlElement) {\n        const onControllerSwiper = (e) => {\n          swiper.controller.control = e.detail[0];\n          swiper.update();\n          controlElement.removeEventListener(\"init\", onControllerSwiper);\n        };\n        controlElement.addEventListener(\"init\", onControllerSwiper);\n      }\n      return;\n    }\n    swiper.controller.control = swiper.params.controller.control;\n  });\n  on(\"update\", () => {\n    removeSpline();\n  });\n  on(\"resize\", () => {\n    removeSpline();\n  });\n  on(\"observerUpdate\", () => {\n    removeSpline();\n  });\n  on(\"setTranslate\", (_s, translate2, byController) => {\n    if (!swiper.controller.control || swiper.controller.control.destroyed)\n      return;\n    swiper.controller.setTranslate(translate2, byController);\n  });\n  on(\"setTransition\", (_s, duration, byController) => {\n    if (!swiper.controller.control || swiper.controller.control.destroyed)\n      return;\n    swiper.controller.setTransition(duration, byController);\n  });\n  Object.assign(swiper.controller, {\n    setTranslate: setTranslate2,\n    setTransition: setTransition2\n  });\n}\nfunction A11y({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    a11y: {\n      enabled: true,\n      notificationClass: \"swiper-notification\",\n      prevSlideMessage: \"Previous slide\",\n      nextSlideMessage: \"Next slide\",\n      firstSlideMessage: \"This is the first slide\",\n      lastSlideMessage: \"This is the last slide\",\n      paginationBulletMessage: \"Go to slide {{index}}\",\n      slideLabelMessage: \"{{index}} / {{slidesLength}}\",\n      containerMessage: null,\n      containerRoleDescriptionMessage: null,\n      itemRoleDescriptionMessage: null,\n      slideRole: \"group\",\n      id: null\n    }\n  });\n  swiper.a11y = {\n    clicked: false\n  };\n  let liveRegion = null;\n  function notify(message) {\n    const notification = liveRegion;\n    if (notification.length === 0)\n      return;\n    notification.innerHTML = \"\";\n    notification.innerHTML = message;\n  }\n  const makeElementsArray = (el) => {\n    if (!Array.isArray(el))\n      el = [el].filter((e) => !!e);\n    return el;\n  };\n  function getRandomNumber(size = 16) {\n    const randomChar = () => Math.round(16 * Math.random()).toString(16);\n    return \"x\".repeat(size).replace(/x/g, randomChar);\n  }\n  function makeElFocusable(el) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute(\"tabIndex\", \"0\");\n    });\n  }\n  function makeElNotFocusable(el) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute(\"tabIndex\", \"-1\");\n    });\n  }\n  function addElRole(el, role) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute(\"role\", role);\n    });\n  }\n  function addElRoleDescription(el, description) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute(\"aria-roledescription\", description);\n    });\n  }\n  function addElControls(el, controls) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute(\"aria-controls\", controls);\n    });\n  }\n  function addElLabel(el, label) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute(\"aria-label\", label);\n    });\n  }\n  function addElId(el, id) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute(\"id\", id);\n    });\n  }\n  function addElLive(el, live) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute(\"aria-live\", live);\n    });\n  }\n  function disableEl(el) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute(\"aria-disabled\", true);\n    });\n  }\n  function enableEl(el) {\n    el = makeElementsArray(el);\n    el.forEach((subEl) => {\n      subEl.setAttribute(\"aria-disabled\", false);\n    });\n  }\n  function onEnterOrSpaceKey(e) {\n    if (e.keyCode !== 13 && e.keyCode !== 32)\n      return;\n    const params = swiper.params.a11y;\n    const targetEl = e.target;\n    if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n      if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass)))\n        return;\n    }\n    if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {\n      if (!(swiper.isEnd && !swiper.params.loop)) {\n        swiper.slideNext();\n      }\n      if (swiper.isEnd) {\n        notify(params.lastSlideMessage);\n      } else {\n        notify(params.nextSlideMessage);\n      }\n    }\n    if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {\n      if (!(swiper.isBeginning && !swiper.params.loop)) {\n        swiper.slidePrev();\n      }\n      if (swiper.isBeginning) {\n        notify(params.firstSlideMessage);\n      } else {\n        notify(params.prevSlideMessage);\n      }\n    }\n    if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {\n      targetEl.click();\n    }\n  }\n  function updateNavigation() {\n    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation)\n      return;\n    const {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    if (prevEl) {\n      if (swiper.isBeginning) {\n        disableEl(prevEl);\n        makeElNotFocusable(prevEl);\n      } else {\n        enableEl(prevEl);\n        makeElFocusable(prevEl);\n      }\n    }\n    if (nextEl) {\n      if (swiper.isEnd) {\n        disableEl(nextEl);\n        makeElNotFocusable(nextEl);\n      } else {\n        enableEl(nextEl);\n        makeElFocusable(nextEl);\n      }\n    }\n  }\n  function hasPagination() {\n    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n  }\n  function hasClickablePagination() {\n    return hasPagination() && swiper.params.pagination.clickable;\n  }\n  function updatePagination() {\n    const params = swiper.params.a11y;\n    if (!hasPagination())\n      return;\n    swiper.pagination.bullets.forEach((bulletEl) => {\n      if (swiper.params.pagination.clickable) {\n        makeElFocusable(bulletEl);\n        if (!swiper.params.pagination.renderBullet) {\n          addElRole(bulletEl, \"button\");\n          addElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n        }\n      }\n      if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {\n        bulletEl.setAttribute(\"aria-current\", \"true\");\n      } else {\n        bulletEl.removeAttribute(\"aria-current\");\n      }\n    });\n  }\n  const initNavEl = (el, wrapperId, message) => {\n    makeElFocusable(el);\n    if (el.tagName !== \"BUTTON\") {\n      addElRole(el, \"button\");\n      el.addEventListener(\"keydown\", onEnterOrSpaceKey);\n    }\n    addElLabel(el, message);\n    addElControls(el, wrapperId);\n  };\n  const handlePointerDown = () => {\n    swiper.a11y.clicked = true;\n  };\n  const handlePointerUp = () => {\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => {\n        if (!swiper.destroyed) {\n          swiper.a11y.clicked = false;\n        }\n      });\n    });\n  };\n  const handleFocus = (e) => {\n    if (swiper.a11y.clicked)\n      return;\n    const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n    if (!slideEl || !swiper.slides.includes(slideEl))\n      return;\n    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n    const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n    if (isActive || isVisible)\n      return;\n    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents)\n      return;\n    if (swiper.isHorizontal()) {\n      swiper.el.scrollLeft = 0;\n    } else {\n      swiper.el.scrollTop = 0;\n    }\n    swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n  };\n  const initSlides = () => {\n    const params = swiper.params.a11y;\n    if (params.itemRoleDescriptionMessage) {\n      addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n    }\n    if (params.slideRole) {\n      addElRole(swiper.slides, params.slideRole);\n    }\n    const slidesLength = swiper.slides.length;\n    if (params.slideLabelMessage) {\n      swiper.slides.forEach((slideEl, index) => {\n        const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute(\"data-swiper-slide-index\"), 10) : index;\n        const ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n        addElLabel(slideEl, ariaLabelMessage);\n      });\n    }\n  };\n  const init = () => {\n    const params = swiper.params.a11y;\n    if (swiper.isElement) {\n      swiper.el.shadowEl.append(liveRegion);\n    } else {\n      swiper.el.append(liveRegion);\n    }\n    const containerEl = swiper.el;\n    if (params.containerRoleDescriptionMessage) {\n      addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n    }\n    if (params.containerMessage) {\n      addElLabel(containerEl, params.containerMessage);\n    }\n    const wrapperEl = swiper.wrapperEl;\n    const wrapperId = params.id || wrapperEl.getAttribute(\"id\") || `swiper-wrapper-${getRandomNumber(16)}`;\n    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? \"off\" : \"polite\";\n    addElId(wrapperEl, wrapperId);\n    addElLive(wrapperEl, live);\n    initSlides();\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation ? swiper.navigation : {};\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    if (nextEl) {\n      nextEl.forEach((el) => initNavEl(el, wrapperId, params.nextSlideMessage));\n    }\n    if (prevEl) {\n      prevEl.forEach((el) => initNavEl(el, wrapperId, params.prevSlideMessage));\n    }\n    if (hasClickablePagination()) {\n      const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n      paginationEl.forEach((el) => {\n        el.addEventListener(\"keydown\", onEnterOrSpaceKey);\n      });\n    }\n    swiper.el.addEventListener(\"focus\", handleFocus, true);\n    swiper.el.addEventListener(\"pointerdown\", handlePointerDown, true);\n    swiper.el.addEventListener(\"pointerup\", handlePointerUp, true);\n  };\n  function destroy() {\n    if (liveRegion)\n      liveRegion.remove();\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation ? swiper.navigation : {};\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    if (nextEl) {\n      nextEl.forEach((el) => el.removeEventListener(\"keydown\", onEnterOrSpaceKey));\n    }\n    if (prevEl) {\n      prevEl.forEach((el) => el.removeEventListener(\"keydown\", onEnterOrSpaceKey));\n    }\n    if (hasClickablePagination()) {\n      const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n      paginationEl.forEach((el) => {\n        el.removeEventListener(\"keydown\", onEnterOrSpaceKey);\n      });\n    }\n    swiper.el.removeEventListener(\"focus\", handleFocus, true);\n    swiper.el.removeEventListener(\"pointerdown\", handlePointerDown, true);\n    swiper.el.removeEventListener(\"pointerup\", handlePointerUp, true);\n  }\n  on(\"beforeInit\", () => {\n    liveRegion = createElement(\"span\", swiper.params.a11y.notificationClass);\n    liveRegion.setAttribute(\"aria-live\", \"assertive\");\n    liveRegion.setAttribute(\"aria-atomic\", \"true\");\n  });\n  on(\"afterInit\", () => {\n    if (!swiper.params.a11y.enabled)\n      return;\n    init();\n  });\n  on(\"slidesLengthChange snapGridLengthChange slidesGridLengthChange\", () => {\n    if (!swiper.params.a11y.enabled)\n      return;\n    initSlides();\n  });\n  on(\"fromEdge toEdge afterInit lock unlock\", () => {\n    if (!swiper.params.a11y.enabled)\n      return;\n    updateNavigation();\n  });\n  on(\"paginationUpdate\", () => {\n    if (!swiper.params.a11y.enabled)\n      return;\n    updatePagination();\n  });\n  on(\"destroy\", () => {\n    if (!swiper.params.a11y.enabled)\n      return;\n    destroy();\n  });\n}\nfunction History({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    history: {\n      enabled: false,\n      root: \"\",\n      replaceState: false,\n      key: \"slides\",\n      keepQuery: false\n    }\n  });\n  let initialized = false;\n  let paths = {};\n  const slugify = (text) => {\n    return text.toString().replace(/\\s+/g, \"-\").replace(/[^\\w-]+/g, \"\").replace(/--+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\");\n  };\n  const getPathValues = (urlOverride) => {\n    const window2 = getWindow();\n    let location;\n    if (urlOverride) {\n      location = new URL(urlOverride);\n    } else {\n      location = window2.location;\n    }\n    const pathArray = location.pathname.slice(1).split(\"/\").filter((part) => part !== \"\");\n    const total = pathArray.length;\n    const key = pathArray[total - 2];\n    const value = pathArray[total - 1];\n    return {\n      key,\n      value\n    };\n  };\n  const setHistory = (key, index) => {\n    const window2 = getWindow();\n    if (!initialized || !swiper.params.history.enabled)\n      return;\n    let location;\n    if (swiper.params.url) {\n      location = new URL(swiper.params.url);\n    } else {\n      location = window2.location;\n    }\n    const slide2 = swiper.slides[index];\n    let value = slugify(slide2.getAttribute(\"data-history\"));\n    if (swiper.params.history.root.length > 0) {\n      let root = swiper.params.history.root;\n      if (root[root.length - 1] === \"/\")\n        root = root.slice(0, root.length - 1);\n      value = `${root}/${key ? `${key}/` : \"\"}${value}`;\n    } else if (!location.pathname.includes(key)) {\n      value = `${key ? `${key}/` : \"\"}${value}`;\n    }\n    if (swiper.params.history.keepQuery) {\n      value += location.search;\n    }\n    const currentState = window2.history.state;\n    if (currentState && currentState.value === value) {\n      return;\n    }\n    if (swiper.params.history.replaceState) {\n      window2.history.replaceState({\n        value\n      }, null, value);\n    } else {\n      window2.history.pushState({\n        value\n      }, null, value);\n    }\n  };\n  const scrollToSlide = (speed, value, runCallbacks) => {\n    if (value) {\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide2 = swiper.slides[i];\n        const slideHistory = slugify(slide2.getAttribute(\"data-history\"));\n        if (slideHistory === value) {\n          const index = swiper.getSlideIndex(slide2);\n          swiper.slideTo(index, speed, runCallbacks);\n        }\n      }\n    } else {\n      swiper.slideTo(0, speed, runCallbacks);\n    }\n  };\n  const setHistoryPopState = () => {\n    paths = getPathValues(swiper.params.url);\n    scrollToSlide(swiper.params.speed, paths.value, false);\n  };\n  const init = () => {\n    const window2 = getWindow();\n    if (!swiper.params.history)\n      return;\n    if (!window2.history || !window2.history.pushState) {\n      swiper.params.history.enabled = false;\n      swiper.params.hashNavigation.enabled = true;\n      return;\n    }\n    initialized = true;\n    paths = getPathValues(swiper.params.url);\n    if (!paths.key && !paths.value) {\n      if (!swiper.params.history.replaceState) {\n        window2.addEventListener(\"popstate\", setHistoryPopState);\n      }\n      return;\n    }\n    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n    if (!swiper.params.history.replaceState) {\n      window2.addEventListener(\"popstate\", setHistoryPopState);\n    }\n  };\n  const destroy = () => {\n    const window2 = getWindow();\n    if (!swiper.params.history.replaceState) {\n      window2.removeEventListener(\"popstate\", setHistoryPopState);\n    }\n  };\n  on(\"init\", () => {\n    if (swiper.params.history.enabled) {\n      init();\n    }\n  });\n  on(\"destroy\", () => {\n    if (swiper.params.history.enabled) {\n      destroy();\n    }\n  });\n  on(\"transitionEnd _freeModeNoMomentumRelease\", () => {\n    if (initialized) {\n      setHistory(swiper.params.history.key, swiper.activeIndex);\n    }\n  });\n  on(\"slideChange\", () => {\n    if (initialized && swiper.params.cssMode) {\n      setHistory(swiper.params.history.key, swiper.activeIndex);\n    }\n  });\n}\nfunction HashNavigation({\n  swiper,\n  extendParams,\n  emit,\n  on\n}) {\n  let initialized = false;\n  const document2 = getDocument();\n  const window2 = getWindow();\n  extendParams({\n    hashNavigation: {\n      enabled: false,\n      replaceState: false,\n      watchState: false,\n      getSlideIndex(_s, hash) {\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          const slideWithHash = swiper.slides.filter((slideEl) => slideEl.getAttribute(\"data-hash\") === hash)[0];\n          if (!slideWithHash)\n            return 0;\n          const index = parseInt(slideWithHash.getAttribute(\"data-swiper-slide-index\"), 10);\n          return index;\n        }\n        return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n      }\n    }\n  });\n  const onHashChange = () => {\n    emit(\"hashChange\");\n    const newHash = document2.location.hash.replace(\"#\", \"\");\n    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute(\"data-hash\") : \"\";\n    if (newHash !== activeSlideHash) {\n      const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n      if (typeof newIndex === \"undefined\" || Number.isNaN(newIndex))\n        return;\n      swiper.slideTo(newIndex);\n    }\n  };\n  const setHash = () => {\n    if (!initialized || !swiper.params.hashNavigation.enabled)\n      return;\n    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute(\"data-hash\") || activeSlideEl.getAttribute(\"data-history\") : \"\";\n    if (swiper.params.hashNavigation.replaceState && window2.history && window2.history.replaceState) {\n      window2.history.replaceState(null, null, `#${activeSlideHash}` || \"\");\n      emit(\"hashSet\");\n    } else {\n      document2.location.hash = activeSlideHash || \"\";\n      emit(\"hashSet\");\n    }\n  };\n  const init = () => {\n    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled)\n      return;\n    initialized = true;\n    const hash = document2.location.hash.replace(\"#\", \"\");\n    if (hash) {\n      const speed = 0;\n      const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n      swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n    }\n    if (swiper.params.hashNavigation.watchState) {\n      window2.addEventListener(\"hashchange\", onHashChange);\n    }\n  };\n  const destroy = () => {\n    if (swiper.params.hashNavigation.watchState) {\n      window2.removeEventListener(\"hashchange\", onHashChange);\n    }\n  };\n  on(\"init\", () => {\n    if (swiper.params.hashNavigation.enabled) {\n      init();\n    }\n  });\n  on(\"destroy\", () => {\n    if (swiper.params.hashNavigation.enabled) {\n      destroy();\n    }\n  });\n  on(\"transitionEnd _freeModeNoMomentumRelease\", () => {\n    if (initialized) {\n      setHash();\n    }\n  });\n  on(\"slideChange\", () => {\n    if (initialized && swiper.params.cssMode) {\n      setHash();\n    }\n  });\n}\nfunction Autoplay({\n  swiper,\n  extendParams,\n  on,\n  emit,\n  params\n}) {\n  swiper.autoplay = {\n    running: false,\n    paused: false,\n    timeLeft: 0\n  };\n  extendParams({\n    autoplay: {\n      enabled: false,\n      delay: 3e3,\n      waitForTransition: true,\n      disableOnInteraction: true,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n      pauseOnMouseEnter: false\n    }\n  });\n  let timeout;\n  let raf;\n  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;\n  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;\n  let autoplayTimeLeft;\n  let autoplayStartTime = (/* @__PURE__ */ new Date()).getTime;\n  let wasPaused;\n  let isTouched;\n  let pausedByTouch;\n  let touchStartTimeout;\n  let slideChanged;\n  let pausedByInteraction;\n  function onTransitionEnd(e) {\n    if (!swiper || swiper.destroyed || !swiper.wrapperEl)\n      return;\n    if (e.target !== swiper.wrapperEl)\n      return;\n    swiper.wrapperEl.removeEventListener(\"transitionend\", onTransitionEnd);\n    resume();\n  }\n  const calcTimeLeft = () => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    if (swiper.autoplay.paused) {\n      wasPaused = true;\n    } else if (wasPaused) {\n      autoplayDelayCurrent = autoplayTimeLeft;\n      wasPaused = false;\n    }\n    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (/* @__PURE__ */ new Date()).getTime();\n    swiper.autoplay.timeLeft = timeLeft;\n    emit(\"autoplayTimeLeft\", timeLeft, timeLeft / autoplayDelayTotal);\n    raf = requestAnimationFrame(() => {\n      calcTimeLeft();\n    });\n  };\n  const getSlideDelay = () => {\n    let activeSlideEl;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      activeSlideEl = swiper.slides.filter((slideEl) => slideEl.classList.contains(\"swiper-slide-active\"))[0];\n    } else {\n      activeSlideEl = swiper.slides[swiper.activeIndex];\n    }\n    if (!activeSlideEl)\n      return void 0;\n    const currentSlideDelay = parseInt(activeSlideEl.getAttribute(\"data-swiper-autoplay\"), 10);\n    return currentSlideDelay;\n  };\n  const run = (delayForce) => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    cancelAnimationFrame(raf);\n    calcTimeLeft();\n    let delay = typeof delayForce === \"undefined\" ? swiper.params.autoplay.delay : delayForce;\n    autoplayDelayTotal = swiper.params.autoplay.delay;\n    autoplayDelayCurrent = swiper.params.autoplay.delay;\n    const currentSlideDelay = getSlideDelay();\n    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === \"undefined\") {\n      delay = currentSlideDelay;\n      autoplayDelayTotal = currentSlideDelay;\n      autoplayDelayCurrent = currentSlideDelay;\n    }\n    autoplayTimeLeft = delay;\n    const speed = swiper.params.speed;\n    const proceed = () => {\n      if (!swiper || swiper.destroyed)\n        return;\n      if (swiper.params.autoplay.reverseDirection) {\n        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n          swiper.slidePrev(speed, true, true);\n          emit(\"autoplay\");\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n          emit(\"autoplay\");\n        }\n      } else {\n        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n          swiper.slideNext(speed, true, true);\n          emit(\"autoplay\");\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(0, speed, true, true);\n          emit(\"autoplay\");\n        }\n      }\n      if (swiper.params.cssMode) {\n        autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();\n        requestAnimationFrame(() => {\n          run();\n        });\n      }\n    };\n    if (delay > 0) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        proceed();\n      }, delay);\n    } else {\n      requestAnimationFrame(() => {\n        proceed();\n      });\n    }\n    return delay;\n  };\n  const start = () => {\n    swiper.autoplay.running = true;\n    run();\n    emit(\"autoplayStart\");\n  };\n  const stop = () => {\n    swiper.autoplay.running = false;\n    clearTimeout(timeout);\n    cancelAnimationFrame(raf);\n    emit(\"autoplayStop\");\n  };\n  const pause = (internal, reset) => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    clearTimeout(timeout);\n    if (!internal) {\n      pausedByInteraction = true;\n    }\n    const proceed = () => {\n      emit(\"autoplayPause\");\n      if (swiper.params.autoplay.waitForTransition) {\n        swiper.wrapperEl.addEventListener(\"transitionend\", onTransitionEnd);\n      } else {\n        resume();\n      }\n    };\n    swiper.autoplay.paused = true;\n    if (reset) {\n      if (slideChanged) {\n        autoplayTimeLeft = swiper.params.autoplay.delay;\n      }\n      slideChanged = false;\n      proceed();\n      return;\n    }\n    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n    autoplayTimeLeft = delay - ((/* @__PURE__ */ new Date()).getTime() - autoplayStartTime);\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop)\n      return;\n    if (autoplayTimeLeft < 0)\n      autoplayTimeLeft = 0;\n    proceed();\n  };\n  const resume = () => {\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running)\n      return;\n    autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();\n    if (pausedByInteraction) {\n      pausedByInteraction = false;\n      run(autoplayTimeLeft);\n    } else {\n      run();\n    }\n    swiper.autoplay.paused = false;\n    emit(\"autoplayResume\");\n  };\n  const onVisibilityChange = () => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    const document2 = getDocument();\n    if (document2.visibilityState === \"hidden\") {\n      pausedByInteraction = true;\n      pause(true);\n    }\n    if (document2.visibilityState === \"visible\") {\n      resume();\n    }\n  };\n  const onPointerEnter = (e) => {\n    if (e.pointerType !== \"mouse\")\n      return;\n    pausedByInteraction = true;\n    pause(true);\n  };\n  const onPointerLeave = (e) => {\n    if (e.pointerType !== \"mouse\")\n      return;\n    if (swiper.autoplay.paused) {\n      resume();\n    }\n  };\n  const attachMouseEvents = () => {\n    if (swiper.params.autoplay.pauseOnMouseEnter) {\n      swiper.el.addEventListener(\"pointerenter\", onPointerEnter);\n      swiper.el.addEventListener(\"pointerleave\", onPointerLeave);\n    }\n  };\n  const detachMouseEvents = () => {\n    swiper.el.removeEventListener(\"pointerenter\", onPointerEnter);\n    swiper.el.removeEventListener(\"pointerleave\", onPointerLeave);\n  };\n  const attachDocumentEvents = () => {\n    const document2 = getDocument();\n    document2.addEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  const detachDocumentEvents = () => {\n    const document2 = getDocument();\n    document2.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  on(\"init\", () => {\n    if (swiper.params.autoplay.enabled) {\n      attachMouseEvents();\n      attachDocumentEvents();\n      autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();\n      start();\n    }\n  });\n  on(\"destroy\", () => {\n    detachMouseEvents();\n    detachDocumentEvents();\n    if (swiper.autoplay.running) {\n      stop();\n    }\n  });\n  on(\"beforeTransitionStart\", (_s, speed, internal) => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    if (internal || !swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n  on(\"sliderFirstMove\", () => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    if (swiper.params.autoplay.disableOnInteraction) {\n      stop();\n      return;\n    }\n    isTouched = true;\n    pausedByTouch = false;\n    pausedByInteraction = false;\n    touchStartTimeout = setTimeout(() => {\n      pausedByInteraction = true;\n      pausedByTouch = true;\n      pause(true);\n    }, 200);\n  });\n  on(\"touchEnd\", () => {\n    if (swiper.destroyed || !swiper.autoplay.running || !isTouched)\n      return;\n    clearTimeout(touchStartTimeout);\n    clearTimeout(timeout);\n    if (swiper.params.autoplay.disableOnInteraction) {\n      pausedByTouch = false;\n      isTouched = false;\n      return;\n    }\n    if (pausedByTouch && swiper.params.cssMode)\n      resume();\n    pausedByTouch = false;\n    isTouched = false;\n  });\n  on(\"slideChange\", () => {\n    if (swiper.destroyed || !swiper.autoplay.running)\n      return;\n    slideChanged = true;\n  });\n  Object.assign(swiper.autoplay, {\n    start,\n    stop,\n    pause,\n    resume\n  });\n}\nfunction Thumb({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    thumbs: {\n      swiper: null,\n      multipleActiveThumbs: true,\n      autoScrollOffset: 0,\n      slideThumbActiveClass: \"swiper-slide-thumb-active\",\n      thumbsContainerClass: \"swiper-thumbs\"\n    }\n  });\n  let initialized = false;\n  let swiperCreated = false;\n  swiper.thumbs = {\n    swiper: null\n  };\n  function onThumbClick() {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed)\n      return;\n    const clickedIndex = thumbsSwiper.clickedIndex;\n    const clickedSlide = thumbsSwiper.clickedSlide;\n    if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass))\n      return;\n    if (typeof clickedIndex === \"undefined\" || clickedIndex === null)\n      return;\n    let slideToIndex;\n    if (thumbsSwiper.params.loop) {\n      slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n    } else {\n      slideToIndex = clickedIndex;\n    }\n    if (swiper.params.loop) {\n      swiper.slideToLoop(slideToIndex);\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  }\n  function init() {\n    const {\n      thumbs: thumbsParams\n    } = swiper.params;\n    if (initialized)\n      return false;\n    initialized = true;\n    const SwiperClass = swiper.constructor;\n    if (thumbsParams.swiper instanceof SwiperClass) {\n      swiper.thumbs.swiper = thumbsParams.swiper;\n      Object.assign(swiper.thumbs.swiper.originalParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false\n      });\n      Object.assign(swiper.thumbs.swiper.params, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false\n      });\n      swiper.thumbs.swiper.update();\n    } else if (isObject(thumbsParams.swiper)) {\n      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n      Object.assign(thumbsSwiperParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false\n      });\n      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n      swiperCreated = true;\n    }\n    swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n    swiper.thumbs.swiper.on(\"tap\", onThumbClick);\n    return true;\n  }\n  function update2(initial) {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed)\n      return;\n    const slidesPerView = thumbsSwiper.params.slidesPerView === \"auto\" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n    let thumbsToActivate = 1;\n    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n      thumbsToActivate = swiper.params.slidesPerView;\n    }\n    if (!swiper.params.thumbs.multipleActiveThumbs) {\n      thumbsToActivate = 1;\n    }\n    thumbsToActivate = Math.floor(thumbsToActivate);\n    thumbsSwiper.slides.forEach((slideEl) => slideEl.classList.remove(thumbActiveClass));\n    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach((slideEl) => {\n          slideEl.classList.add(thumbActiveClass);\n        });\n      }\n    } else {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        if (thumbsSwiper.slides[swiper.realIndex + i]) {\n          thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n        }\n      }\n    }\n    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n      const currentThumbsIndex = thumbsSwiper.activeIndex;\n      let newThumbsIndex;\n      let direction;\n      if (thumbsSwiper.params.loop) {\n        const newThumbsSlide = thumbsSwiper.slides.filter((slideEl) => slideEl.getAttribute(\"data-swiper-slide-index\") === `${swiper.realIndex}`)[0];\n        newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n        direction = swiper.activeIndex > swiper.previousIndex ? \"next\" : \"prev\";\n      } else {\n        newThumbsIndex = swiper.realIndex;\n        direction = newThumbsIndex > swiper.previousIndex ? \"next\" : \"prev\";\n      }\n      if (useOffset) {\n        newThumbsIndex += direction === \"next\" ? autoScrollOffset : -1 * autoScrollOffset;\n      }\n      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n        if (thumbsSwiper.params.centeredSlides) {\n          if (newThumbsIndex > currentThumbsIndex) {\n            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n          } else {\n            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n          }\n        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) {\n        }\n        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);\n      }\n    }\n  }\n  on(\"beforeInit\", () => {\n    const {\n      thumbs\n    } = swiper.params;\n    if (!thumbs || !thumbs.swiper)\n      return;\n    if (typeof thumbs.swiper === \"string\" || thumbs.swiper instanceof HTMLElement) {\n      const document2 = getDocument();\n      const getThumbsElementAndInit = () => {\n        const thumbsElement = typeof thumbs.swiper === \"string\" ? document2.querySelector(thumbs.swiper) : thumbs.swiper;\n        if (thumbsElement && thumbsElement.swiper) {\n          thumbs.swiper = thumbsElement.swiper;\n          init();\n          update2(true);\n        } else if (thumbsElement) {\n          const onThumbsSwiper = (e) => {\n            thumbs.swiper = e.detail[0];\n            thumbsElement.removeEventListener(\"init\", onThumbsSwiper);\n            init();\n            update2(true);\n            thumbs.swiper.update();\n            swiper.update();\n          };\n          thumbsElement.addEventListener(\"init\", onThumbsSwiper);\n        }\n        return thumbsElement;\n      };\n      const watchForThumbsToAppear = () => {\n        if (swiper.destroyed)\n          return;\n        const thumbsElement = getThumbsElementAndInit();\n        if (!thumbsElement) {\n          requestAnimationFrame(watchForThumbsToAppear);\n        }\n      };\n      requestAnimationFrame(watchForThumbsToAppear);\n    } else {\n      init();\n      update2(true);\n    }\n  });\n  on(\"slideChange update resize observerUpdate\", () => {\n    update2();\n  });\n  on(\"setTransition\", (_s, duration) => {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed)\n      return;\n    thumbsSwiper.setTransition(duration);\n  });\n  on(\"beforeDestroy\", () => {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed)\n      return;\n    if (swiperCreated) {\n      thumbsSwiper.destroy();\n    }\n  });\n  Object.assign(swiper.thumbs, {\n    init,\n    update: update2\n  });\n}\nfunction freeMode({\n  swiper,\n  extendParams,\n  emit,\n  once\n}) {\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n  function onTouchStart2() {\n    if (swiper.params.cssMode)\n      return;\n    const translate2 = swiper.getTranslate();\n    swiper.setTranslate(translate2);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({\n      currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n    });\n  }\n  function onTouchMove2() {\n    if (swiper.params.cssMode)\n      return;\n    const {\n      touchEventsData: data,\n      touches\n    } = swiper;\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? \"startX\" : \"startY\"],\n        time: data.touchStartTime\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? \"currentX\" : \"currentY\"],\n      time: now()\n    });\n  }\n  function onTouchEnd2({\n    currentPos\n  }) {\n    if (swiper.params.cssMode)\n      return;\n    const {\n      params,\n      wrapperEl,\n      rtlTranslate: rtl,\n      snapGrid,\n      touchEventsData: data\n    } = swiper;\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        }\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1e3 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl)\n        newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides)\n          needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides)\n          needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === \"next\") {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        once(\"transitionEnd\", () => {\n          swiper.loopFix();\n        });\n      }\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeMode.sticky) {\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        elementTransitionEnd(wrapperEl, () => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce)\n            return;\n          emit(\"momentumBounce\");\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed)\n                return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit(\"_freeModeNoMomentumRelease\");\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, () => {\n            if (!swiper || swiper.destroyed)\n              return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit(\"_freeModeNoMomentumRelease\");\n    }\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart: onTouchStart2,\n      onTouchMove: onTouchMove2,\n      onTouchEnd: onTouchEnd2\n    }\n  });\n}\nfunction Grid({\n  swiper,\n  extendParams\n}) {\n  extendParams({\n    grid: {\n      rows: 1,\n      fill: \"column\"\n    }\n  });\n  let slidesNumberEvenToRows;\n  let slidesPerRow;\n  let numFullColumns;\n  const getSpaceBetween = () => {\n    let spaceBetween = swiper.params.spaceBetween;\n    if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n      spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiper.size;\n    } else if (typeof spaceBetween === \"string\") {\n      spaceBetween = parseFloat(spaceBetween);\n    }\n    return spaceBetween;\n  };\n  const initSlides = (slidesLength) => {\n    const {\n      slidesPerView\n    } = swiper.params;\n    const {\n      rows,\n      fill\n    } = swiper.params.grid;\n    numFullColumns = Math.floor(slidesLength / rows);\n    if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n      slidesNumberEvenToRows = slidesLength;\n    } else {\n      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n    }\n    if (slidesPerView !== \"auto\" && fill === \"row\") {\n      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n    }\n    slidesPerRow = slidesNumberEvenToRows / rows;\n  };\n  const updateSlide = (i, slide2, slidesLength, getDirectionLabel) => {\n    const {\n      slidesPerGroup\n    } = swiper.params;\n    const spaceBetween = getSpaceBetween();\n    const {\n      rows,\n      fill\n    } = swiper.params.grid;\n    let newSlideOrderIndex;\n    let column;\n    let row;\n    if (fill === \"row\" && slidesPerGroup > 1) {\n      const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n      const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n      row = Math.floor(slideIndexInGroup / columnsInGroup);\n      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n      newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n      slide2.style.order = newSlideOrderIndex;\n    } else if (fill === \"column\") {\n      column = Math.floor(i / rows);\n      row = i - column * rows;\n      if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n        row += 1;\n        if (row >= rows) {\n          row = 0;\n          column += 1;\n        }\n      }\n    } else {\n      row = Math.floor(i / slidesPerRow);\n      column = i - row * slidesPerRow;\n    }\n    slide2.row = row;\n    slide2.column = column;\n    slide2.style[getDirectionLabel(\"margin-top\")] = row !== 0 ? spaceBetween && `${spaceBetween}px` : \"\";\n  };\n  const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n    const {\n      centeredSlides,\n      roundLengths\n    } = swiper.params;\n    const spaceBetween = getSpaceBetween();\n    const {\n      rows\n    } = swiper.params.grid;\n    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n    swiper.wrapperEl.style[getDirectionLabel(\"width\")] = `${swiper.virtualSize + spaceBetween}px`;\n    if (centeredSlides) {\n      const newSlidesGrid = [];\n      for (let i = 0; i < snapGrid.length; i += 1) {\n        let slidesGridItem = snapGrid[i];\n        if (roundLengths)\n          slidesGridItem = Math.floor(slidesGridItem);\n        if (snapGrid[i] < swiper.virtualSize + snapGrid[0])\n          newSlidesGrid.push(slidesGridItem);\n      }\n      snapGrid.splice(0, snapGrid.length);\n      snapGrid.push(...newSlidesGrid);\n    }\n  };\n  swiper.grid = {\n    initSlides,\n    updateSlide,\n    updateWrapperSize\n  };\n}\nfunction appendSlide(slides) {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  const appendElement = (slideEl) => {\n    if (typeof slideEl === \"string\") {\n      const tempDOM = document.createElement(\"div\");\n      tempDOM.innerHTML = slideEl;\n      slidesEl.append(tempDOM.children[0]);\n      tempDOM.innerHTML = \"\";\n    } else {\n      slidesEl.append(slideEl);\n    }\n  };\n  if (typeof slides === \"object\" && \"length\" in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i])\n        appendElement(slides[i]);\n    }\n  } else {\n    appendElement(slides);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n}\nfunction prependSlide(slides) {\n  const swiper = this;\n  const {\n    params,\n    activeIndex,\n    slidesEl\n  } = swiper;\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndex + 1;\n  const prependElement = (slideEl) => {\n    if (typeof slideEl === \"string\") {\n      const tempDOM = document.createElement(\"div\");\n      tempDOM.innerHTML = slideEl;\n      slidesEl.prepend(tempDOM.children[0]);\n      tempDOM.innerHTML = \"\";\n    } else {\n      slidesEl.prepend(slideEl);\n    }\n  };\n  if (typeof slides === \"object\" && \"length\" in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i])\n        prependElement(slides[i]);\n    }\n    newActiveIndex = activeIndex + slides.length;\n  } else {\n    prependElement(slides);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  swiper.slideTo(newActiveIndex, 0, false);\n}\nfunction addSlide(index, slides) {\n  const swiper = this;\n  const {\n    params,\n    activeIndex,\n    slidesEl\n  } = swiper;\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.recalcSlides();\n  }\n  const baseLength = swiper.slides.length;\n  if (index <= 0) {\n    swiper.prependSlide(slides);\n    return;\n  }\n  if (index >= baseLength) {\n    swiper.appendSlide(slides);\n    return;\n  }\n  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n  const slidesBuffer = [];\n  for (let i = baseLength - 1; i >= index; i -= 1) {\n    const currentSlide = swiper.slides[i];\n    currentSlide.remove();\n    slidesBuffer.unshift(currentSlide);\n  }\n  if (typeof slides === \"object\" && \"length\" in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i])\n        slidesEl.append(slides[i]);\n    }\n    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n  } else {\n    slidesEl.append(slides);\n  }\n  for (let i = 0; i < slidesBuffer.length; i += 1) {\n    slidesEl.append(slidesBuffer[i]);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\nfunction removeSlide(slidesIndexes) {\n  const swiper = this;\n  const {\n    params,\n    activeIndex\n  } = swiper;\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndexBuffer;\n  let indexToRemove;\n  if (typeof slidesIndexes === \"object\" && \"length\" in slidesIndexes) {\n    for (let i = 0; i < slidesIndexes.length; i += 1) {\n      indexToRemove = slidesIndexes[i];\n      if (swiper.slides[indexToRemove])\n        swiper.slides[indexToRemove].remove();\n      if (indexToRemove < newActiveIndex)\n        newActiveIndex -= 1;\n    }\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  } else {\n    indexToRemove = slidesIndexes;\n    if (swiper.slides[indexToRemove])\n      swiper.slides[indexToRemove].remove();\n    if (indexToRemove < newActiveIndex)\n      newActiveIndex -= 1;\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\nfunction removeAllSlides() {\n  const swiper = this;\n  const slidesIndexes = [];\n  for (let i = 0; i < swiper.slides.length; i += 1) {\n    slidesIndexes.push(i);\n  }\n  swiper.removeSlide(slidesIndexes);\n}\nfunction Manipulation({\n  swiper\n}) {\n  Object.assign(swiper, {\n    appendSlide: appendSlide.bind(swiper),\n    prependSlide: prependSlide.bind(swiper),\n    addSlide: addSlide.bind(swiper),\n    removeSlide: removeSlide.bind(swiper),\n    removeAllSlides: removeAllSlides.bind(swiper)\n  });\n}\nfunction effectInit(params) {\n  const {\n    effect,\n    swiper,\n    on,\n    setTranslate: setTranslate2,\n    setTransition: setTransition2,\n    overwriteParams,\n    perspective,\n    recreateShadows,\n    getEffectParams\n  } = params;\n  on(\"beforeInit\", () => {\n    if (swiper.params.effect !== effect)\n      return;\n    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n    if (perspective && perspective()) {\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n    }\n    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n    Object.assign(swiper.params, overwriteParamsResult);\n    Object.assign(swiper.originalParams, overwriteParamsResult);\n  });\n  on(\"setTranslate\", () => {\n    if (swiper.params.effect !== effect)\n      return;\n    setTranslate2();\n  });\n  on(\"setTransition\", (_s, duration) => {\n    if (swiper.params.effect !== effect)\n      return;\n    setTransition2(duration);\n  });\n  on(\"transitionEnd\", () => {\n    if (swiper.params.effect !== effect)\n      return;\n    if (recreateShadows) {\n      if (!getEffectParams || !getEffectParams().slideShadows)\n        return;\n      swiper.slides.forEach((slideEl) => {\n        slideEl.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl) => shadowEl.remove());\n      });\n      recreateShadows();\n    }\n  });\n  let requireUpdateOnVirtual;\n  on(\"virtualUpdate\", () => {\n    if (swiper.params.effect !== effect)\n      return;\n    if (!swiper.slides.length) {\n      requireUpdateOnVirtual = true;\n    }\n    requestAnimationFrame(() => {\n      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n        setTranslate2();\n        requireUpdateOnVirtual = false;\n      }\n    });\n  });\n}\nfunction effectTarget(effectParams, slideEl) {\n  const transformEl = getSlideTransformEl(slideEl);\n  if (transformEl !== slideEl) {\n    transformEl.style.backfaceVisibility = \"hidden\";\n    transformEl.style[\"-webkit-backface-visibility\"] = \"hidden\";\n  }\n  return transformEl;\n}\nfunction effectVirtualTransitionEnd({\n  swiper,\n  duration,\n  transformElements,\n  allSlides\n}) {\n  const {\n    activeIndex\n  } = swiper;\n  const getSlide = (el) => {\n    if (!el.parentElement) {\n      const slide2 = swiper.slides.filter((slideEl) => slideEl.shadowEl && slideEl.shadowEl === el.parentNode)[0];\n      return slide2;\n    }\n    return el.parentElement;\n  };\n  if (swiper.params.virtualTranslate && duration !== 0) {\n    let eventTriggered = false;\n    let transitionEndTarget;\n    if (allSlides) {\n      transitionEndTarget = transformElements;\n    } else {\n      transitionEndTarget = transformElements.filter((transformEl) => {\n        const el = transformEl.classList.contains(\"swiper-slide-transform\") ? getSlide(transformEl) : transformEl;\n        return swiper.getSlideIndex(el) === activeIndex;\n      });\n    }\n    transitionEndTarget.forEach((el) => {\n      elementTransitionEnd(el, () => {\n        if (eventTriggered)\n          return;\n        if (!swiper || swiper.destroyed)\n          return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const evt = new window.CustomEvent(\"transitionend\", {\n          bubbles: true,\n          cancelable: true\n        });\n        swiper.wrapperEl.dispatchEvent(evt);\n      });\n    });\n  }\n}\nfunction EffectFade({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    fadeEffect: {\n      crossFade: false\n    }\n  });\n  const setTranslate2 = () => {\n    const {\n      slides\n    } = swiper;\n    const params = swiper.params.fadeEffect;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = swiper.slides[i];\n      const offset = slideEl.swiperSlideOffset;\n      let tx = -offset;\n      if (!swiper.params.virtualTranslate)\n        tx -= swiper.translate;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n      }\n      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.opacity = slideOpacity;\n      targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n    }\n  };\n  const setTransition2 = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n    });\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements,\n      allSlides: true\n    });\n  };\n  effectInit({\n    effect: \"fade\",\n    swiper,\n    on,\n    setTranslate: setTranslate2,\n    setTransition: setTransition2,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\nfunction EffectCube({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    cubeEffect: {\n      slideShadows: true,\n      shadow: true,\n      shadowOffset: 20,\n      shadowScale: 0.94\n    }\n  });\n  const createSlideShadows = (slideEl, progress, isHorizontal) => {\n    let shadowBefore = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n    let shadowAfter = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n    if (!shadowBefore) {\n      shadowBefore = createElement(\"div\", `swiper-slide-shadow-${isHorizontal ? \"left\" : \"top\"}`);\n      slideEl.append(shadowBefore);\n    }\n    if (!shadowAfter) {\n      shadowAfter = createElement(\"div\", `swiper-slide-shadow-${isHorizontal ? \"right\" : \"bottom\"}`);\n      slideEl.append(shadowAfter);\n    }\n    if (shadowBefore)\n      shadowBefore.style.opacity = Math.max(-progress, 0);\n    if (shadowAfter)\n      shadowAfter.style.opacity = Math.max(progress, 0);\n  };\n  const recreateShadows = () => {\n    const isHorizontal = swiper.isHorizontal();\n    swiper.slides.forEach((slideEl) => {\n      const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      createSlideShadows(slideEl, progress, isHorizontal);\n    });\n  };\n  const setTranslate2 = () => {\n    const {\n      el,\n      wrapperEl,\n      slides,\n      width: swiperWidth,\n      height: swiperHeight,\n      rtlTranslate: rtl,\n      size: swiperSize,\n      browser: browser2\n    } = swiper;\n    const params = swiper.params.cubeEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let wrapperRotate = 0;\n    let cubeShadowEl;\n    if (params.shadow) {\n      if (isHorizontal) {\n        cubeShadowEl = swiper.slidesEl.querySelector(\".swiper-cube-shadow\");\n        if (!cubeShadowEl) {\n          cubeShadowEl = createElement(\"div\", \"swiper-cube-shadow\");\n          swiper.slidesEl.append(cubeShadowEl);\n        }\n        cubeShadowEl.style.height = `${swiperWidth}px`;\n      } else {\n        cubeShadowEl = el.querySelector(\".swiper-cube-shadow\");\n        if (!cubeShadowEl) {\n          cubeShadowEl = createElement(\"div\", \"swiper-cube-shadow\");\n          el.append(cubeShadowEl);\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      let slideIndex = i;\n      if (isVirtual) {\n        slideIndex = parseInt(slideEl.getAttribute(\"data-swiper-slide-index\"), 10);\n      }\n      let slideAngle = slideIndex * 90;\n      let round = Math.floor(slideAngle / 360);\n      if (rtl) {\n        slideAngle = -slideAngle;\n        round = Math.floor(-slideAngle / 360);\n      }\n      const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      let tx = 0;\n      let ty = 0;\n      let tz = 0;\n      if (slideIndex % 4 === 0) {\n        tx = -round * 4 * swiperSize;\n        tz = 0;\n      } else if ((slideIndex - 1) % 4 === 0) {\n        tx = 0;\n        tz = -round * 4 * swiperSize;\n      } else if ((slideIndex - 2) % 4 === 0) {\n        tx = swiperSize + round * 4 * swiperSize;\n        tz = swiperSize;\n      } else if ((slideIndex - 3) % 4 === 0) {\n        tx = -swiperSize;\n        tz = 3 * swiperSize + swiperSize * 4 * round;\n      }\n      if (rtl) {\n        tx = -tx;\n      }\n      if (!isHorizontal) {\n        ty = tx;\n        tx = 0;\n      }\n      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n      if (progress <= 1 && progress > -1) {\n        wrapperRotate = slideIndex * 90 + progress * 90;\n        if (rtl)\n          wrapperRotate = -slideIndex * 90 - progress * 90;\n      }\n      slideEl.style.transform = transform;\n      if (params.slideShadows) {\n        createSlideShadows(slideEl, progress, isHorizontal);\n      }\n    }\n    wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n    wrapperEl.style[\"-webkit-transform-origin\"] = `50% 50% -${swiperSize / 2}px`;\n    if (params.shadow) {\n      if (isHorizontal) {\n        cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;\n      } else {\n        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n        const scale1 = params.shadowScale;\n        const scale2 = params.shadowScale / multiplier;\n        const offset = params.shadowOffset;\n        cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n      }\n    }\n    const zFactor = (browser2.isSafari || browser2.isWebView) && browser2.needPerspectiveFix ? -swiperSize / 2 : 0;\n    wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n    wrapperEl.style.setProperty(\"--swiper-cube-translate-z\", `${zFactor}px`);\n  };\n  const setTransition2 = (duration) => {\n    const {\n      el,\n      slides\n    } = swiper;\n    slides.forEach((slideEl) => {\n      slideEl.style.transitionDuration = `${duration}ms`;\n      slideEl.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((subEl) => {\n        subEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n      const shadowEl = el.querySelector(\".swiper-cube-shadow\");\n      if (shadowEl)\n        shadowEl.style.transitionDuration = `${duration}ms`;\n    }\n  };\n  effectInit({\n    effect: \"cube\",\n    swiper,\n    on,\n    setTranslate: setTranslate2,\n    setTransition: setTransition2,\n    recreateShadows,\n    getEffectParams: () => swiper.params.cubeEffect,\n    perspective: () => true,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      resistanceRatio: 0,\n      spaceBetween: 0,\n      centeredSlides: false,\n      virtualTranslate: true\n    })\n  });\n}\nfunction createShadow(params, slideEl, side) {\n  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : \"\"}`;\n  const shadowContainer = getSlideTransformEl(slideEl);\n  let shadowEl = shadowContainer.querySelector(`.${shadowClass}`);\n  if (!shadowEl) {\n    shadowEl = createElement(\"div\", `swiper-slide-shadow${side ? `-${side}` : \"\"}`);\n    shadowContainer.append(shadowEl);\n  }\n  return shadowEl;\n}\nfunction EffectFlip({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    flipEffect: {\n      slideShadows: true,\n      limitRotation: true\n    }\n  });\n  const createSlideShadows = (slideEl, progress, params) => {\n    let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n    let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n    if (!shadowBefore) {\n      shadowBefore = createShadow(params, slideEl, swiper.isHorizontal() ? \"left\" : \"top\");\n    }\n    if (!shadowAfter) {\n      shadowAfter = createShadow(params, slideEl, swiper.isHorizontal() ? \"right\" : \"bottom\");\n    }\n    if (shadowBefore)\n      shadowBefore.style.opacity = Math.max(-progress, 0);\n    if (shadowAfter)\n      shadowAfter.style.opacity = Math.max(progress, 0);\n  };\n  const recreateShadows = () => {\n    const params = swiper.params.flipEffect;\n    swiper.slides.forEach((slideEl) => {\n      let progress = slideEl.progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      }\n      createSlideShadows(slideEl, progress, params);\n    });\n  };\n  const setTranslate2 = () => {\n    const {\n      slides,\n      rtlTranslate: rtl\n    } = swiper;\n    const params = swiper.params.flipEffect;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      let progress = slideEl.progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      }\n      const offset = slideEl.swiperSlideOffset;\n      const rotate = -180 * progress;\n      let rotateY = rotate;\n      let rotateX = 0;\n      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n        rotateX = -rotateY;\n        rotateY = 0;\n      } else if (rtl) {\n        rotateY = -rotateY;\n      }\n      slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n      if (params.slideShadows) {\n        createSlideShadows(slideEl, progress, params);\n      }\n      const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n    }\n  };\n  const setTransition2 = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl) => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements\n    });\n  };\n  effectInit({\n    effect: \"flip\",\n    swiper,\n    on,\n    setTranslate: setTranslate2,\n    setTransition: setTransition2,\n    recreateShadows,\n    getEffectParams: () => swiper.params.flipEffect,\n    perspective: () => true,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\nfunction EffectCoverflow({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    coverflowEffect: {\n      rotate: 50,\n      stretch: 0,\n      depth: 100,\n      scale: 1,\n      modifier: 1,\n      slideShadows: true\n    }\n  });\n  const setTranslate2 = () => {\n    const {\n      width: swiperWidth,\n      height: swiperHeight,\n      slides,\n      slidesSizesGrid\n    } = swiper;\n    const params = swiper.params.coverflowEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const transform = swiper.translate;\n    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n    const rotate = isHorizontal ? params.rotate : -params.rotate;\n    const translate2 = params.depth;\n    for (let i = 0, length = slides.length; i < length; i += 1) {\n      const slideEl = slides[i];\n      const slideSize = slidesSizesGrid[i];\n      const slideOffset = slideEl.swiperSlideOffset;\n      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n      const offsetMultiplier = typeof params.modifier === \"function\" ? params.modifier(centerOffset) : centerOffset * params.modifier;\n      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n      let translateZ = -translate2 * Math.abs(offsetMultiplier);\n      let stretch = params.stretch;\n      if (typeof stretch === \"string\" && stretch.indexOf(\"%\") !== -1) {\n        stretch = parseFloat(params.stretch) / 100 * slideSize;\n      }\n      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n      if (Math.abs(translateX) < 1e-3)\n        translateX = 0;\n      if (Math.abs(translateY) < 1e-3)\n        translateY = 0;\n      if (Math.abs(translateZ) < 1e-3)\n        translateZ = 0;\n      if (Math.abs(rotateY) < 1e-3)\n        rotateY = 0;\n      if (Math.abs(rotateX) < 1e-3)\n        rotateX = 0;\n      if (Math.abs(scale) < 1e-3)\n        scale = 0;\n      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = slideTransform;\n      slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n      if (params.slideShadows) {\n        let shadowBeforeEl = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n        let shadowAfterEl = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n        if (!shadowBeforeEl) {\n          shadowBeforeEl = createShadow(params, slideEl, isHorizontal ? \"left\" : \"top\");\n        }\n        if (!shadowAfterEl) {\n          shadowAfterEl = createShadow(params, slideEl, isHorizontal ? \"right\" : \"bottom\");\n        }\n        if (shadowBeforeEl)\n          shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n        if (shadowAfterEl)\n          shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n      }\n    }\n  };\n  const setTransition2 = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl) => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n  };\n  effectInit({\n    effect: \"coverflow\",\n    swiper,\n    on,\n    setTranslate: setTranslate2,\n    setTransition: setTransition2,\n    perspective: () => true,\n    overwriteParams: () => ({\n      watchSlidesProgress: true\n    })\n  });\n}\nfunction EffectCreative({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    creativeEffect: {\n      limitProgress: 1,\n      shadowPerProgress: false,\n      progressMultiplier: 1,\n      perspective: true,\n      prev: {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        opacity: 1,\n        scale: 1\n      },\n      next: {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        opacity: 1,\n        scale: 1\n      }\n    }\n  });\n  const getTranslateValue = (value) => {\n    if (typeof value === \"string\")\n      return value;\n    return `${value}px`;\n  };\n  const setTranslate2 = () => {\n    const {\n      slides,\n      wrapperEl,\n      slidesSizesGrid\n    } = swiper;\n    const params = swiper.params.creativeEffect;\n    const {\n      progressMultiplier: multiplier\n    } = params;\n    const isCenteredSlides = swiper.params.centeredSlides;\n    if (isCenteredSlides) {\n      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n      wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      const slideProgress = slideEl.progress;\n      const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n      let originalProgress = progress;\n      if (!isCenteredSlides) {\n        originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n      }\n      const offset = slideEl.swiperSlideOffset;\n      const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n      const r = [0, 0, 0];\n      let custom = false;\n      if (!swiper.isHorizontal()) {\n        t[1] = t[0];\n        t[0] = 0;\n      }\n      let data = {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        scale: 1,\n        opacity: 1\n      };\n      if (progress < 0) {\n        data = params.next;\n        custom = true;\n      } else if (progress > 0) {\n        data = params.prev;\n        custom = true;\n      }\n      t.forEach((value, index) => {\n        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n      });\n      r.forEach((value, index) => {\n        r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n      });\n      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n      const translateString = t.join(\", \");\n      const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n      const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n      const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n      const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n      if (custom && data.shadow || !custom) {\n        let shadowEl = slideEl.querySelector(\".swiper-slide-shadow\");\n        if (!shadowEl && data.shadow) {\n          shadowEl = createShadow(params, slideEl);\n        }\n        if (shadowEl) {\n          const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n          shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n        }\n      }\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n      targetEl.style.opacity = opacityString;\n      if (data.origin) {\n        targetEl.style.transformOrigin = data.origin;\n      }\n    }\n  };\n  const setTransition2 = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll(\".swiper-slide-shadow\").forEach((shadowEl) => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements,\n      allSlides: true\n    });\n  };\n  effectInit({\n    effect: \"creative\",\n    swiper,\n    on,\n    setTranslate: setTranslate2,\n    setTransition: setTransition2,\n    perspective: () => swiper.params.creativeEffect.perspective,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\nfunction EffectCards({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    cardsEffect: {\n      slideShadows: true,\n      rotate: true,\n      perSlideRotate: 2,\n      perSlideOffset: 8\n    }\n  });\n  const setTranslate2 = () => {\n    const {\n      slides,\n      activeIndex,\n      rtlTranslate: rtl\n    } = swiper;\n    const params = swiper.params.cardsEffect;\n    const {\n      startTranslate,\n      isTouched\n    } = swiper.touchEventsData;\n    const currentTranslate = rtl ? -swiper.translate : swiper.translate;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      const slideProgress = slideEl.progress;\n      const progress = Math.min(Math.max(slideProgress, -4), 4);\n      let offset = slideEl.swiperSlideOffset;\n      if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n        swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n      }\n      if (swiper.params.centeredSlides && swiper.params.cssMode) {\n        offset -= slides[0].swiperSlideOffset;\n      }\n      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n      let tY = 0;\n      const tZ = -100 * Math.abs(progress);\n      let scale = 1;\n      let rotate = -params.perSlideRotate * progress;\n      let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n      const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n      const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n      const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n      if (isSwipeToNext || isSwipeToPrev) {\n        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n        rotate += -28 * progress * subProgress;\n        scale += -0.5 * subProgress;\n        tXAdd += 96 * subProgress;\n        tY = `${-25 * subProgress * Math.abs(progress)}%`;\n      }\n      if (progress < 0) {\n        tX = `calc(${tX}px ${rtl ? \"-\" : \"+\"} (${tXAdd * Math.abs(progress)}%))`;\n      } else if (progress > 0) {\n        tX = `calc(${tX}px ${rtl ? \"-\" : \"+\"} (-${tXAdd * Math.abs(progress)}%))`;\n      } else {\n        tX = `${tX}px`;\n      }\n      if (!swiper.isHorizontal()) {\n        const prevY = tY;\n        tY = tX;\n        tX = prevY;\n      }\n      const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n      const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)\n        scale(${scaleString})\n      `;\n      if (params.slideShadows) {\n        let shadowEl = slideEl.querySelector(\".swiper-slide-shadow\");\n        if (!shadowEl) {\n          shadowEl = createShadow(params, slideEl);\n        }\n        if (shadowEl)\n          shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n      }\n      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n    }\n  };\n  const setTransition2 = (duration) => {\n    const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n    transformElements.forEach((el) => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll(\".swiper-slide-shadow\").forEach((shadowEl) => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements\n    });\n  };\n  effectInit({\n    effect: \"cards\",\n    swiper,\n    on,\n    setTranslate: setTranslate2,\n    setTransition: setTransition2,\n    perspective: () => true,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  try {\n    customTitle();\n    new Swiper(\".tmpl_hh_aside__slider .swiper\", {\n      loop: true,\n      modules: [Navigation],\n      spaceBetween: 10,\n      breakpoints: {\n        768: {\n          slidesPerView: 3\n        },\n        320: {\n          slidesPerView: 1\n        }\n      },\n      navigation: {\n        nextEl: \".tmpl_hh_aside__slider .swiper-button-next\",\n        prevEl: \".tmpl_hh_aside__slider .swiper-button-prev\"\n      }\n    });\n  } catch (error) {\n    console.log(error);\n  }\n});\n\n\n//\n</script>\n",
  "vacancy_constructor_template": null,
  "key_skills": [],
  "accept_handicapped": false,
  "accept_kids": false,
  "archived": false,
  "response_url": null,
  "specializations": [],
  "professional_roles": [
    {
      "id": "165",
      "name": "Дата-сайентист"
    }
  ],
  "code": null,
  "hidden": false,
  "quick_responses_allowed": false,
  "driver_license_types": [],
  "accept_incomplete_resumes": false,
  "employer": {
    "id": "1516420",
    "name": "Lime Credit Group",
    "url": "https://api.hh.ru/employers/1516420",
    "alternate_url": "https://hh.ru/employer/1516420",
    "logo_urls": {
      "original": "https://img.hhcdn.ru/employer-logo-original/1388130.png",
      "90": "https://img.hhcdn.ru/employer-logo/7172307.png",
      "240": "https://img.hhcdn.ru/employer-logo/7172308.png"
    },
    "vacancies_url": "https://api.hh.ru/vacancies?employer_id=1516420",
    "accredited_it_employer": false,
    "trusted": true
  },
  "published_at": "2025-05-23T12:59:22+0300",
  "created_at": "2025-05-23T12:59:22+0300",
  "initial_created_at": "2025-05-23T12:59:22+0300",
  "negotiations_url": null,
  "suitable_resumes_url": null,
  "apply_alternate_url": "https://hh.ru/applicant/vacancy_response?vacancyId=120906838",
  "has_test": false,
  "test": null,
  "alternate_url": "https://hh.ru/vacancy/120906838",
  "working_days": [],
  "working_time_intervals": [],
  "working_time_modes": [],
  "accept_temporary": false,
  "languages": [],
  "approved": true,
  "employment_form": {
    "id": "FULL",
    "name": "Полная"
  },
  "fly_in_fly_out_duration": [],
  "internship": false,
  "night_shifts": false,
  "work_format": [
    {
      "id": "ON_SITE",
      "name": "На месте работодателя"
    },
    {
      "id": "REMOTE",
      "name": "Удалённо"
    },
    {
      "id": "HYBRID",
      "name": "Гибрид"
    }
  ],
  "work_schedule_by_days": [
    {
      "id": "FIVE_ON_TWO_OFF",
      "name": "5/2"
    }
  ],
  "working_hours": [
    {
      "id": "HOURS_8",
      "name": "8 часов"
    }
  ],
  "show_logo_in_search": true
}
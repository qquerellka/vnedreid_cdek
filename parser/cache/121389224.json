{
  "id": "121389224",
  "premium": false,
  "billing_type": {
    "id": "standard",
    "name": "Стандарт"
  },
  "relations": [],
  "name": "Системный аналитик ЦФТ (Кредиты ФЛ)",
  "insider_interview": null,
  "response_letter_required": false,
  "area": {
    "id": "4",
    "name": "Новосибирск",
    "url": "https://api.hh.ru/areas/4"
  },
  "salary": null,
  "salary_range": null,
  "type": {
    "id": "open",
    "name": "Открытая"
  },
  "address": null,
  "allow_messages": true,
  "experience": {
    "id": "between3And6",
    "name": "От 3 до 6 лет"
  },
  "schedule": {
    "id": "remote",
    "name": "Удаленная работа"
  },
  "employment": {
    "id": "full",
    "name": "Полная занятость"
  },
  "department": {
    "id": "4649269-4649269-innoteh",
    "name": "Т1 Иннотех"
  },
  "show_contacts": false,
  "contacts": null,
  "description": "<p>Стрим <strong>&quot;Кредиты и документарные операции ФЛ&quot;</strong> отвечает за поддержку бизнеса по кредитным продуктам ФЛ и расчетам с использованием аккредитивов ФЛ и счетов эскроу ФЛ.<br />Сейчас в рамках импортозамещения мы начинаем масштабный проект по отказу от легаси-систем на основе Oracle. Наши команды будут формировать будущую банковскую микросервисную архитектуру.</p> <p><strong>Обязанности:</strong></p> <ul> <li>Выявление, описание и согласование требований к локальным и интеграционным доработкам по продукту &quot;Кредит ФЛ&quot;;</li> <li>Участие и помощь в тестировании, в т.ч. участие в организации интеграционных решений;</li> <li>Описание требований к информационной системе (ТИС) и требования к решению (ТР);</li> <li>Выявлять зависимости и адаптировать свои сервисы под планируемые изменения;</li> <li>Проводить показы, формировать протокол и его согласовывать;</li> <li>Моделировать сервисы, в т. ч. с помощью технологической схемы (BPMN);</li> <li>Выполнять настройки на тестовых контурах по продукту «Кредит ФЛ»</li> <li>Анализировать дефекты ПРОМ, ПСИ, ИФТ, предлагать варианты исправления;</li> </ul> <p><strong>Требования:</strong></p> <ul> <li>Знание АБС ЦФТ-Банк (IBSO) - УЯ, Кредиты, РКО или понимание деталей банковских бизнес процессов, объектов АБС (кредиты, вклады, расчеты, закрытие ОД - подтвержденный опыт;</li> <li>Знание всех основных бэковых кредитных процессов и операций в разрезе жизни кредита (выдача, погашение, учет, резервирование и т.д.);</li> <li>Понимание бизнес-процессов на уровне структур таблиц (ERD);</li> <li>Умение читать SQL код, делать не сложные запросы. (Oracle, PostgreSQL);</li> <li>Навык создания/согласования аналитической документации, описания БП, использования различных нотаций (BPMN, UML+ERD);</li> <li>Знание основных видов интеграционных взаимодействий - JSON, Rabbit, файловый обмен и т.д.;</li> <li>Понимание принципов монолитной и микросервисной архитектуры;</li> <li>Опыт участия в проектах интеграции крупных подсистем (АБС, CRM, Front) - большой плюс;</li> <li>Опыт работы со структурами XML;</li> <li>Опыт работы с Jira, Confluence.</li> </ul>",
  "branded_description": "\n  <style>\n    /** @format */\n    .hht-vacancydescription {\n      padding: 0;\n    }\n    .tmpl_hh_wrapper {\n      width: 100%;\n      margin: 0 auto;\n      max-width: 690px;\n      position: relative;\n      word-break: normal;\n      overflow: hidden;\n      font-weight: 400;\n      font-size: 16px;\n      line-height: 22px;\n      letter-spacing: 0.01em;\n      z-index: 1;\n    }\n    @media (max-width: 1019px) {\n      .tmpl_hh_wrapper {\n        max-width: 610px;\n      }\n    }\n    .tmpl_hh_wrapper p,\n    .tmpl_hh_wrapper h1,\n    .tmpl_hh_wrapper h2,\n    .tmpl_hh_wrapper h3,\n    .tmpl_hh_wrapper h4,\n    .tmpl_hh_wrapper h5,\n    .tmpl_hh_wrapper h6,\n    .tmpl_hh_wrapper a,\n    .tmpl_hh_wrapper img,\n    .tmpl_hh_wrapper ol,\n    .tmpl_hh_wrapper ul,\n    .tmpl_hh_wrapper li {\n      margin: 0;\n      padding: 0;\n      border: 0;\n      font: inherit;\n      vertical-align: baseline;\n    }\n    .tmpl_hh_wrapper ul {\n      list-style: none;\n    }\n    .tmpl_hh_wrapper a {\n      text-decoration: none;\n    }\n    .tmpl_hh_wrapper a:hover {\n      color: inherit;\n    }\n    .tmpl_hh_wrapper img {\n      display: block;\n    }\n    .tmpl_hh_wrapper button {\n      display: block;\n      border: none;\n      background-color: transparent;\n      cursor: pointer;\n      outline: none;\n      padding: 0;\n    }\n    .tmpl_hh_wrapper button svg {\n      cursor: pointer;\n    }\n    .tmpl_hh_wrapper .l-cell,\n    .tmpl_hh_wrapper .l-paddings {\n      padding: 0 !important;\n    }\n    .tmpl_hh_wrapper .b-vacancy-desc-wrapper {\n      margin-top: 0 !important;\n    }\n    .tmpl_hh_wrapper .b-vacancy-desc {\n      overflow: visible !important;\n      line-height: inherit;\n    }\n    .tmpl_hh_content ol li b,\n    .tmpl_hh_content ol li strong,\n    .tmpl_hh_content ol li p b,\n    .tmpl_hh_content ol li p strong,\n    .tmpl_hh_content ul li b,\n    .tmpl_hh_content ul li strong,\n    .tmpl_hh_content ul li p b,\n    .tmpl_hh_content ul li p strong {\n      font-weight: normal;\n      font-size: inherit !important;\n      color: inherit !important;\n      margin: 0 !important;\n      text-transform: none;\n      line-height: inherit;\n    }\n    .tmpl_hh_content ol li p,\n    .tmpl_hh_content ul li p {\n      font-weight: normal;\n      margin: 0;\n    }\n    .tmpl_hh_content p {\n      margin-bottom: 16px;\n    }\n    .tmpl_hh_content p b,\n    .tmpl_hh_content p strong {\n      display: inline;\n      margin: 0;\n    }\n    .tmpl_hh_content ol,\n    .tmpl_hh_content ul {\n      margin-left: 18px;\n      margin-bottom: 32px;\n      list-style: none !important;\n    }\n    .tmpl_hh_content ol {\n      counter-reset: list_counter;\n    }\n    .tmpl_hh_content li {\n      position: relative;\n      margin-bottom: 8px;\n      font-size: 16px;\n    }\n    .tmpl_hh_content li:last-child {\n      margin-bottom: 0;\n    }\n    .tmpl_hh_content ul ul,\n    .tmpl_hh_content ul ol,\n    .tmpl_hh_content ol ol,\n    .tmpl_hh_content ol ul {\n      margin-top: 14px;\n    }\n    .tmpl_hh_content ol > li {\n      counter-increment: list_counter;\n    }\n    .tmpl_hh_content ul > li:before {\n      content: \"\";\n      background-image: url(\"https://hhcdn.ru/ichameleon/362428.svg\");\n      background-repeat: no-repeat;\n      background-size: 100% auto;\n      background-position: center;\n      position: absolute;\n      top: 4px;\n      left: -18px;\n      width: 10px;\n      height: 10px;\n    }\n    .tmpl_hh_content ol > li::before {\n      content: counter(list_counter) \".\";\n      right: 100%;\n      left: auto;\n      margin-right: 2px;\n    }\n    .tmpl_hh_content ol > li:before {\n      content: counter(list_counter) \".\";\n      left: auto;\n      right: 100%;\n      margin-right: 2px;\n    }\n    .tmpl_hh_content :last-child {\n      margin-bottom: 0;\n    }\n    /* stylelint-disable block-no-empty */\n    /* stylelint-enable block-no-empty */\n    .tmpl_hh_wrapper {\n      box-sizing: border-box;\n      color: #030126;\n      font-size: 18px;\n      font-family: Arial, sans-serif;\n      line-height: 27px;\n    }\n    .tmpl_hh_wrapper .tmpl_hh_designation {\n      color: #c1c3c7;\n      font-size: 14px;\n      line-height: 20px;\n    }\n    .tmpl_hh_flex {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n    }\n    .tmpl_hh_header {\n      display: flex;\n      flex-wrap: wrap;\n      align-content: space-between;\n      box-sizing: border-box;\n      height: 369px;\n      padding: 25px 30px 30px;\n      border-radius: 5px 5px 0 0;\n      background: url(\"https://hhcdn.ru/ichameleon/362400.jpg\") center/cover\n        no-repeat;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_header {\n        height: auto;\n        padding: 15px 20px 20px;\n      }\n    }\n    .tmpl_hh_header-title {\n      width: 94%;\n      height: auto;\n      max-width: 630px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_header-title {\n        width: auto;\n        margin-bottom: 170px;\n      }\n    }\n    .tmpl_hh_header > p {\n      width: 100%;\n      color: #fff;\n      font-size: 16px;\n      line-height: 120%;\n    }\n    .tmpl_hh_aside-first {\n      padding: 50px 30px 25px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-first {\n        padding: 50px 20px;\n      }\n    }\n    .tmpl_hh_aside-first > h2 {\n      margin-bottom: 30px;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-first > h2 {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_aside-first > ul {\n      display: flex;\n      gap: 10px;\n      margin-bottom: 20px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-first > ul {\n        flex-wrap: wrap;\n      }\n    }\n    .tmpl_hh_aside-first > ul > li {\n      display: flex;\n      flex-grow: 1;\n      flex-direction: column;\n      gap: 20px;\n      box-sizing: border-box;\n      width: 33%;\n      padding: 15px;\n      border-radius: 10px;\n      background: #ecf0ff;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-first > ul > li {\n        width: 100%;\n      }\n    }\n    .tmpl_hh_aside-first > ul > li > img {\n      width: 120px;\n      height: 88px;\n    }\n    .tmpl_hh_aside-first > ul > li > p {\n      font-size: 16px;\n      line-height: 130%;\n    }\n    .tmpl_hh_aside-first-ft {\n      display: flex;\n      flex-direction: column;\n      gap: 5px;\n      margin-bottom: 30px;\n      color: #c1c3c7;\n      font-size: 13px;\n      line-height: 115%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-first-ft {\n        font-size: 14px;\n      }\n    }\n    .tmpl_hh_aside-first-ft > p:last-of-type {\n      padding-left: 5px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-first-ft > p:last-of-type {\n        padding: 0;\n      }\n    }\n    .tmpl_hh_aside-first-text {\n      display: flex;\n      flex-direction: column;\n      gap: 30px;\n      font-size: 16px;\n      line-height: 120%;\n    }\n    .tmpl_hh_aside-first-text > p:last-of-type {\n      margin-top: -10px;\n    }\n    .tmpl_hh_aside-second {\n      padding: 25px 30px 50px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second {\n        padding: 50px 20px;\n      }\n    }\n    .tmpl_hh_aside-second > h3 {\n      margin-bottom: 30px;\n      color: #00aae6;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second > h3 {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_aside-second > p {\n      margin-bottom: 30px;\n      font-size: 16px;\n      line-height: 130%;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper {\n      margin-top: 50px;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__slide {\n      width: 100%;\n      padding-top: 49.2063492063%;\n      border-radius: 15px;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__slide-1 {\n      background: url(\"https://hhcdn.ru/ichameleon/332876.png\") center/contain\n        no-repeat;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__slide-2 {\n      background: url(\"https://hhcdn.ru/ichameleon/332877.png\") center/contain\n        no-repeat;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__slide-3 {\n      background: url(\"https://hhcdn.ru/ichameleon/332878.png\") center/contain\n        no-repeat;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__slide-4 {\n      background: url(\"https://hhcdn.ru/ichameleon/332879.png\") center/contain\n        no-repeat;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__slide-5 {\n      background: url(\"https://img.hhcdn.ru/ichameleon/439866.png\")\n        center/contain no-repeat;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__btns {\n      position: absolute;\n      top: 0;\n      left: 0;\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      width: 100%;\n      height: 100%;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__button-prev,\n    .tmpl_hh_aside-second .tmpl_hh_swiper__button-next {\n      position: relative;\n      z-index: 9;\n      width: 32px;\n      height: 32px;\n      margin: 0 20px;\n      background: url(\"https://hhcdn.ru/ichameleon/332872.png\") center/contain\n        no-repeat;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second .tmpl_hh_swiper__button-prev,\n      .tmpl_hh_aside-second .tmpl_hh_swiper__button-next {\n        width: 18px;\n        height: 18px;\n        margin: 0 10px;\n      }\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__button-next {\n      background: url(\"https://hhcdn.ru/ichameleon/332873.png\") center/contain\n        no-repeat;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__pagination {\n      position: absolute;\n      bottom: 20px;\n      left: 0;\n      display: flex;\n      gap: 10px;\n      justify-content: center;\n      width: 100%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second .tmpl_hh_swiper__pagination {\n        bottom: 10px;\n      }\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__pagination-bullet {\n      position: relative;\n      z-index: 9;\n      width: 50px;\n      height: 5px;\n      border-radius: 100px;\n      background: #fff;\n      cursor: pointer;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second .tmpl_hh_swiper__pagination-bullet {\n        width: 28px;\n        height: 2px;\n        border-radius: 50px;\n      }\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__pagination-bullet-active {\n      background: #00aae6;\n    }\n    .tmpl_hh_aside-second > ul {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 20px;\n    }\n    .tmpl_hh_aside-second > ul > li {\n      display: flex;\n      flex-grow: 1;\n      flex-direction: column;\n      gap: 15px;\n      width: calc(50% - 20px);\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second > ul > li {\n        width: 100%;\n      }\n    }\n    .tmpl_hh_aside-second > ul > li > img {\n      width: 62px;\n      height: 62px;\n    }\n    .tmpl_hh_aside-second > ul > li > p {\n      color: #8a9aaa;\n      font-size: 14px;\n      line-height: 115%;\n    }\n    .tmpl_hh_aside-second > ul > li > p > b {\n      color: #030126;\n      font-size: 16px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second > ul > li > p br {\n        display: none;\n      }\n    }\n    .tmpl_hh_content {\n      padding-right: 30px;\n      padding-left: 30px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_content {\n        padding-right: 20px;\n        padding-left: 20px;\n      }\n    }\n    .tmpl_hh_content p.tmpl_hh_content_vacancy-title {\n      margin-bottom: 30px;\n      color: #00aae6;\n      font-weight: 700;\n      font-style: normal;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_content p.tmpl_hh_content_vacancy-title {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_content p.tmpl_hh_content_title,\n    .tmpl_hh_content b.tmpl_hh_content_title,\n    .tmpl_hh_content strong.tmpl_hh_content_title {\n      margin-bottom: 24px;\n      color: #00aae6;\n      font-weight: 700;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_content p.tmpl_hh_content_title,\n      .tmpl_hh_content b.tmpl_hh_content_title,\n      .tmpl_hh_content strong.tmpl_hh_content_title {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_content p.tmpl_hh_content_title > em,\n    .tmpl_hh_content p.tmpl_hh_content_title > i,\n    .tmpl_hh_content b.tmpl_hh_content_title > em,\n    .tmpl_hh_content b.tmpl_hh_content_title > i,\n    .tmpl_hh_content strong.tmpl_hh_content_title > em,\n    .tmpl_hh_content strong.tmpl_hh_content_title > i {\n      font-style: normal;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_content p.tmpl_hh_content_title > em,\n      .tmpl_hh_content p.tmpl_hh_content_title > i,\n      .tmpl_hh_content b.tmpl_hh_content_title > em,\n      .tmpl_hh_content b.tmpl_hh_content_title > i,\n      .tmpl_hh_content strong.tmpl_hh_content_title > em,\n      .tmpl_hh_content strong.tmpl_hh_content_title > i {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_content p.tmpl_hh_content_title > b,\n    .tmpl_hh_content p.tmpl_hh_content_title > strong {\n      color: #00aae6;\n      font-weight: 700;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_content p.tmpl_hh_content_title > b,\n      .tmpl_hh_content p.tmpl_hh_content_title > strong {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_content p.tmpl_hh_content_title > b > em,\n    .tmpl_hh_content p.tmpl_hh_content_title > b > i,\n    .tmpl_hh_content p.tmpl_hh_content_title > strong > em,\n    .tmpl_hh_content p.tmpl_hh_content_title > strong > i {\n      font-style: normal;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_content p.tmpl_hh_content_title > b > em,\n      .tmpl_hh_content p.tmpl_hh_content_title > b > i,\n      .tmpl_hh_content p.tmpl_hh_content_title > strong > em,\n      .tmpl_hh_content p.tmpl_hh_content_title > strong > i {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_content p {\n      margin-bottom: 20px;\n      font-size: 16px;\n      line-height: 120%;\n    }\n    .tmpl_hh_content ul {\n      margin: 24px 0 30px 18px;\n    }\n    .tmpl_hh_content li {\n      margin-bottom: 24px;\n      font-size: 16px;\n      line-height: 120%;\n    }\n\n    .tmpl_hh_footer {\n      box-sizing: border-box;\n      padding: 20px 30px;\n      border-radius: 0 0 10px 10px;\n      background: url(\"https://hhcdn.ru/ichameleon/362409.jpg\") center/cover\n        no-repeat;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_footer {\n        padding: 20px;\n      }\n    }\n    .tmpl_hh_footer-title {\n      width: 100%;\n      height: auto;\n      margin-bottom: 100px;\n      max-width: 423px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_footer-title {\n        margin-bottom: 95px;\n      }\n    }\n    .tmpl_hh_footer > p {\n      color: #fdfeff;\n      font-size: 14px;\n      line-height: 120%;\n      opacity: 0.5;\n    } /**\n   * Swiper 9.1.0\n   * Most modern mobile touch slider and framework with hardware accelerated transitions\n   * https://swiperjs.com\n   *\n   * Copyright 2014-2023 Vladimir Kharlampidi\n   *\n   * Released under the MIT License\n   *\n   * Released on: February 28, 2023\n   */\n\n    @font-face {\n      font-family: swiper-icons;\n      src: url(\"data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA\");\n      font-weight: 400;\n      font-style: normal;\n    }\n    :root {\n      --swiper-theme-color: #007aff;\n    }\n    .swiper,\n    swiper-container {\n      margin-left: auto;\n      margin-right: auto;\n      position: relative;\n      overflow: hidden;\n      list-style: none;\n      padding: 0;\n      z-index: 1;\n      display: block;\n    }\n    .swiper-vertical > .swiper-wrapper {\n      flex-direction: column;\n    }\n    .swiper-wrapper {\n      position: relative;\n      width: 100%;\n      height: 100%;\n      z-index: 1;\n      display: flex;\n      transition-property: transform;\n      transition-timing-function: var(\n        --swiper-wrapper-transition-timing-function,\n        initial\n      );\n      box-sizing: content-box;\n    }\n    .swiper-android .swiper-slide,\n    .swiper-wrapper {\n      transform: translate3d(0px, 0, 0);\n    }\n    .swiper-horizontal {\n      touch-action: pan-y;\n    }\n    .swiper-vertical {\n      touch-action: pan-x;\n    }\n    .swiper-slide,\n    swiper-slide {\n      flex-shrink: 0;\n      width: 100%;\n      height: 100%;\n      position: relative;\n      transition-property: transform;\n      display: block;\n    }\n    .swiper-slide-invisible-blank {\n      visibility: hidden;\n    }\n    .swiper-autoheight,\n    .swiper-autoheight .swiper-slide {\n      height: auto;\n    }\n    .swiper-autoheight .swiper-wrapper {\n      align-items: flex-start;\n      transition-property: transform, height;\n    }\n    .swiper-backface-hidden .swiper-slide {\n      transform: translateZ(0);\n      -webkit-backface-visibility: hidden;\n      backface-visibility: hidden;\n    }\n    .swiper-3d.swiper-css-mode .swiper-wrapper {\n      perspective: 1200px;\n    }\n    .swiper-3d .swiper-wrapper {\n      transform-style: preserve-3d;\n    }\n    .swiper-3d {\n      perspective: 1200px;\n    }\n    .swiper-3d .swiper-cube-shadow,\n    .swiper-3d .swiper-slide,\n    .swiper-3d .swiper-slide-shadow,\n    .swiper-3d .swiper-slide-shadow-bottom,\n    .swiper-3d .swiper-slide-shadow-left,\n    .swiper-3d .swiper-slide-shadow-right,\n    .swiper-3d .swiper-slide-shadow-top {\n      transform-style: preserve-3d;\n    }\n    .swiper-3d .swiper-slide-shadow,\n    .swiper-3d .swiper-slide-shadow-bottom,\n    .swiper-3d .swiper-slide-shadow-left,\n    .swiper-3d .swiper-slide-shadow-right,\n    .swiper-3d .swiper-slide-shadow-top {\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      pointer-events: none;\n      z-index: 10;\n    }\n    .swiper-3d .swiper-slide-shadow {\n      background: rgba(0, 0, 0, 0.15);\n    }\n    .swiper-3d .swiper-slide-shadow-left {\n      background-image: linear-gradient(\n        to left,\n        rgba(0, 0, 0, 0.5),\n        rgba(0, 0, 0, 0)\n      );\n    }\n    .swiper-3d .swiper-slide-shadow-right {\n      background-image: linear-gradient(\n        to right,\n        rgba(0, 0, 0, 0.5),\n        rgba(0, 0, 0, 0)\n      );\n    }\n    .swiper-3d .swiper-slide-shadow-top {\n      background-image: linear-gradient(\n        to top,\n        rgba(0, 0, 0, 0.5),\n        rgba(0, 0, 0, 0)\n      );\n    }\n    .swiper-3d .swiper-slide-shadow-bottom {\n      background-image: linear-gradient(\n        to bottom,\n        rgba(0, 0, 0, 0.5),\n        rgba(0, 0, 0, 0)\n      );\n    }\n    .swiper-css-mode > .swiper-wrapper {\n      overflow: auto;\n      scrollbar-width: none;\n      -ms-overflow-style: none;\n    }\n    .swiper-css-mode > .swiper-wrapper::-webkit-scrollbar {\n      display: none;\n    }\n    .swiper-css-mode > .swiper-wrapper > .swiper-slide {\n      scroll-snap-align: start start;\n    }\n    .swiper-horizontal.swiper-css-mode > .swiper-wrapper {\n      scroll-snap-type: x mandatory;\n    }\n    .swiper-vertical.swiper-css-mode > .swiper-wrapper {\n      scroll-snap-type: y mandatory;\n    }\n    .swiper-centered > .swiper-wrapper::before {\n      content: \"\";\n      flex-shrink: 0;\n      order: 9999;\n    }\n    .swiper-centered > .swiper-wrapper > .swiper-slide {\n      scroll-snap-align: center center;\n      scroll-snap-stop: always;\n    }\n    .swiper-centered.swiper-horizontal\n      > .swiper-wrapper\n      > .swiper-slide:first-child {\n      margin-inline-start: var(--swiper-centered-offset-before);\n    }\n    .swiper-centered.swiper-horizontal > .swiper-wrapper::before {\n      height: 100%;\n      min-height: 1px;\n      width: var(--swiper-centered-offset-after);\n    }\n    .swiper-centered.swiper-vertical\n      > .swiper-wrapper\n      > .swiper-slide:first-child {\n      margin-block-start: var(--swiper-centered-offset-before);\n    }\n    .swiper-centered.swiper-vertical > .swiper-wrapper::before {\n      width: 100%;\n      min-width: 1px;\n      height: var(--swiper-centered-offset-after);\n    }\n    .swiper-lazy-preloader {\n      width: 42px;\n      height: 42px;\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      margin-left: -21px;\n      margin-top: -21px;\n      z-index: 10;\n      transform-origin: 50%;\n      box-sizing: border-box;\n      border: 4px solid var(--swiper-preloader-color, var(--swiper-theme-color));\n      border-radius: 50%;\n      border-top-color: transparent;\n    }\n    .swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader,\n    .swiper:not(.swiper-watch-progress) .swiper-lazy-preloader,\n    swiper-container:not(.swiper-watch-progress) .swiper-lazy-preloader {\n      animation: swiper-preloader-spin 1s infinite linear;\n    }\n    .swiper-lazy-preloader-white {\n      --swiper-preloader-color: #fff;\n    }\n    .swiper-lazy-preloader-black {\n      --swiper-preloader-color: #000;\n    }\n    @keyframes swiper-preloader-spin {\n      0% {\n        transform: rotate(0deg);\n      }\n      100% {\n        transform: rotate(360deg);\n      }\n    }\n    .swiper-fade.swiper-free-mode .swiper-slide {\n      transition-timing-function: ease-out;\n    }\n    .swiper-fade .swiper-slide {\n      pointer-events: none;\n      transition-property: opacity;\n    }\n    .swiper-fade .swiper-slide .swiper-slide {\n      pointer-events: none;\n    }\n    .swiper-fade .swiper-slide-active,\n    .swiper-fade .swiper-slide-active .swiper-slide-active {\n      pointer-events: auto;\n    }\n  </style>\n  <div>\n    <div class=\"tmpl_hh_wrapper\">\n      <header class=\"tmpl_hh_header\">\n        <svg class=\"tmpl_hh_header-title\" width=\"571\" height=\"101\" viewBox=\"0 0 571 101\" fill=\"none\">\n          <path d=\"M28.5532 28.7239H35.2732C35.0866 30.3292 34.6199 31.9159 33.8732 33.4839C33.1266 35.0146 32.0999 36.4519 30.7932 37.7959C29.4866 39.1399 27.7692 40.2412 25.6412 41.0999C23.5132 41.9212 21.1612 42.3319 18.5852 42.3319C13.2839 42.3319 8.93457 40.4652 5.53723 36.7319C2.17723 32.9612 0.497234 28.0332 0.497234 21.9479C0.497234 15.9372 2.17723 11.0466 5.53723 7.27591C8.89724 3.46791 13.2466 1.56391 18.5852 1.56391C23.2892 1.56391 27.0786 2.85191 29.9532 5.42791C32.8279 7.96658 34.5639 11.1959 35.1612 15.1159H28.4972C27.8999 12.9132 26.7799 11.1212 25.1372 9.73991C23.4946 8.35858 21.3106 7.66791 18.5852 7.66791C15.1879 7.66791 12.4626 8.99324 10.4092 11.6439C8.3559 14.2572 7.32924 17.6919 7.32924 21.9479C7.32924 26.1666 8.3559 29.6012 10.4092 32.2519C12.4626 34.9026 15.1879 36.2279 18.5852 36.2279C21.4226 36.2279 23.6999 35.4626 25.4172 33.9319C27.1346 32.4012 28.1799 30.6652 28.5532 28.7239ZM41.487 16.5719C44.1004 13.8092 47.4977 12.4279 51.679 12.4279C55.8604 12.4279 59.239 13.8092 61.815 16.5719C64.4284 19.3346 65.735 22.9372 65.735 27.3799C65.735 31.8226 64.4284 35.4252 61.815 38.1879C59.239 40.9506 55.8604 42.3319 51.679 42.3319C47.4977 42.3319 44.1004 40.9506 41.487 38.1879C38.911 35.4252 37.623 31.8226 37.623 27.3799C37.623 22.9372 38.911 19.3346 41.487 16.5719ZM46.135 34.0999C47.5164 35.8172 49.3644 36.6759 51.679 36.6759C53.9937 36.6759 55.823 35.8172 57.167 34.0999C58.5484 32.3826 59.239 30.1426 59.239 27.3799C59.239 24.6172 58.5484 22.3772 57.167 20.6599C55.823 18.9426 53.9937 18.0839 51.679 18.0839C49.3644 18.0839 47.5164 18.9426 46.135 20.6599C44.791 22.3772 44.119 24.6172 44.119 27.3799C44.119 30.1426 44.791 32.3826 46.135 34.0999ZM67.9834 21.1079C68.282 18.3826 69.5327 16.2546 71.7354 14.7239C73.9754 13.1932 76.6634 12.4279 79.7994 12.4279C82.8607 12.4279 85.3807 13.1746 87.3594 14.6679C89.338 16.1612 90.3274 18.1399 90.3274 20.6039C90.3274 23.5906 88.946 25.6626 86.1834 26.8199C87.5647 27.1186 88.778 27.8279 89.8234 28.9479C90.906 30.0306 91.4474 31.5239 91.4474 33.4279C91.4474 36.0786 90.346 38.2252 88.1434 39.8679C85.978 41.5106 83.1594 42.3319 79.6874 42.3319C76.3274 42.3319 73.546 41.5292 71.3434 39.9239C69.1407 38.3186 67.8527 36.0972 67.4794 33.2599H73.6954C73.994 34.4919 74.666 35.4439 75.7114 36.1159C76.794 36.7506 78.1194 37.0679 79.6874 37.0679C81.33 37.0679 82.6367 36.7319 83.6074 36.0599C84.578 35.3506 85.0634 34.3799 85.0634 33.1479C85.0634 30.8332 83.29 29.6759 79.7434 29.6759H75.5434V24.6359H79.4074C80.9007 24.6359 82.0394 24.3372 82.8234 23.7399C83.6447 23.1052 84.0554 22.2279 84.0554 21.1079C84.0554 20.0252 83.626 19.1852 82.7674 18.5879C81.946 17.9906 80.8447 17.6919 79.4634 17.6919C78.0074 17.6919 76.8127 18.0092 75.8794 18.6439C74.946 19.2786 74.3487 20.0999 74.0874 21.1079H67.9834ZM124.817 36.0599V48.8279H118.657V41.6599H98.4968V48.8279H92.3368V36.0599H94.6328C96.3128 35.1266 97.3768 32.1586 97.8248 27.1559L98.8888 13.0999H120.673V36.0599H124.817ZM103.873 27.3799C103.537 31.7852 102.734 34.6786 101.465 36.0599H114.289V18.6999H104.545L103.873 27.3799ZM144.755 22.7319C144.755 21.1266 144.233 19.8946 143.187 19.0359C142.179 18.1399 140.835 17.6919 139.155 17.6919C136.131 17.6919 134.246 18.7932 133.499 20.9959H127.451C127.899 18.5319 129.15 16.4972 131.203 14.8919C133.294 13.2492 136.019 12.4279 139.379 12.4279C142.926 12.4279 145.745 13.3426 147.835 15.1719C149.963 17.0012 151.027 19.5586 151.027 22.8439V41.6599H145.091V38.4119C143.001 41.0252 140.051 42.3319 136.243 42.3319C133.406 42.3319 131.035 41.5292 129.131 39.9239C127.265 38.2812 126.331 36.0972 126.331 33.3719C126.331 30.5346 127.339 28.3319 129.355 26.7639C131.409 25.1586 134.227 24.3559 137.811 24.3559H144.755V22.7319ZM137.643 37.1239C139.622 37.1239 141.302 36.5639 142.683 35.4439C144.065 34.2866 144.755 32.7746 144.755 30.9079V29.1719H138.259C136.579 29.1719 135.235 29.5266 134.227 30.2359C133.257 30.9079 132.771 31.8786 132.771 33.1479C132.771 34.4172 133.219 35.4066 134.115 36.1159C135.011 36.7879 136.187 37.1239 137.643 37.1239ZM181.319 29.2279H161.215V29.3399C161.215 31.5426 161.924 33.3719 163.343 34.8279C164.762 36.2839 166.61 37.0119 168.887 37.0119C170.455 37.0119 171.743 36.6946 172.751 36.0599C173.796 35.3879 174.45 34.6786 174.711 33.9319H180.983C180.535 36.0972 179.266 38.0386 177.175 39.7559C175.122 41.4732 172.322 42.3319 168.775 42.3319C164.519 42.3319 161.103 41.0066 158.527 38.3559C155.951 35.6679 154.663 32.0279 154.663 27.4359C154.663 22.8439 155.932 19.2039 158.471 16.5159C161.01 13.7906 164.314 12.4279 168.383 12.4279C172.303 12.4279 175.439 13.7159 177.791 16.2919C180.143 18.8679 181.319 22.3026 181.319 26.5959V29.2279ZM168.327 17.7479C166.311 17.7479 164.668 18.3452 163.399 19.5399C162.167 20.7346 161.458 22.3586 161.271 24.4119H174.935C174.86 22.3212 174.226 20.6972 173.031 19.5399C171.874 18.3452 170.306 17.7479 168.327 17.7479ZM159.703 2.01191C160.45 1.26524 161.364 0.89191 162.447 0.89191C163.53 0.89191 164.426 1.26524 165.135 2.01191C165.882 2.72124 166.255 3.59858 166.255 4.64391C166.255 5.68924 165.882 6.58524 165.135 7.33191C164.426 8.04124 163.53 8.39591 162.447 8.39591C161.364 8.39591 160.45 8.04124 159.703 7.33191C158.994 6.58524 158.639 5.68924 158.639 4.64391C158.639 3.59858 158.994 2.72124 159.703 2.01191ZM171.575 2.01191C172.322 1.26524 173.236 0.89191 174.319 0.89191C175.402 0.89191 176.298 1.26524 177.007 2.01191C177.754 2.72124 178.127 3.59858 178.127 4.64391C178.127 5.68924 177.754 6.58524 177.007 7.33191C176.298 8.04124 175.402 8.39591 174.319 8.39591C173.236 8.39591 172.322 8.04124 171.575 7.33191C170.866 6.58524 170.511 5.68924 170.511 4.64391C170.511 3.59858 170.866 2.72124 171.575 2.01191ZM185.164 13.0999H193.228L202.3 33.8199L211.372 13.0999H219.324V41.6599H213.164V22.1159L204.596 41.5479H199.892L191.324 22.1719V41.6599H185.164V13.0999ZM241.154 41.6599H234.77V13.0999H241.154V24.0759H253.418V13.0999H259.802V41.6599H253.418V29.7319H241.154V41.6599ZM282.032 22.7319C282.032 21.1266 281.509 19.8946 280.464 19.0359C279.456 18.1399 278.112 17.6919 276.432 17.6919C273.408 17.6919 271.523 18.7932 270.776 20.9959H264.728C265.176 18.5319 266.427 16.4972 268.48 14.8919C270.571 13.2492 273.296 12.4279 276.656 12.4279C280.203 12.4279 283.021 13.3426 285.112 15.1719C287.24 17.0012 288.304 19.5586 288.304 22.8439V41.6599H282.368V38.4119C280.277 41.0252 277.328 42.3319 273.52 42.3319C270.683 42.3319 268.312 41.5292 266.408 39.9239C264.541 38.2812 263.608 36.0972 263.608 33.3719C263.608 30.5346 264.616 28.3319 266.632 26.7639C268.685 25.1586 271.504 24.3559 275.088 24.3559H282.032V22.7319ZM274.92 37.1239C276.899 37.1239 278.579 36.5639 279.96 35.4439C281.341 34.2866 282.032 32.7746 282.032 30.9079V29.1719H275.536C273.856 29.1719 272.512 29.5266 271.504 30.2359C270.533 30.9079 270.048 31.8786 270.048 33.1479C270.048 34.4172 270.496 35.4066 271.392 36.1159C272.288 36.7879 273.464 37.1239 274.92 37.1239ZM315.74 13.0999V36.0599H325.148V13.0999H331.532V41.6599H293.564V13.0999H299.948V36.0599H309.356V13.0999H315.74ZM355.634 13.0999H362.522L347.122 52.3559H340.29L344.714 41.1559L333.738 13.0999H340.626L348.13 33.5399L355.634 13.0999ZM371.648 41.7719V36.1719H372.544C374.112 36.1719 375.213 35.7426 375.848 34.8839C376.52 33.9879 376.949 32.4386 377.136 30.2359L378.536 13.0999H399.536V41.6599H393.152V18.6999H384.136L383.184 30.6839C382.885 34.6039 381.952 37.4412 380.384 39.1959C378.853 40.9132 376.52 41.7719 373.384 41.7719H371.648ZM423.672 13.0999H430.56L415.16 52.3559H408.328L412.752 41.1559L401.776 13.0999H408.664L416.168 33.5399L423.672 13.0999ZM449.33 13.0999H455.714V41.6599H449.33V30.4039C447.65 31.3746 445.522 31.8599 442.946 31.8599C439.624 31.8599 436.936 30.8892 434.882 28.9479C432.829 27.0066 431.802 24.1506 431.802 20.3799V13.0999H438.186V19.9319C438.186 24.1506 440.258 26.2599 444.402 26.2599C446.269 26.2599 447.912 25.8866 449.33 25.1399V13.0999ZM483.37 13.0999V36.0599H492.778V13.0999H499.162V41.6599H461.194V13.0999H467.578V36.0599H476.986V13.0999H483.37ZM523.265 13.0999H530.153L514.753 52.3559H507.921L512.345 41.1559L501.369 13.0999H508.257L515.761 33.5399L523.265 13.0999ZM538.731 41.6599H532.347V13.0999H538.731V24.0759H543.603C544.237 20.5666 545.768 17.7479 548.195 15.6199C550.621 13.4919 553.608 12.4279 557.155 12.4279C561.299 12.4279 564.64 13.8279 567.179 16.6279C569.717 19.3906 570.987 22.9746 570.987 27.3799C570.987 31.8226 569.717 35.4252 567.179 38.1879C564.64 40.9506 561.299 42.3319 557.155 42.3319C553.459 42.3319 550.36 41.1932 547.859 38.9159C545.395 36.6012 543.92 33.5399 543.435 29.7319H538.731V41.6599ZM551.723 34.1559C553.067 35.8359 554.877 36.6759 557.155 36.6759C559.432 36.6759 561.224 35.8359 562.531 34.1559C563.875 32.4386 564.547 30.1799 564.547 27.3799C564.547 24.5799 563.875 22.3399 562.531 20.6599C561.224 18.9426 559.432 18.0839 557.155 18.0839C554.877 18.0839 553.067 18.9426 551.723 20.6599C550.416 22.3399 549.763 24.5799 549.763 27.3799C549.763 30.1799 550.416 32.4386 551.723 34.1559ZM21.3852 60.4839C25.7532 60.6332 29.3372 62.0706 32.1372 64.7959C34.9372 67.5212 36.3372 71.0492 36.3372 75.3799C36.3372 79.7106 34.9372 83.2386 32.1372 85.9639C29.3372 88.6892 25.7532 90.1266 21.3852 90.2759V100.356H15.1132V90.2759C10.7079 90.1266 7.10523 88.6892 4.30523 85.9639C1.50523 83.2386 0.105235 79.7106 0.105235 75.3799C0.105235 71.0492 1.50523 67.5212 4.30523 64.7959C7.10523 62.0706 10.7079 60.6332 15.1132 60.4839V49.8999H21.3852V60.4839ZM15.1132 84.7319V66.0279C12.6866 66.1026 10.6519 66.9799 9.00924 68.6599C7.36657 70.3026 6.54523 72.5426 6.54523 75.3799C6.54523 78.2172 7.36657 80.4759 9.00924 82.1559C10.6519 83.7986 12.6866 84.6572 15.1132 84.7319ZM29.9532 75.3799C29.9532 72.5426 29.1319 70.3026 27.4892 68.6599C25.8466 66.9799 23.8119 66.1026 21.3852 66.0279V84.7319C23.8119 84.6572 25.8466 83.7799 27.4892 82.0999C29.1319 80.4199 29.9532 78.1799 29.9532 75.3799ZM65.5447 61.0999V89.6599H59.2727V70.6759L46.3367 89.6599H40.1767V61.0999H46.4487V80.1399L59.3847 61.0999H65.5447ZM77.4067 89.6599H71.0227V61.0999H77.4067V72.0759H89.6707V61.0999H96.0547V89.6599H89.6707V77.7319H77.4067V89.6599ZM99.3005 66.6999V61.0999H123.94V66.6999H114.812V89.6599H108.428V66.6999H99.3005ZM151.129 77.2279H131.025V77.3399C131.025 79.5426 131.735 81.3719 133.153 82.8279C134.572 84.2839 136.42 85.0119 138.697 85.0119C140.265 85.0119 141.553 84.6946 142.561 84.0599C143.607 83.3879 144.26 82.6786 144.521 81.9319H150.793C150.345 84.0972 149.076 86.0386 146.985 87.7559C144.932 89.4732 142.132 90.3319 138.585 90.3319C134.329 90.3319 130.913 89.0066 128.337 86.3559C125.761 83.6679 124.473 80.0279 124.473 75.4359C124.473 70.8439 125.743 67.2039 128.281 64.5159C130.82 61.7906 134.124 60.4279 138.193 60.4279C142.113 60.4279 145.249 61.7159 147.601 64.2919C149.953 66.8679 151.129 70.3026 151.129 74.5959V77.2279ZM138.137 65.7479C136.121 65.7479 134.479 66.3452 133.209 67.5399C131.977 68.7346 131.268 70.3586 131.081 72.4119H144.745C144.671 70.3212 144.036 68.6972 142.841 67.5399C141.684 66.3452 140.116 65.7479 138.137 65.7479ZM171.957 89.6599L165.237 79.8039L158.629 89.6599H151.517L161.429 75.3799L151.629 61.0999H158.965L165.629 71.1239L172.181 61.0999H179.237L169.381 75.5479L179.349 89.6599H171.957ZM179.625 77.3959V71.5159H197.433V77.3959H179.625ZM208.558 89.6599H202.174V61.0999H208.558V72.9719L219.534 61.0999H227.094L214.774 74.4839L227.262 89.6599H219.534L208.558 76.3319V89.6599ZM230.338 64.5719C232.952 61.8092 236.349 60.4279 240.53 60.4279C244.712 60.4279 248.09 61.8092 250.666 64.5719C253.28 67.3346 254.586 70.9372 254.586 75.3799C254.586 79.8226 253.28 83.4252 250.666 86.1879C248.09 88.9506 244.712 90.3319 240.53 90.3319C236.349 90.3319 232.952 88.9506 230.338 86.1879C227.762 83.4252 226.474 79.8226 226.474 75.3799C226.474 70.9372 227.762 67.3346 230.338 64.5719ZM234.986 82.0999C236.368 83.8172 238.216 84.6759 240.53 84.6759C242.845 84.6759 244.674 83.8172 246.018 82.0999C247.4 80.3826 248.09 78.1426 248.09 75.3799C248.09 72.6172 247.4 70.3772 246.018 68.6599C244.674 66.9426 242.845 66.0839 240.53 66.0839C238.216 66.0839 236.368 66.9426 234.986 68.6599C233.642 70.3772 232.97 72.6172 232.97 75.3799C232.97 78.1426 233.642 80.3826 234.986 82.0999ZM258.452 61.0999H266.516L275.588 81.8199L284.66 61.0999H292.612V89.6599H286.452V70.1159L277.884 89.5479H273.18L264.612 70.1719V89.6599H258.452V61.0999ZM314.847 70.7319C314.847 69.1266 314.324 67.8946 313.279 67.0359C312.271 66.1399 310.927 65.6919 309.247 65.6919C306.223 65.6919 304.337 66.7932 303.591 68.9959H297.543C297.991 66.5319 299.241 64.4972 301.295 62.8919C303.385 61.2492 306.111 60.4279 309.471 60.4279C313.017 60.4279 315.836 61.3426 317.927 63.1719C320.055 65.0012 321.119 67.5586 321.119 70.8439V89.6599H315.183V86.4119C313.092 89.0252 310.143 90.3319 306.335 90.3319C303.497 90.3319 301.127 89.5292 299.223 87.9239C297.356 86.2812 296.423 84.0972 296.423 81.3719C296.423 78.5346 297.431 76.3319 299.447 74.7639C301.5 73.1586 304.319 72.3559 307.903 72.3559H314.847V70.7319ZM307.735 85.1239C309.713 85.1239 311.393 84.5639 312.775 83.4439C314.156 82.2866 314.847 80.7746 314.847 78.9079V77.1719H308.351C306.671 77.1719 305.327 77.5266 304.319 78.2359C303.348 78.9079 302.863 79.8786 302.863 81.1479C302.863 82.4172 303.311 83.4066 304.207 84.1159C305.103 84.7879 306.279 85.1239 307.735 85.1239ZM332.762 89.6599H326.378V61.0999H332.762V72.0759H345.026V61.0999H351.41V89.6599H345.026V77.7319H332.762V89.6599ZM386.352 84.0599V96.8279H380.192V89.6599H360.032V96.8279H353.872V84.0599H356.168C357.848 83.1266 358.912 80.1586 359.36 75.1559L360.424 61.0999H382.208V84.0599H386.352ZM365.408 75.3799C365.072 79.7852 364.269 82.6786 363 84.0599H375.824V66.6999H366.08L365.408 75.3799ZM407.865 61.0999H414.753L399.353 100.356H392.521L396.945 89.1559L385.969 61.0999H392.857L400.361 81.5399L407.865 61.0999ZM426.903 89.6599V61.0999H439.727C442.788 61.0999 445.121 61.7906 446.727 63.1719C448.332 64.5532 449.135 66.3266 449.135 68.4919C449.135 70.0599 448.743 71.3666 447.959 72.4119C447.212 73.4199 446.279 74.1479 445.159 74.5959C446.615 75.0066 447.828 75.8092 448.799 77.0039C449.807 78.1986 450.311 79.7106 450.311 81.5399C450.311 83.9292 449.415 85.8892 447.623 87.4199C445.868 88.9132 443.423 89.6599 440.287 89.6599H426.903ZM439.503 77.4519H433.175V84.7319H439.503C440.921 84.7319 442.004 84.4146 442.751 83.7799C443.535 83.1079 443.927 82.1932 443.927 81.0359C443.927 78.6466 442.452 77.4519 439.503 77.4519ZM438.943 66.0279H433.175V72.6359H438.943C440.175 72.6359 441.127 72.3372 441.799 71.7399C442.508 71.1426 442.863 70.3212 442.863 69.2759C442.863 67.1106 441.556 66.0279 438.943 66.0279ZM462.133 56.2279V50.2359H493.605V56.2279H481.229V89.6599H474.565V56.2279H462.133ZM512.189 50.2359V89.6599H505.581V57.6839L496.173 63.6199V56.8999L506.197 50.2359H512.189Z\" fill=\"white\"></path>\n        </svg>\n        <p><b>Финтех-разработка</b></p>\n      </header>\n      <aside class=\"tmpl_hh_aside tmpl_hh_aside-first\">\n        <h2><b>Создаем технологии, определяя будущее</b></h2>\n        <ul>\n          <li>\n            <img src=\"https://hhcdn.ru/ichameleon/361888.png\" alt=\"item\">\n            <p>Т1 — один из лидеров* ИT‑индустрии</p>\n          </li>\n          <li>\n            <img src=\"https://hhcdn.ru/ichameleon/361889.png\" alt=\"item\">\n            <p>\n              Наши партнёры — ведущие производители\n              и разработчики. \n            </p>\n          </li>\n          <li>\n            <img src=\"https://hhcdn.ru/ichameleon/361890.png\" alt=\"item\">\n            <p>Входит в реестр аккредитованных ИТ‑компаний</p>\n          </li>\n        </ul>\n        <div class=\"tmpl_hh_aside-first-ft\">\n          <p>\n            * Первое место среди ведущих российских ИКТ-компаний в рэнкинге\n            RAEX 2023;\n          </p>\n          <p>\n             Первое место среди российских разработчиков ПО\n            и интеграторов в рейтинге CNews100 2023\n          </p>\n        </div>\n        <div class=\"tmpl_hh_aside-first-text\">\n          <p>\n            Т1 — это стабильный и надёжный работодатель.\n            Мы помогаем профессионально расти и решать действительно\n            интересные задачи, создаём атмосферу открытости и комфортные\n            условия для работы в гибридном формате.\n          </p>\n          <p>\n            В Т1 можно выбрать любое ИТ-направление и построить\n            свою траекторию развития. В состав Т1 входят:\n            Т1 Иннотех, Т1 ИИ, Т1 Интеграция, Т1 Облако,\n            Т1 Сервионика, Т1 Цифровая Академия, НОТА от Т1.\n          </p>\n          <p>\n            <b>Мы стремительно растём, масштабируемся и ищем новых\n              специалистов в команду!</b>\n          </p>\n          <p>\n            Мы помогаем ускорить цифровую трансформацию с помощью\n            гибких и быстроадаптируемых решений мирового уровня: современных\n            ИТ-продуктов, систем работы с большими данными\n            и комплексных решений для фронт- и бэк-офисов. Наши\n            разработки повышают гибкость и эффективность работы банковских\n            команд.\n          </p>\n        </div>\n      </aside>\n      <main class=\"tmpl_hh_content\">\n        <p>Стрим <strong>\"Кредиты и документарные операции ФЛ\"</strong> отвечает за поддержку бизнеса по кредитным продуктам ФЛ и расчетам с использованием аккредитивов ФЛ и счетов эскроу ФЛ.<br>Сейчас в рамках импортозамещения мы начинаем масштабный проект по отказу от легаси-систем на основе Oracle. Наши команды будут формировать будущую банковскую микросервисную архитектуру.</p> <p><strong>Обязанности:</strong></p> <ul> <li>Выявление, описание и согласование требований к локальным и интеграционным доработкам по продукту \"Кредит ФЛ\";</li> <li>Участие и помощь в тестировании, в т.ч. участие в организации интеграционных решений;</li> <li>Описание требований к информационной системе (ТИС) и требования к решению (ТР);</li> <li>Выявлять зависимости и адаптировать свои сервисы под планируемые изменения;</li> <li>Проводить показы, формировать протокол и его согласовывать;</li> <li>Моделировать сервисы, в т. ч. с помощью технологической схемы (BPMN);</li> <li>Выполнять настройки на тестовых контурах по продукту «Кредит ФЛ»</li> <li>Анализировать дефекты ПРОМ, ПСИ, ИФТ, предлагать варианты исправления;</li> </ul> <p><strong>Требования:</strong></p> <ul> <li>Знание АБС ЦФТ-Банк (IBSO) - УЯ, Кредиты, РКО или понимание деталей банковских бизнес процессов, объектов АБС (кредиты, вклады, расчеты, закрытие ОД - подтвержденный опыт;</li> <li>Знание всех основных бэковых кредитных процессов и операций в разрезе жизни кредита (выдача, погашение, учет, резервирование и т.д.);</li> <li>Понимание бизнес-процессов на уровне структур таблиц (ERD);</li> <li>Умение читать SQL код, делать не сложные запросы. (Oracle, PostgreSQL);</li> <li>Навык создания/согласования аналитической документации, описания БП, использования различных нотаций (BPMN, UML+ERD);</li> <li>Знание основных видов интеграционных взаимодействий - JSON, Rabbit, файловый обмен и т.д.;</li> <li>Понимание принципов монолитной и микросервисной архитектуры;</li> <li>Опыт участия в проектах интеграции крупных подсистем (АБС, CRM, Front) - большой плюс;</li> <li>Опыт работы со структурами XML;</li> <li>Опыт работы с Jira, Confluence.</li> </ul></main>\n      <aside class=\"tmpl_hh_aside tmpl_hh_aside-second\">\n        <h3><b>Преимущества работы в Т1:</b></h3>\n        <ul>\n          <li>\n            <img src=\"https://hhcdn.ru/ichameleon/362402.png\" alt=\"item\">\n            <p>\n              <b>Комфортные офисы <br>и гибкий рабочий день</b>\n            </p>\n            <p>\n              В офисе, удаленно или в гибридном формате. Главный\n              офис у м. Динамо в Москве — победитель\n              в номинации «Гибкий офис» Best Office Awards 2023\n            </p>\n          </li>\n          <li>\n            <img src=\"https://hhcdn.ru/ichameleon/362403.png\" alt=\"item\">\n            <p>\n              <b>Интересные задачи, производительное железо <br>и софт\n                для работы</b>\n            </p>\n\n            <p>Создаём востребованные ИТ-продукты, ключевые уже внесены в ЕРРП Минцифры (Реестр российского ПО), используем передовые технологии</p>\n          </li>\n          <li>\n            <img src=\"https://hhcdn.ru/ichameleon/362404.png\" alt=\"item\">\n            <p>\n              <b>Забота о здоровье</b>\n            </p>\n            <p>\n              ДМС с телемедициной, стоматологией и возможностью подключения\n              родственников для психологической, юридической и финансовой\n              поддержки\n            </p>\n          </li>\n          <li>\n            <img src=\"https://hhcdn.ru/ichameleon/362401.png\" alt=\"item\">\n            <p>\n              <b>Участие в конференциях и бесплатное обучение</b>\n            </p>\n            <p>\n              А также программа наставничества и 12+ активных сообществ и\n              техногильдий\n            </p>\n          </li>\n          <li>\n            <img src=\"https://hhcdn.ru/ichameleon/362408.png\" alt=\"item\">\n            <p>\n              <b>Насыщенная корпоративная <br>жизнь и нетворкинг</b>\n            </p>\n            <p>\n              Масштабные таунхоллы и яркие неформальные события, регулярные\n              митапы, корпоративная библиотека, активные сообщества\n              и многое другое\n            </p>\n          </li>\n          <li>\n            <img src=\"https://hhcdn.ru/ichameleon/362405.png\" alt=\"item\">\n            <p>\n              <b>Скидки и партнерские<br> программы</b>\n            </p>\n            <p>\n              Сервис привилегий от 100+ партнёров на покупку техники,\n              занятия спортом и иностранными языками, концерты,\n              отели, SPA и др. А также развитая программа\n              компенсации и маркетплейс мерча с собственной\n              корпоративной валютой\n            </p>\n          </li>\n          <li>\n            <img src=\"https://hhcdn.ru/ichameleon/362407.png\" alt=\"item\">\n            <p><b>Конкурентная заработная плата</b></p>\n            <p>\n              Достойный оклад по итогам интервью и система\n              премирования. Оформление <br>по ТК и эксклюзивный\n              зарплатный проект для сотрудников в банке ВТБ\n            </p>\n          </li>\n          <li>\n            <img src=\"https://hhcdn.ru/ichameleon/362406.png\" alt=\"item\">\n            <p><b>Дополнительные выходные и материальная помощь</b></p>\n            <p>\n              Рождение ребёнка, поддержка многодетных семей и одиноких\n              родителей, смерть членов семьи и др. Дополнительный\n              оплачиваемый отпуск (3 календарных дня)\n            </p>\n          </li>\n        </ul>\n\n        <div class=\"swiper tmpl_hh_swiper\">\n          <div class=\"swiper-wrapper tmpl_hh_swiper__wrapper\">\n            <div class=\"swiper-slide tmpl_hh_swiper__slide tmpl_hh_swiper__slide-1\"></div>\n            <div class=\"swiper-slide tmpl_hh_swiper__slide tmpl_hh_swiper__slide-2\"></div>\n            <div class=\"swiper-slide tmpl_hh_swiper__slide tmpl_hh_swiper__slide-3\"></div>\n            <div class=\"swiper-slide tmpl_hh_swiper__slide tmpl_hh_swiper__slide-4\"></div>\n            <div class=\"swiper-slide tmpl_hh_swiper__slide tmpl_hh_swiper__slide-5\"></div>\n          </div>\n\n          <div class=\"swiper-pagination tmpl_hh_swiper__pagination\"></div>\n\n          <div class=\"tmpl_hh_swiper__btns\">\n            <button class=\"swiper-button-prev tmpl_hh_swiper__button tmpl_hh_swiper__button-prev\" type=\"button\"></button>\n            <button class=\"swiper-button-next tmpl_hh_swiper__button tmpl_hh_swiper__button-next\" type=\"button\"></button>\n          </div>\n        </div>\n      </aside>\n      <footer class=\"tmpl_hh_footer\">\n        <svg class=\"tmpl_hh_footer-title\" width=\"423\" height=\"65\" viewBox=\"0 0 423 65\" fill=\"none\">\n          <path d=\"M161.449 6.6C157.369 6.6 154.769 3.96 154.689 0H158.369C158.369 1.8 159.409 3.36 161.449 3.36C163.489 3.36 164.529 1.8 164.529 0H168.209C168.129 3.96 165.529 6.6 161.449 6.6Z\" fill=\"white\"></path>\n          <path d=\"M156.849 22.8L166.089 9.24H170.489V29.64H166.009V16.08L156.769 29.64H152.369V9.24H156.849V22.8Z\" fill=\"white\"></path>\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M362.953 19.44C362.953 13.12 358.913 8.76 352.913 8.76C346.913 8.76 342.873 13.12 342.873 19.44C342.873 25.76 346.913 30.12 352.913 30.12C358.913 30.12 362.953 25.76 362.953 19.44ZM358.313 19.44C358.313 23.36 356.273 26.08 352.913 26.08C349.553 26.08 347.513 23.36 347.513 19.44C347.513 15.52 349.553 12.8 352.913 12.8C356.273 12.8 358.313 15.52 358.313 19.44Z\" fill=\"white\"></path>\n          <path d=\"M409.274 22.8L418.514 9.24H422.914V29.64H418.434V16.08L409.194 29.64H404.794V9.24H409.274V22.8Z\" fill=\"white\"></path>\n          <path d=\"M162.387 35.48H184.867V39.76H176.027V63.64H171.267V39.76H162.387V35.48Z\" fill=\"white\"></path>\n          <path d=\"M194.061 35.48H198.341V63.64H193.621V40.8L186.901 45.04V40.24L194.061 35.48Z\" fill=\"white\"></path>\n          <path d=\"M149.283 56.68C148.883 58.24 147.643 60.08 144.723 60.08C141.523 60.08 139.443 57.44 139.443 53.44C139.443 49.52 141.443 46.8 144.683 46.8C147.483 46.8 148.763 48.6 149.243 50.12H153.683C153.203 46.48 150.203 42.76 144.683 42.76C138.643 42.76 134.803 47.32 134.803 53.44C134.803 59.64 138.683 64.12 144.683 64.12C149.923 64.12 153.283 60.68 153.723 56.68H149.283Z\" fill=\"white\"></path>\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M125.705 52.88V54.76H111.345V54.84C111.345 57.92 113.545 60.32 116.825 60.32C119.265 60.32 120.665 59.04 120.985 58.12H125.465C124.945 60.72 122.305 64.12 116.745 64.12C110.705 64.12 106.665 60.08 106.665 53.48C106.665 46.84 110.705 42.76 116.465 42.76C122.065 42.76 125.705 46.72 125.705 52.88ZM116.425 46.56C113.545 46.56 111.665 48.4 111.385 51.32H121.185C121.025 48.36 119.265 46.56 116.425 46.56Z\" fill=\"white\"></path>\n          <path d=\"M106.085 43.24H88.4847V47.24H95.0047V63.64H99.5647V47.24H106.085V43.24Z\" fill=\"white\"></path>\n          <path d=\"M78.6822 60.08C81.6022 60.08 82.8422 58.24 83.2422 56.68H87.6822C87.2422 60.68 83.8822 64.12 78.6422 64.12C72.6422 64.12 68.7622 59.64 68.7622 53.44C68.7622 47.32 72.6022 42.76 78.6422 42.76C84.1622 42.76 87.1622 46.48 87.6422 50.12H83.2022C82.7222 48.6 81.4422 46.8 78.6422 46.8C75.4022 46.8 73.4022 49.52 73.4022 53.44C73.4022 57.44 75.4822 60.08 78.6822 60.08Z\" fill=\"white\"></path>\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M66.9756 54.76V52.88C66.9756 46.72 63.3356 42.76 57.7356 42.76C51.9756 42.76 47.9356 46.84 47.9356 53.48C47.9356 60.08 51.9756 64.12 58.0156 64.12C63.5756 64.12 66.2156 60.72 66.7356 58.12H62.2556C61.9356 59.04 60.5356 60.32 58.0956 60.32C54.8156 60.32 52.6156 57.92 52.6156 54.84V54.76H66.9756ZM52.6556 51.32C52.9356 48.4 54.8156 46.56 57.6956 46.56C60.5356 46.56 62.2956 48.36 62.4556 51.32H52.6556Z\" fill=\"white\"></path>\n          <path d=\"M32.8138 58.04L39.2938 43.24H44.9738V63.64H40.5737V49.64L34.4538 63.56H31.0938L24.9737 49.72V63.64H20.5737V43.24H26.3337L32.8138 58.04Z\" fill=\"white\"></path>\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M17.6 57.84C17.6 55.04 15.84 53.4 13.92 52.88C15.4 52.32 16.76 50.88 16.76 48.52C16.76 45.56 14.6 43.24 10.04 43.24H0.879999V63.64H10.44C15.08 63.64 17.6 61.12 17.6 57.84ZM9.48 46.76C11.32 46.76 12.28 47.56 12.28 49.08C12.28 50.56 11.28 51.48 9.48 51.48H5.36V46.76H9.48ZM9.88 60.12H5.36V54.92H9.88C11.96 54.92 13.04 55.84 13.04 57.48C13.04 59.12 11.96 60.12 9.88 60.12Z\" fill=\"white\"></path>\n          <path d=\"M396.281 9.24L387.041 22.8V9.24H382.561V29.64H386.961L396.201 16.08V29.64H400.681V9.24H396.281Z\" fill=\"white\"></path>\n          <path d=\"M365.914 9.24H379.914V13.24H370.474V29.64H365.914V9.24Z\" fill=\"white\"></path>\n          <path d=\"M323.873 21.48L324.873 9.24H339.873V29.64H335.313V13.24H328.913L328.193 21.8C327.753 27.44 325.673 29.72 321.193 29.72H319.953V25.72H320.593C322.873 25.72 323.633 24.56 323.873 21.48Z\" fill=\"white\"></path>\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M319.464 19.44C319.464 13.12 315.424 8.76 309.424 8.76C303.424 8.76 299.384 13.12 299.384 19.44C299.384 25.76 303.424 30.12 309.424 30.12C315.424 30.12 319.464 25.76 319.464 19.44ZM314.824 19.44C314.824 23.36 312.784 26.08 309.424 26.08C306.064 26.08 304.024 23.36 304.024 19.44C304.024 15.52 306.064 12.8 309.424 12.8C312.784 12.8 314.824 15.52 314.824 19.44Z\" fill=\"white\"></path>\n          <path d=\"M291.866 17.08V9.24H296.426V29.64H291.866V21.12H283.106V29.64H278.546V9.24H283.106V17.08H291.866Z\" fill=\"white\"></path>\n          <path d=\"M276.457 29.64L269.377 19.56L276.377 9.24H271.337L266.657 16.4L261.897 9.24H256.657L263.697 19.4L256.577 29.64H261.657L266.417 22.56L271.177 29.64H276.457Z\" fill=\"white\"></path>\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M256.101 18.88V20.76H241.741V20.84C241.741 23.92 243.941 26.32 247.221 26.32C249.661 26.32 251.061 25.04 251.381 24.12H255.861C255.341 26.72 252.701 30.12 247.141 30.12C241.101 30.12 237.061 26.08 237.061 19.48C237.061 12.84 241.101 8.76 246.861 8.76C252.461 8.76 256.101 12.72 256.101 18.88ZM246.821 12.56C243.941 12.56 242.061 14.4 241.781 17.32H251.581C251.421 14.36 249.661 12.56 246.821 12.56Z\" fill=\"white\"></path>\n          <path d=\"M236.48 9.24H218.88V13.24H225.4V29.64H229.96V13.24H236.48V9.24Z\" fill=\"white\"></path>\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M210.222 18.88V20.76H195.862V20.84C195.862 23.92 198.062 26.32 201.342 26.32C203.782 26.32 205.182 25.04 205.502 24.12H209.982C209.462 26.72 206.822 30.12 201.262 30.12C195.223 30.12 191.182 26.08 191.182 19.48C191.182 12.84 195.222 8.76 200.982 8.76C206.582 8.76 210.222 12.72 210.222 18.88ZM200.942 12.56C198.062 12.56 196.182 14.4 195.902 17.32H205.702C205.542 14.36 203.782 12.56 200.942 12.56Z\" fill=\"white\"></path>\n          <path d=\"M190.602 9.24H173.002V13.24H179.522V29.64H184.082V13.24H190.602V9.24Z\" fill=\"white\"></path>\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M148.412 16.2C148.412 11.44 145.092 8.76 140.092 8.76C135.092 8.76 132.172 11.56 131.572 14.88H135.892C136.332 13.6 137.572 12.52 139.932 12.52C142.212 12.52 143.932 13.72 143.932 16.12V17.28H138.972C133.892 17.28 130.772 19.68 130.772 23.72C130.772 27.72 133.892 30.12 137.852 30.12C140.492 30.12 142.772 29.12 144.172 27.32V29.64H148.412V16.2ZM143.932 21.96C143.932 24.72 141.572 26.4 138.852 26.4C136.812 26.4 135.372 25.4 135.372 23.56C135.372 21.72 136.972 20.72 139.292 20.72H143.932V21.96Z\" fill=\"white\"></path>\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M125.318 18.88C127.238 19.4 128.998 21.04 128.998 23.84C128.998 27.12 126.478 29.64 121.838 29.64H112.278V9.24H121.438C125.998 9.24 128.158 11.56 128.158 14.52C128.158 16.88 126.798 18.32 125.318 18.88ZM123.678 15.08C123.678 13.56 122.718 12.76 120.878 12.76H116.758V17.48H120.878C122.678 17.48 123.678 16.56 123.678 15.08ZM116.758 26.12H121.278C123.358 26.12 124.438 25.12 124.438 23.48C124.438 21.84 123.358 20.92 121.278 20.92H116.758V26.12Z\" fill=\"white\"></path>\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M108.322 16.2C108.322 11.44 105.002 8.76 100.002 8.76C95.0016 8.76 92.0816 11.56 91.4816 14.88H95.8016C96.2416 13.6 97.4816 12.52 99.8416 12.52C102.122 12.52 103.842 13.72 103.842 16.12V17.28H98.8816C93.8016 17.28 90.6816 19.68 90.6816 23.72C90.6816 27.72 93.8016 30.12 97.7616 30.12C100.402 30.12 102.682 29.12 104.082 27.32V29.64H108.322V16.2ZM103.842 21.96C103.842 24.72 101.482 26.4 98.7616 26.4C96.7216 26.4 95.2816 25.4 95.2816 23.56C95.2816 21.72 96.8816 20.72 99.2016 20.72H103.842V21.96Z\" fill=\"white\"></path>\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M86.4397 9.24V25.64H89.3997V34.76H84.9997V29.64H70.5997V34.76H66.1997V25.64H67.8397C69.1997 24.88 69.8797 22.4 70.1197 19.28L70.8797 9.24H86.4397ZM74.9197 13.24L74.4397 19.44C74.2397 21.96 73.9997 24.24 72.7597 25.64H81.8797V13.24H74.9197Z\" fill=\"white\"></path>\n          <path d=\"M48.6044 14.96H52.9644C53.3244 13.56 54.6444 12.52 56.8044 12.52C58.7644 12.52 60.0844 13.4 60.0844 14.96C60.0844 16.56 58.8844 17.48 56.7644 17.48H54.0044V21.08H57.0044C59.4844 21.08 60.8044 21.88 60.8044 23.56C60.8044 25.36 59.2844 26.36 56.9644 26.36C54.7644 26.36 53.1244 25.4 52.6844 23.64H48.2444C48.7644 27.76 52.2444 30.12 56.9644 30.12C61.9244 30.12 65.3644 27.56 65.3644 23.76C65.3644 20.72 63.1644 19.4 61.6044 19.04C63.0444 18.44 64.5644 17.12 64.5644 14.6C64.5644 11.04 61.3244 8.76 57.0444 8.76C52.7244 8.76 49.0444 10.92 48.6044 14.96Z\" fill=\"white\"></path>\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M36.7584 8.76C42.7584 8.76 46.7984 13.12 46.7984 19.44C46.7984 25.76 42.7584 30.12 36.7584 30.12C30.7584 30.12 26.7184 25.76 26.7184 19.44C26.7184 13.12 30.7584 8.76 36.7584 8.76ZM36.7584 26.08C40.1184 26.08 42.1584 23.36 42.1584 19.44C42.1584 15.52 40.1184 12.8 36.7584 12.8C33.3984 12.8 31.3584 15.52 31.3584 19.44C31.3584 23.36 33.3984 26.08 36.7584 26.08Z\" fill=\"white\"></path>\n          <path d=\"M24.84 20.4H20.04C19.6 22.76 17.32 25.76 12.92 25.76C8 25.76 4.88 21.52 4.88 15.56C4.88 9.48 8.08 5.36 12.92 5.36C17.04 5.36 19.2 7.8 20 10.68H24.76C23.96 5.4 19.96 1 12.92 1C5.28 1 0 7 0 15.56C0 24.32 5.44 30.12 12.92 30.12C20.68 30.12 24.36 24.76 24.84 20.4Z\" fill=\"white\"></path>\n        </svg>\n\n        <p>\n          Команда рекрутмента<br> ООО «Группа компаний Иннотех» (входит\n          в Т1)\n        </p>\n      </footer>\n    </div>\n  </div>\n  <script>\n    //\n\n    const main = \"\";\n    const customTitle = () => {\n      const allUl = document.querySelectorAll(\".tmpl_hh_content ul\");\n      allUl.forEach((ul, i) => {\n        const ulTitle = ul.previousElementSibling;\n        if (ulTitle) {\n          ulTitle.classList.add(\"tmpl_hh_content_title\");\n          if (i === 0) {\n            ul.previousElementSibling.classList.add(\n              \"tmpl_hh_content_title--first\"\n            );\n          }\n        }\n      });\n    };\n    const swiper_min = \"\";\n    const effectFade_min = \"\";\n    function isObject$1(obj) {\n      return (\n        obj !== null &&\n        typeof obj === \"object\" &&\n        \"constructor\" in obj &&\n        obj.constructor === Object\n      );\n    }\n    function extend$1(target = {}, src = {}) {\n      Object.keys(src).forEach((key) => {\n        if (typeof target[key] === \"undefined\") target[key] = src[key];\n        else if (\n          isObject$1(src[key]) &&\n          isObject$1(target[key]) &&\n          Object.keys(src[key]).length > 0\n        ) {\n          extend$1(target[key], src[key]);\n        }\n      });\n    }\n    const ssrDocument = {\n      body: {},\n      addEventListener() {},\n      removeEventListener() {},\n      activeElement: {\n        blur() {},\n        nodeName: \"\",\n      },\n      querySelector() {\n        return null;\n      },\n      querySelectorAll() {\n        return [];\n      },\n      getElementById() {\n        return null;\n      },\n      createEvent() {\n        return {\n          initEvent() {},\n        };\n      },\n      createElement() {\n        return {\n          children: [],\n          childNodes: [],\n          style: {},\n          setAttribute() {},\n          getElementsByTagName() {\n            return [];\n          },\n        };\n      },\n      createElementNS() {\n        return {};\n      },\n      importNode() {\n        return null;\n      },\n      location: {\n        hash: \"\",\n        host: \"\",\n        hostname: \"\",\n        href: \"\",\n        origin: \"\",\n        pathname: \"\",\n        protocol: \"\",\n        search: \"\",\n      },\n    };\n    function getDocument() {\n      const doc = typeof document !== \"undefined\" ? document : {};\n      extend$1(doc, ssrDocument);\n      return doc;\n    }\n    const ssrWindow = {\n      document: ssrDocument,\n      navigator: {\n        userAgent: \"\",\n      },\n      location: {\n        hash: \"\",\n        host: \"\",\n        hostname: \"\",\n        href: \"\",\n        origin: \"\",\n        pathname: \"\",\n        protocol: \"\",\n        search: \"\",\n      },\n      history: {\n        replaceState() {},\n        pushState() {},\n        go() {},\n        back() {},\n      },\n      CustomEvent: function CustomEvent() {\n        return this;\n      },\n      addEventListener() {},\n      removeEventListener() {},\n      getComputedStyle() {\n        return {\n          getPropertyValue() {\n            return \"\";\n          },\n        };\n      },\n      Image() {},\n      Date() {},\n      screen: {},\n      setTimeout() {},\n      clearTimeout() {},\n      matchMedia() {\n        return {};\n      },\n      requestAnimationFrame(callback) {\n        if (typeof setTimeout === \"undefined\") {\n          callback();\n          return null;\n        }\n        return setTimeout(callback, 0);\n      },\n      cancelAnimationFrame(id) {\n        if (typeof setTimeout === \"undefined\") {\n          return;\n        }\n        clearTimeout(id);\n      },\n    };\n    function getWindow() {\n      const win = typeof window !== \"undefined\" ? window : {};\n      extend$1(win, ssrWindow);\n      return win;\n    }\n    function deleteProps(obj) {\n      const object = obj;\n      Object.keys(object).forEach((key) => {\n        try {\n          object[key] = null;\n        } catch (e) {}\n        try {\n          delete object[key];\n        } catch (e) {}\n      });\n    }\n    function nextTick(callback, delay = 0) {\n      return setTimeout(callback, delay);\n    }\n    function now() {\n      return Date.now();\n    }\n    function getComputedStyle$1(el) {\n      const window2 = getWindow();\n      let style;\n      if (window2.getComputedStyle) {\n        style = window2.getComputedStyle(el, null);\n      }\n      if (!style && el.currentStyle) {\n        style = el.currentStyle;\n      }\n      if (!style) {\n        style = el.style;\n      }\n      return style;\n    }\n    function getTranslate(el, axis = \"x\") {\n      const window2 = getWindow();\n      let matrix;\n      let curTransform;\n      let transformMatrix;\n      const curStyle = getComputedStyle$1(el, null);\n      if (window2.WebKitCSSMatrix) {\n        curTransform = curStyle.transform || curStyle.webkitTransform;\n        if (curTransform.split(\",\").length > 6) {\n          curTransform = curTransform\n            .split(\", \")\n            .map((a) => a.replace(\",\", \".\"))\n            .join(\", \");\n        }\n        transformMatrix = new window2.WebKitCSSMatrix(\n          curTransform === \"none\" ? \"\" : curTransform\n        );\n      } else {\n        transformMatrix =\n          curStyle.MozTransform ||\n          curStyle.OTransform ||\n          curStyle.MsTransform ||\n          curStyle.msTransform ||\n          curStyle.transform ||\n          curStyle\n            .getPropertyValue(\"transform\")\n            .replace(\"translate(\", \"matrix(1, 0, 0, 1,\");\n        matrix = transformMatrix.toString().split(\",\");\n      }\n      if (axis === \"x\") {\n        if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n        else curTransform = parseFloat(matrix[4]);\n      }\n      if (axis === \"y\") {\n        if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n        else curTransform = parseFloat(matrix[5]);\n      }\n      return curTransform || 0;\n    }\n    function isObject(o) {\n      return (\n        typeof o === \"object\" &&\n        o !== null &&\n        o.constructor &&\n        Object.prototype.toString.call(o).slice(8, -1) === \"Object\"\n      );\n    }\n    function isNode(node) {\n      if (\n        typeof window !== \"undefined\" &&\n        typeof window.HTMLElement !== \"undefined\"\n      ) {\n        return node instanceof HTMLElement;\n      }\n      return node && (node.nodeType === 1 || node.nodeType === 11);\n    }\n    function extend(...args) {\n      const to = Object(args[0]);\n      const noExtend = [\"__proto__\", \"constructor\", \"prototype\"];\n      for (let i = 1; i < args.length; i += 1) {\n        const nextSource = args[i];\n        if (\n          nextSource !== void 0 &&\n          nextSource !== null &&\n          !isNode(nextSource)\n        ) {\n          const keysArray = Object.keys(Object(nextSource)).filter(\n            (key) => noExtend.indexOf(key) < 0\n          );\n          for (\n            let nextIndex = 0, len = keysArray.length;\n            nextIndex < len;\n            nextIndex += 1\n          ) {\n            const nextKey = keysArray[nextIndex];\n            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n            if (desc !== void 0 && desc.enumerable) {\n              if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                if (nextSource[nextKey].__swiper__) {\n                  to[nextKey] = nextSource[nextKey];\n                } else {\n                  extend(to[nextKey], nextSource[nextKey]);\n                }\n              } else if (\n                !isObject(to[nextKey]) &&\n                isObject(nextSource[nextKey])\n              ) {\n                to[nextKey] = {};\n                if (nextSource[nextKey].__swiper__) {\n                  to[nextKey] = nextSource[nextKey];\n                } else {\n                  extend(to[nextKey], nextSource[nextKey]);\n                }\n              } else {\n                to[nextKey] = nextSource[nextKey];\n              }\n            }\n          }\n        }\n      }\n      return to;\n    }\n    function setCSSProperty(el, varName, varValue) {\n      el.style.setProperty(varName, varValue);\n    }\n    function animateCSSModeScroll({ swiper, targetPosition, side }) {\n      const window2 = getWindow();\n      const startPosition = -swiper.translate;\n      let startTime = null;\n      let time;\n      const duration = swiper.params.speed;\n      swiper.wrapperEl.style.scrollSnapType = \"none\";\n      window2.cancelAnimationFrame(swiper.cssModeFrameID);\n      const dir = targetPosition > startPosition ? \"next\" : \"prev\";\n      const isOutOfBound = (current, target) => {\n        return (\n          (dir === \"next\" && current >= target) ||\n          (dir === \"prev\" && current <= target)\n        );\n      };\n      const animate = () => {\n        time = /* @__PURE__ */ new Date().getTime();\n        if (startTime === null) {\n          startTime = time;\n        }\n        const progress = Math.max(\n          Math.min((time - startTime) / duration, 1),\n          0\n        );\n        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n        let currentPosition =\n          startPosition + easeProgress * (targetPosition - startPosition);\n        if (isOutOfBound(currentPosition, targetPosition)) {\n          currentPosition = targetPosition;\n        }\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition,\n        });\n        if (isOutOfBound(currentPosition, targetPosition)) {\n          swiper.wrapperEl.style.overflow = \"hidden\";\n          swiper.wrapperEl.style.scrollSnapType = \"\";\n          setTimeout(() => {\n            swiper.wrapperEl.style.overflow = \"\";\n            swiper.wrapperEl.scrollTo({\n              [side]: currentPosition,\n            });\n          });\n          window2.cancelAnimationFrame(swiper.cssModeFrameID);\n          return;\n        }\n        swiper.cssModeFrameID = window2.requestAnimationFrame(animate);\n      };\n      animate();\n    }\n    function getSlideTransformEl(slideEl) {\n      return (\n        slideEl.querySelector(\".swiper-slide-transform\") ||\n        (slideEl.shadowEl &&\n          slideEl.shadowEl.querySelector(\".swiper-slide-transform\")) ||\n        slideEl\n      );\n    }\n    function findElementsInElements(elements = [], selector = \"\") {\n      const found = [];\n      elements.forEach((el) => {\n        found.push(...el.querySelectorAll(selector));\n      });\n      return found;\n    }\n    function elementChildren(element, selector = \"\") {\n      return [...element.children].filter((el) => el.matches(selector));\n    }\n    function createElement(tag, classes2 = []) {\n      const el = document.createElement(tag);\n      el.classList.add(...(Array.isArray(classes2) ? classes2 : [classes2]));\n      return el;\n    }\n    function elementOffset(el) {\n      const window2 = getWindow();\n      const document2 = getDocument();\n      const box = el.getBoundingClientRect();\n      const body = document2.body;\n      const clientTop = el.clientTop || body.clientTop || 0;\n      const clientLeft = el.clientLeft || body.clientLeft || 0;\n      const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;\n      const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;\n      return {\n        top: box.top + scrollTop - clientTop,\n        left: box.left + scrollLeft - clientLeft,\n      };\n    }\n    function elementPrevAll(el, selector) {\n      const prevEls = [];\n      while (el.previousElementSibling) {\n        const prev = el.previousElementSibling;\n        if (selector) {\n          if (prev.matches(selector)) prevEls.push(prev);\n        } else prevEls.push(prev);\n        el = prev;\n      }\n      return prevEls;\n    }\n    function elementNextAll(el, selector) {\n      const nextEls = [];\n      while (el.nextElementSibling) {\n        const next = el.nextElementSibling;\n        if (selector) {\n          if (next.matches(selector)) nextEls.push(next);\n        } else nextEls.push(next);\n        el = next;\n      }\n      return nextEls;\n    }\n    function elementStyle(el, prop) {\n      const window2 = getWindow();\n      return window2.getComputedStyle(el, null).getPropertyValue(prop);\n    }\n    function elementIndex(el) {\n      let child = el;\n      let i;\n      if (child) {\n        i = 0;\n        while ((child = child.previousSibling) !== null) {\n          if (child.nodeType === 1) i += 1;\n        }\n        return i;\n      }\n      return void 0;\n    }\n    function elementParents(el, selector) {\n      const parents = [];\n      let parent = el.parentElement;\n      while (parent) {\n        if (selector) {\n          if (parent.matches(selector)) parents.push(parent);\n        } else {\n          parents.push(parent);\n        }\n        parent = parent.parentElement;\n      }\n      return parents;\n    }\n    function elementTransitionEnd(el, callback) {\n      function fireCallBack(e) {\n        if (e.target !== el) return;\n        callback.call(el, e);\n        el.removeEventListener(\"transitionend\", fireCallBack);\n      }\n      if (callback) {\n        el.addEventListener(\"transitionend\", fireCallBack);\n      }\n    }\n    function elementOuterSize(el, size, includeMargins) {\n      const window2 = getWindow();\n      if (includeMargins) {\n        return (\n          el[size === \"width\" ? \"offsetWidth\" : \"offsetHeight\"] +\n          parseFloat(\n            window2\n              .getComputedStyle(el, null)\n              .getPropertyValue(\n                size === \"width\" ? \"margin-right\" : \"margin-top\"\n              )\n          ) +\n          parseFloat(\n            window2\n              .getComputedStyle(el, null)\n              .getPropertyValue(\n                size === \"width\" ? \"margin-left\" : \"margin-bottom\"\n              )\n          )\n        );\n      }\n      return el.offsetWidth;\n    }\n    let support;\n    function calcSupport() {\n      const window2 = getWindow();\n      const document2 = getDocument();\n      return {\n        smoothScroll:\n          document2.documentElement &&\n          \"scrollBehavior\" in document2.documentElement.style,\n        touch: !!(\n          \"ontouchstart\" in window2 ||\n          (window2.DocumentTouch && document2 instanceof window2.DocumentTouch)\n        ),\n      };\n    }\n    function getSupport() {\n      if (!support) {\n        support = calcSupport();\n      }\n      return support;\n    }\n    let deviceCached;\n    function calcDevice({ userAgent } = {}) {\n      const support2 = getSupport();\n      const window2 = getWindow();\n      const platform = window2.navigator.platform;\n      const ua = userAgent || window2.navigator.userAgent;\n      const device = {\n        ios: false,\n        android: false,\n      };\n      const screenWidth = window2.screen.width;\n      const screenHeight = window2.screen.height;\n      const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n      let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n      const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n      const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n      const windows = platform === \"Win32\";\n      let macos = platform === \"MacIntel\";\n      const iPadScreens = [\n        \"1024x1366\",\n        \"1366x1024\",\n        \"834x1194\",\n        \"1194x834\",\n        \"834x1112\",\n        \"1112x834\",\n        \"768x1024\",\n        \"1024x768\",\n        \"820x1180\",\n        \"1180x820\",\n        \"810x1080\",\n        \"1080x810\",\n      ];\n      if (\n        !ipad &&\n        macos &&\n        support2.touch &&\n        iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0\n      ) {\n        ipad = ua.match(/(Version)\\/([\\d.]+)/);\n        if (!ipad) ipad = [0, 1, \"13_0_0\"];\n        macos = false;\n      }\n      if (android && !windows) {\n        device.os = \"android\";\n        device.android = true;\n      }\n      if (ipad || iphone || ipod) {\n        device.os = \"ios\";\n        device.ios = true;\n      }\n      return device;\n    }\n    function getDevice(overrides = {}) {\n      if (!deviceCached) {\n        deviceCached = calcDevice(overrides);\n      }\n      return deviceCached;\n    }\n    let browser;\n    function calcBrowser() {\n      const window2 = getWindow();\n      let needPerspectiveFix = false;\n      function isSafari() {\n        const ua = window2.navigator.userAgent.toLowerCase();\n        return (\n          ua.indexOf(\"safari\") >= 0 &&\n          ua.indexOf(\"chrome\") < 0 &&\n          ua.indexOf(\"android\") < 0\n        );\n      }\n      if (isSafari()) {\n        const ua = String(window2.navigator.userAgent);\n        if (ua.includes(\"Version/\")) {\n          const [major, minor] = ua\n            .split(\"Version/\")[1]\n            .split(\" \")[0]\n            .split(\".\")\n            .map((num) => Number(num));\n          needPerspectiveFix = major < 16 || (major === 16 && minor < 2);\n        }\n      }\n      return {\n        isSafari: needPerspectiveFix || isSafari(),\n        needPerspectiveFix,\n        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(\n          window2.navigator.userAgent\n        ),\n      };\n    }\n    function getBrowser() {\n      if (!browser) {\n        browser = calcBrowser();\n      }\n      return browser;\n    }\n    function Resize({ swiper, on, emit }) {\n      const window2 = getWindow();\n      let observer = null;\n      let animationFrame = null;\n      const resizeHandler = () => {\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        emit(\"beforeResize\");\n        emit(\"resize\");\n      };\n      const createObserver = () => {\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        observer = new ResizeObserver((entries) => {\n          animationFrame = window2.requestAnimationFrame(() => {\n            const { width, height } = swiper;\n            let newWidth = width;\n            let newHeight = height;\n            entries.forEach(({ contentBoxSize, contentRect, target }) => {\n              if (target && target !== swiper.el) return;\n              newWidth = contentRect\n                ? contentRect.width\n                : (contentBoxSize[0] || contentBoxSize).inlineSize;\n              newHeight = contentRect\n                ? contentRect.height\n                : (contentBoxSize[0] || contentBoxSize).blockSize;\n            });\n            if (newWidth !== width || newHeight !== height) {\n              resizeHandler();\n            }\n          });\n        });\n        observer.observe(swiper.el);\n      };\n      const removeObserver = () => {\n        if (animationFrame) {\n          window2.cancelAnimationFrame(animationFrame);\n        }\n        if (observer && observer.unobserve && swiper.el) {\n          observer.unobserve(swiper.el);\n          observer = null;\n        }\n      };\n      const orientationChangeHandler = () => {\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        emit(\"orientationchange\");\n      };\n      on(\"init\", () => {\n        if (\n          swiper.params.resizeObserver &&\n          typeof window2.ResizeObserver !== \"undefined\"\n        ) {\n          createObserver();\n          return;\n        }\n        window2.addEventListener(\"resize\", resizeHandler);\n        window2.addEventListener(\"orientationchange\", orientationChangeHandler);\n      });\n      on(\"destroy\", () => {\n        removeObserver();\n        window2.removeEventListener(\"resize\", resizeHandler);\n        window2.removeEventListener(\n          \"orientationchange\",\n          orientationChangeHandler\n        );\n      });\n    }\n    function Observer({ swiper, extendParams, on, emit }) {\n      const observers = [];\n      const window2 = getWindow();\n      const attach = (target, options = {}) => {\n        const ObserverFunc =\n          window2.MutationObserver || window2.WebkitMutationObserver;\n        const observer = new ObserverFunc((mutations) => {\n          if (swiper.__preventObserver__) return;\n          if (mutations.length === 1) {\n            emit(\"observerUpdate\", mutations[0]);\n            return;\n          }\n          const observerUpdate = function observerUpdate2() {\n            emit(\"observerUpdate\", mutations[0]);\n          };\n          if (window2.requestAnimationFrame) {\n            window2.requestAnimationFrame(observerUpdate);\n          } else {\n            window2.setTimeout(observerUpdate, 0);\n          }\n        });\n        observer.observe(target, {\n          attributes:\n            typeof options.attributes === \"undefined\"\n              ? true\n              : options.attributes,\n          childList:\n            typeof options.childList === \"undefined\" ? true : options.childList,\n          characterData:\n            typeof options.characterData === \"undefined\"\n              ? true\n              : options.characterData,\n        });\n        observers.push(observer);\n      };\n      const init = () => {\n        if (!swiper.params.observer) return;\n        if (swiper.params.observeParents) {\n          const containerParents = elementParents(swiper.el);\n          for (let i = 0; i < containerParents.length; i += 1) {\n            attach(containerParents[i]);\n          }\n        }\n        attach(swiper.el, {\n          childList: swiper.params.observeSlideChildren,\n        });\n        attach(swiper.wrapperEl, {\n          attributes: false,\n        });\n      };\n      const destroy = () => {\n        observers.forEach((observer) => {\n          observer.disconnect();\n        });\n        observers.splice(0, observers.length);\n      };\n      extendParams({\n        observer: false,\n        observeParents: false,\n        observeSlideChildren: false,\n      });\n      on(\"init\", init);\n      on(\"destroy\", destroy);\n    }\n    const eventsEmitter = {\n      on(events2, handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== \"function\") return self;\n        const method = priority ? \"unshift\" : \"push\";\n        events2.split(\" \").forEach((event2) => {\n          if (!self.eventsListeners[event2]) self.eventsListeners[event2] = [];\n          self.eventsListeners[event2][method](handler);\n        });\n        return self;\n      },\n      once(events2, handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== \"function\") return self;\n        function onceHandler(...args) {\n          self.off(events2, onceHandler);\n          if (onceHandler.__emitterProxy) {\n            delete onceHandler.__emitterProxy;\n          }\n          handler.apply(self, args);\n        }\n        onceHandler.__emitterProxy = handler;\n        return self.on(events2, onceHandler, priority);\n      },\n      onAny(handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== \"function\") return self;\n        const method = priority ? \"unshift\" : \"push\";\n        if (self.eventsAnyListeners.indexOf(handler) < 0) {\n          self.eventsAnyListeners[method](handler);\n        }\n        return self;\n      },\n      offAny(handler) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsAnyListeners) return self;\n        const index = self.eventsAnyListeners.indexOf(handler);\n        if (index >= 0) {\n          self.eventsAnyListeners.splice(index, 1);\n        }\n        return self;\n      },\n      off(events2, handler) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsListeners) return self;\n        events2.split(\" \").forEach((event2) => {\n          if (typeof handler === \"undefined\") {\n            self.eventsListeners[event2] = [];\n          } else if (self.eventsListeners[event2]) {\n            self.eventsListeners[event2].forEach((eventHandler, index) => {\n              if (\n                eventHandler === handler ||\n                (eventHandler.__emitterProxy &&\n                  eventHandler.__emitterProxy === handler)\n              ) {\n                self.eventsListeners[event2].splice(index, 1);\n              }\n            });\n          }\n        });\n        return self;\n      },\n      emit(...args) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsListeners) return self;\n        let events2;\n        let data;\n        let context;\n        if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n          events2 = args[0];\n          data = args.slice(1, args.length);\n          context = self;\n        } else {\n          events2 = args[0].events;\n          data = args[0].data;\n          context = args[0].context || self;\n        }\n        data.unshift(context);\n        const eventsArray = Array.isArray(events2)\n          ? events2\n          : events2.split(\" \");\n        eventsArray.forEach((event2) => {\n          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n            self.eventsAnyListeners.forEach((eventHandler) => {\n              eventHandler.apply(context, [event2, ...data]);\n            });\n          }\n          if (self.eventsListeners && self.eventsListeners[event2]) {\n            self.eventsListeners[event2].forEach((eventHandler) => {\n              eventHandler.apply(context, data);\n            });\n          }\n        });\n        return self;\n      },\n    };\n    function updateSize() {\n      const swiper = this;\n      let width;\n      let height;\n      const el = swiper.el;\n      if (\n        typeof swiper.params.width !== \"undefined\" &&\n        swiper.params.width !== null\n      ) {\n        width = swiper.params.width;\n      } else {\n        width = el.clientWidth;\n      }\n      if (\n        typeof swiper.params.height !== \"undefined\" &&\n        swiper.params.height !== null\n      ) {\n        height = swiper.params.height;\n      } else {\n        height = el.clientHeight;\n      }\n      if (\n        (width === 0 && swiper.isHorizontal()) ||\n        (height === 0 && swiper.isVertical())\n      ) {\n        return;\n      }\n      width =\n        width -\n        parseInt(elementStyle(el, \"padding-left\") || 0, 10) -\n        parseInt(elementStyle(el, \"padding-right\") || 0, 10);\n      height =\n        height -\n        parseInt(elementStyle(el, \"padding-top\") || 0, 10) -\n        parseInt(elementStyle(el, \"padding-bottom\") || 0, 10);\n      if (Number.isNaN(width)) width = 0;\n      if (Number.isNaN(height)) height = 0;\n      Object.assign(swiper, {\n        width,\n        height,\n        size: swiper.isHorizontal() ? width : height,\n      });\n    }\n    function updateSlides() {\n      const swiper = this;\n      function getDirectionLabel(property) {\n        if (swiper.isHorizontal()) {\n          return property;\n        }\n        return {\n          width: \"height\",\n          \"margin-top\": \"margin-left\",\n          \"margin-bottom \": \"margin-right\",\n          \"margin-left\": \"margin-top\",\n          \"margin-right\": \"margin-bottom\",\n          \"padding-left\": \"padding-top\",\n          \"padding-right\": \"padding-bottom\",\n          marginRight: \"marginBottom\",\n        }[property];\n      }\n      function getDirectionPropertyValue(node, label) {\n        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n      }\n      const params = swiper.params;\n      const {\n        wrapperEl,\n        slidesEl,\n        size: swiperSize,\n        rtlTranslate: rtl,\n        wrongRTL,\n      } = swiper;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      const previousSlidesLength = isVirtual\n        ? swiper.virtual.slides.length\n        : swiper.slides.length;\n      const slides = elementChildren(\n        slidesEl,\n        `.${swiper.params.slideClass}, swiper-slide`\n      );\n      const slidesLength = isVirtual\n        ? swiper.virtual.slides.length\n        : slides.length;\n      let snapGrid = [];\n      const slidesGrid = [];\n      const slidesSizesGrid = [];\n      let offsetBefore = params.slidesOffsetBefore;\n      if (typeof offsetBefore === \"function\") {\n        offsetBefore = params.slidesOffsetBefore.call(swiper);\n      }\n      let offsetAfter = params.slidesOffsetAfter;\n      if (typeof offsetAfter === \"function\") {\n        offsetAfter = params.slidesOffsetAfter.call(swiper);\n      }\n      const previousSnapGridLength = swiper.snapGrid.length;\n      const previousSlidesGridLength = swiper.slidesGrid.length;\n      let spaceBetween = params.spaceBetween;\n      let slidePosition = -offsetBefore;\n      let prevSlideSize = 0;\n      let index = 0;\n      if (typeof swiperSize === \"undefined\") {\n        return;\n      }\n      if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n        spaceBetween =\n          (parseFloat(spaceBetween.replace(\"%\", \"\")) / 100) * swiperSize;\n      }\n      swiper.virtualSize = -spaceBetween;\n      slides.forEach((slideEl) => {\n        if (rtl) {\n          slideEl.style.marginLeft = \"\";\n        } else {\n          slideEl.style.marginRight = \"\";\n        }\n        slideEl.style.marginBottom = \"\";\n        slideEl.style.marginTop = \"\";\n      });\n      if (params.centeredSlides && params.cssMode) {\n        setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", \"\");\n        setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", \"\");\n      }\n      const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n      if (gridEnabled) {\n        swiper.grid.initSlides(slidesLength);\n      }\n      let slideSize;\n      const shouldResetSlideSize =\n        params.slidesPerView === \"auto\" &&\n        params.breakpoints &&\n        Object.keys(params.breakpoints).filter((key) => {\n          return typeof params.breakpoints[key].slidesPerView !== \"undefined\";\n        }).length > 0;\n      for (let i = 0; i < slidesLength; i += 1) {\n        slideSize = 0;\n        let slide2;\n        if (slides[i]) slide2 = slides[i];\n        if (gridEnabled) {\n          swiper.grid.updateSlide(i, slide2, slidesLength, getDirectionLabel);\n        }\n        if (slides[i] && elementStyle(slide2, \"display\") === \"none\") continue;\n        if (params.slidesPerView === \"auto\") {\n          if (shouldResetSlideSize) {\n            slides[i].style[getDirectionLabel(\"width\")] = ``;\n          }\n          const slideStyles = getComputedStyle(slide2);\n          const currentTransform = slide2.style.transform;\n          const currentWebKitTransform = slide2.style.webkitTransform;\n          if (currentTransform) {\n            slide2.style.transform = \"none\";\n          }\n          if (currentWebKitTransform) {\n            slide2.style.webkitTransform = \"none\";\n          }\n          if (params.roundLengths) {\n            slideSize = swiper.isHorizontal()\n              ? elementOuterSize(slide2, \"width\", true)\n              : elementOuterSize(slide2, \"height\", true);\n          } else {\n            const width = getDirectionPropertyValue(slideStyles, \"width\");\n            const paddingLeft = getDirectionPropertyValue(\n              slideStyles,\n              \"padding-left\"\n            );\n            const paddingRight = getDirectionPropertyValue(\n              slideStyles,\n              \"padding-right\"\n            );\n            const marginLeft = getDirectionPropertyValue(\n              slideStyles,\n              \"margin-left\"\n            );\n            const marginRight = getDirectionPropertyValue(\n              slideStyles,\n              \"margin-right\"\n            );\n            const boxSizing = slideStyles.getPropertyValue(\"box-sizing\");\n            if (boxSizing && boxSizing === \"border-box\") {\n              slideSize = width + marginLeft + marginRight;\n            } else {\n              const { clientWidth, offsetWidth } = slide2;\n              slideSize =\n                width +\n                paddingLeft +\n                paddingRight +\n                marginLeft +\n                marginRight +\n                (offsetWidth - clientWidth);\n            }\n          }\n          if (currentTransform) {\n            slide2.style.transform = currentTransform;\n          }\n          if (currentWebKitTransform) {\n            slide2.style.webkitTransform = currentWebKitTransform;\n          }\n          if (params.roundLengths) slideSize = Math.floor(slideSize);\n        } else {\n          slideSize =\n            (swiperSize - (params.slidesPerView - 1) * spaceBetween) /\n            params.slidesPerView;\n          if (params.roundLengths) slideSize = Math.floor(slideSize);\n          if (slides[i]) {\n            slides[i].style[getDirectionLabel(\"width\")] = `${slideSize}px`;\n          }\n        }\n        if (slides[i]) {\n          slides[i].swiperSlideSize = slideSize;\n        }\n        slidesSizesGrid.push(slideSize);\n        if (params.centeredSlides) {\n          slidePosition =\n            slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n          if (prevSlideSize === 0 && i !== 0)\n            slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n          if (i === 0)\n            slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n          if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;\n          if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n          slidesGrid.push(slidePosition);\n        } else {\n          if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n          if (\n            (index - Math.min(swiper.params.slidesPerGroupSkip, index)) %\n              swiper.params.slidesPerGroup ===\n            0\n          )\n            snapGrid.push(slidePosition);\n          slidesGrid.push(slidePosition);\n          slidePosition = slidePosition + slideSize + spaceBetween;\n        }\n        swiper.virtualSize += slideSize + spaceBetween;\n        prevSlideSize = slideSize;\n        index += 1;\n      }\n      swiper.virtualSize =\n        Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n      if (\n        rtl &&\n        wrongRTL &&\n        (params.effect === \"slide\" || params.effect === \"coverflow\")\n      ) {\n        wrapperEl.style.width = `${swiper.virtualSize + params.spaceBetween}px`;\n      }\n      if (params.setWrapperSize) {\n        wrapperEl.style[getDirectionLabel(\"width\")] = `${\n          swiper.virtualSize + params.spaceBetween\n        }px`;\n      }\n      if (gridEnabled) {\n        swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n      }\n      if (!params.centeredSlides) {\n        const newSlidesGrid = [];\n        for (let i = 0; i < snapGrid.length; i += 1) {\n          let slidesGridItem = snapGrid[i];\n          if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n          if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n            newSlidesGrid.push(slidesGridItem);\n          }\n        }\n        snapGrid = newSlidesGrid;\n        if (\n          Math.floor(swiper.virtualSize - swiperSize) -\n            Math.floor(snapGrid[snapGrid.length - 1]) >\n          1\n        ) {\n          snapGrid.push(swiper.virtualSize - swiperSize);\n        }\n      }\n      if (isVirtual && params.loop) {\n        const size = slidesSizesGrid[0] + spaceBetween;\n        if (params.slidesPerGroup > 1) {\n          const groups = Math.ceil(\n            (swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) /\n              params.slidesPerGroup\n          );\n          const groupSize = size * params.slidesPerGroup;\n          for (let i = 0; i < groups; i += 1) {\n            snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n          }\n        }\n        for (\n          let i = 0;\n          i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter;\n          i += 1\n        ) {\n          if (params.slidesPerGroup === 1) {\n            snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n          }\n          slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n          swiper.virtualSize += size;\n        }\n      }\n      if (snapGrid.length === 0) snapGrid = [0];\n      if (params.spaceBetween !== 0) {\n        const key =\n          swiper.isHorizontal() && rtl\n            ? \"marginLeft\"\n            : getDirectionLabel(\"marginRight\");\n        slides\n          .filter((_, slideIndex) => {\n            if (!params.cssMode || params.loop) return true;\n            if (slideIndex === slides.length - 1) {\n              return false;\n            }\n            return true;\n          })\n          .forEach((slideEl) => {\n            slideEl.style[key] = `${spaceBetween}px`;\n          });\n      }\n      if (params.centeredSlides && params.centeredSlidesBounds) {\n        let allSlidesSize = 0;\n        slidesSizesGrid.forEach((slideSizeValue) => {\n          allSlidesSize +=\n            slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n        });\n        allSlidesSize -= params.spaceBetween;\n        const maxSnap = allSlidesSize - swiperSize;\n        snapGrid = snapGrid.map((snap) => {\n          if (snap < 0) return -offsetBefore;\n          if (snap > maxSnap) return maxSnap + offsetAfter;\n          return snap;\n        });\n      }\n      if (params.centerInsufficientSlides) {\n        let allSlidesSize = 0;\n        slidesSizesGrid.forEach((slideSizeValue) => {\n          allSlidesSize +=\n            slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n        });\n        allSlidesSize -= params.spaceBetween;\n        if (allSlidesSize < swiperSize) {\n          const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n          snapGrid.forEach((snap, snapIndex) => {\n            snapGrid[snapIndex] = snap - allSlidesOffset;\n          });\n          slidesGrid.forEach((snap, snapIndex) => {\n            slidesGrid[snapIndex] = snap + allSlidesOffset;\n          });\n        }\n      }\n      Object.assign(swiper, {\n        slides,\n        snapGrid,\n        slidesGrid,\n        slidesSizesGrid,\n      });\n      if (\n        params.centeredSlides &&\n        params.cssMode &&\n        !params.centeredSlidesBounds\n      ) {\n        setCSSProperty(\n          wrapperEl,\n          \"--swiper-centered-offset-before\",\n          `${-snapGrid[0]}px`\n        );\n        setCSSProperty(\n          wrapperEl,\n          \"--swiper-centered-offset-after\",\n          `${\n            swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2\n          }px`\n        );\n        const addToSnapGrid = -swiper.snapGrid[0];\n        const addToSlidesGrid = -swiper.slidesGrid[0];\n        swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);\n        swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);\n      }\n      if (slidesLength !== previousSlidesLength) {\n        swiper.emit(\"slidesLengthChange\");\n      }\n      if (snapGrid.length !== previousSnapGridLength) {\n        if (swiper.params.watchOverflow) swiper.checkOverflow();\n        swiper.emit(\"snapGridLengthChange\");\n      }\n      if (slidesGrid.length !== previousSlidesGridLength) {\n        swiper.emit(\"slidesGridLengthChange\");\n      }\n      if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n      }\n      if (\n        !isVirtual &&\n        !params.cssMode &&\n        (params.effect === \"slide\" || params.effect === \"fade\")\n      ) {\n        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n        const hasClassBackfaceClassAdded =\n          swiper.el.classList.contains(backFaceHiddenClass);\n        if (slidesLength <= params.maxBackfaceHiddenSlides) {\n          if (!hasClassBackfaceClassAdded)\n            swiper.el.classList.add(backFaceHiddenClass);\n        } else if (hasClassBackfaceClassAdded) {\n          swiper.el.classList.remove(backFaceHiddenClass);\n        }\n      }\n    }\n    function updateAutoHeight(speed) {\n      const swiper = this;\n      const activeSlides = [];\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      let newHeight = 0;\n      let i;\n      if (typeof speed === \"number\") {\n        swiper.setTransition(speed);\n      } else if (speed === true) {\n        swiper.setTransition(swiper.params.speed);\n      }\n      const getSlideByIndex = (index) => {\n        if (isVirtual) {\n          return swiper.slides.filter(\n            (el) =>\n              parseInt(el.getAttribute(\"data-swiper-slide-index\"), 10) === index\n          )[0];\n        }\n        return swiper.slides[index];\n      };\n      if (\n        swiper.params.slidesPerView !== \"auto\" &&\n        swiper.params.slidesPerView > 1\n      ) {\n        if (swiper.params.centeredSlides) {\n          (swiper.visibleSlides || []).forEach((slide2) => {\n            activeSlides.push(slide2);\n          });\n        } else {\n          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n            const index = swiper.activeIndex + i;\n            if (index > swiper.slides.length && !isVirtual) break;\n            activeSlides.push(getSlideByIndex(index));\n          }\n        }\n      } else {\n        activeSlides.push(getSlideByIndex(swiper.activeIndex));\n      }\n      for (i = 0; i < activeSlides.length; i += 1) {\n        if (typeof activeSlides[i] !== \"undefined\") {\n          const height = activeSlides[i].offsetHeight;\n          newHeight = height > newHeight ? height : newHeight;\n        }\n      }\n      if (newHeight || newHeight === 0)\n        swiper.wrapperEl.style.height = `${newHeight}px`;\n    }\n    function updateSlidesOffset() {\n      const swiper = this;\n      const slides = swiper.slides;\n      const minusOffset = swiper.isElement\n        ? swiper.isHorizontal()\n          ? swiper.wrapperEl.offsetLeft\n          : swiper.wrapperEl.offsetTop\n        : 0;\n      for (let i = 0; i < slides.length; i += 1) {\n        slides[i].swiperSlideOffset =\n          (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) -\n          minusOffset;\n      }\n    }\n    function updateSlidesProgress(translate2 = (this && this.translate) || 0) {\n      const swiper = this;\n      const params = swiper.params;\n      const { slides, rtlTranslate: rtl, snapGrid } = swiper;\n      if (slides.length === 0) return;\n      if (typeof slides[0].swiperSlideOffset === \"undefined\")\n        swiper.updateSlidesOffset();\n      let offsetCenter = -translate2;\n      if (rtl) offsetCenter = translate2;\n      slides.forEach((slideEl) => {\n        slideEl.classList.remove(params.slideVisibleClass);\n      });\n      swiper.visibleSlidesIndexes = [];\n      swiper.visibleSlides = [];\n      for (let i = 0; i < slides.length; i += 1) {\n        const slide2 = slides[i];\n        let slideOffset = slide2.swiperSlideOffset;\n        if (params.cssMode && params.centeredSlides) {\n          slideOffset -= slides[0].swiperSlideOffset;\n        }\n        const slideProgress =\n          (offsetCenter +\n            (params.centeredSlides ? swiper.minTranslate() : 0) -\n            slideOffset) /\n          (slide2.swiperSlideSize + params.spaceBetween);\n        const originalSlideProgress =\n          (offsetCenter -\n            snapGrid[0] +\n            (params.centeredSlides ? swiper.minTranslate() : 0) -\n            slideOffset) /\n          (slide2.swiperSlideSize + params.spaceBetween);\n        const slideBefore = -(offsetCenter - slideOffset);\n        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n        const isVisible =\n          (slideBefore >= 0 && slideBefore < swiper.size - 1) ||\n          (slideAfter > 1 && slideAfter <= swiper.size) ||\n          (slideBefore <= 0 && slideAfter >= swiper.size);\n        if (isVisible) {\n          swiper.visibleSlides.push(slide2);\n          swiper.visibleSlidesIndexes.push(i);\n          slides[i].classList.add(params.slideVisibleClass);\n        }\n        slide2.progress = rtl ? -slideProgress : slideProgress;\n        slide2.originalProgress = rtl\n          ? -originalSlideProgress\n          : originalSlideProgress;\n      }\n    }\n    function updateProgress(translate2) {\n      const swiper = this;\n      if (typeof translate2 === \"undefined\") {\n        const multiplier = swiper.rtlTranslate ? -1 : 1;\n        translate2 =\n          (swiper && swiper.translate && swiper.translate * multiplier) || 0;\n      }\n      const params = swiper.params;\n      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n      let { progress, isBeginning, isEnd, progressLoop } = swiper;\n      const wasBeginning = isBeginning;\n      const wasEnd = isEnd;\n      if (translatesDiff === 0) {\n        progress = 0;\n        isBeginning = true;\n        isEnd = true;\n      } else {\n        progress = (translate2 - swiper.minTranslate()) / translatesDiff;\n        const isBeginningRounded =\n          Math.abs(translate2 - swiper.minTranslate()) < 1;\n        const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;\n        isBeginning = isBeginningRounded || progress <= 0;\n        isEnd = isEndRounded || progress >= 1;\n        if (isBeginningRounded) progress = 0;\n        if (isEndRounded) progress = 1;\n      }\n      if (params.loop) {\n        const firstSlideIndex = swiper.getSlideIndex(\n          swiper.slides.filter(\n            (el) => el.getAttribute(\"data-swiper-slide-index\") === \"0\"\n          )[0]\n        );\n        const lastSlideIndex = swiper.getSlideIndex(\n          swiper.slides.filter(\n            (el) =>\n              el.getAttribute(\"data-swiper-slide-index\") * 1 ===\n              swiper.slides.length - 1\n          )[0]\n        );\n        const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n        const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n        const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n        const translateAbs = Math.abs(translate2);\n        if (translateAbs >= firstSlideTranslate) {\n          progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n        } else {\n          progressLoop =\n            (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n        }\n        if (progressLoop > 1) progressLoop -= 1;\n      }\n      Object.assign(swiper, {\n        progress,\n        progressLoop,\n        isBeginning,\n        isEnd,\n      });\n      if (\n        params.watchSlidesProgress ||\n        (params.centeredSlides && params.autoHeight)\n      )\n        swiper.updateSlidesProgress(translate2);\n      if (isBeginning && !wasBeginning) {\n        swiper.emit(\"reachBeginning toEdge\");\n      }\n      if (isEnd && !wasEnd) {\n        swiper.emit(\"reachEnd toEdge\");\n      }\n      if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {\n        swiper.emit(\"fromEdge\");\n      }\n      swiper.emit(\"progress\", progress);\n    }\n    function updateSlidesClasses() {\n      const swiper = this;\n      const { slides, params, slidesEl, activeIndex } = swiper;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      const getFilteredSlide = (selector) => {\n        return elementChildren(\n          slidesEl,\n          `.${params.slideClass}${selector}, swiper-slide${selector}`\n        )[0];\n      };\n      slides.forEach((slideEl) => {\n        slideEl.classList.remove(\n          params.slideActiveClass,\n          params.slideNextClass,\n          params.slidePrevClass\n        );\n      });\n      let activeSlide;\n      if (isVirtual) {\n        if (params.loop) {\n          let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n          if (slideIndex < 0)\n            slideIndex = swiper.virtual.slides.length + slideIndex;\n          if (slideIndex >= swiper.virtual.slides.length)\n            slideIndex -= swiper.virtual.slides.length;\n          activeSlide = getFilteredSlide(\n            `[data-swiper-slide-index=\"${slideIndex}\"]`\n          );\n        } else {\n          activeSlide = getFilteredSlide(\n            `[data-swiper-slide-index=\"${activeIndex}\"]`\n          );\n        }\n      } else {\n        activeSlide = slides[activeIndex];\n      }\n      if (activeSlide) {\n        activeSlide.classList.add(params.slideActiveClass);\n        let nextSlide = elementNextAll(\n          activeSlide,\n          `.${params.slideClass}, swiper-slide`\n        )[0];\n        if (params.loop && !nextSlide) {\n          nextSlide = slides[0];\n        }\n        if (nextSlide) {\n          nextSlide.classList.add(params.slideNextClass);\n        }\n        let prevSlide = elementPrevAll(\n          activeSlide,\n          `.${params.slideClass}, swiper-slide`\n        )[0];\n        if (params.loop && !prevSlide === 0) {\n          prevSlide = slides[slides.length - 1];\n        }\n        if (prevSlide) {\n          prevSlide.classList.add(params.slidePrevClass);\n        }\n      }\n      swiper.emitSlidesClasses();\n    }\n    function getActiveIndexByTranslate(swiper) {\n      const { slidesGrid, params } = swiper;\n      const translate2 = swiper.rtlTranslate\n        ? swiper.translate\n        : -swiper.translate;\n      let activeIndex;\n      for (let i = 0; i < slidesGrid.length; i += 1) {\n        if (typeof slidesGrid[i + 1] !== \"undefined\") {\n          if (\n            translate2 >= slidesGrid[i] &&\n            translate2 <\n              slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2\n          ) {\n            activeIndex = i;\n          } else if (\n            translate2 >= slidesGrid[i] &&\n            translate2 < slidesGrid[i + 1]\n          ) {\n            activeIndex = i + 1;\n          }\n        } else if (translate2 >= slidesGrid[i]) {\n          activeIndex = i;\n        }\n      }\n      if (params.normalizeSlideIndex) {\n        if (activeIndex < 0 || typeof activeIndex === \"undefined\")\n          activeIndex = 0;\n      }\n      return activeIndex;\n    }\n    function updateActiveIndex(newActiveIndex) {\n      const swiper = this;\n      const translate2 = swiper.rtlTranslate\n        ? swiper.translate\n        : -swiper.translate;\n      const {\n        snapGrid,\n        params,\n        activeIndex: previousIndex,\n        realIndex: previousRealIndex,\n        snapIndex: previousSnapIndex,\n      } = swiper;\n      let activeIndex = newActiveIndex;\n      let snapIndex;\n      const getVirtualRealIndex = (aIndex) => {\n        let realIndex2 = aIndex - swiper.virtual.slidesBefore;\n        if (realIndex2 < 0) {\n          realIndex2 = swiper.virtual.slides.length + realIndex2;\n        }\n        if (realIndex2 >= swiper.virtual.slides.length) {\n          realIndex2 -= swiper.virtual.slides.length;\n        }\n        return realIndex2;\n      };\n      if (typeof activeIndex === \"undefined\") {\n        activeIndex = getActiveIndexByTranslate(swiper);\n      }\n      if (snapGrid.indexOf(translate2) >= 0) {\n        snapIndex = snapGrid.indexOf(translate2);\n      } else {\n        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n        snapIndex =\n          skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n      }\n      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n      if (activeIndex === previousIndex) {\n        if (snapIndex !== previousSnapIndex) {\n          swiper.snapIndex = snapIndex;\n          swiper.emit(\"snapIndexChange\");\n        }\n        if (\n          swiper.params.loop &&\n          swiper.virtual &&\n          swiper.params.virtual.enabled\n        ) {\n          swiper.realIndex = getVirtualRealIndex(activeIndex);\n        }\n        return;\n      }\n      let realIndex;\n      if (swiper.virtual && params.virtual.enabled && params.loop) {\n        realIndex = getVirtualRealIndex(activeIndex);\n      } else if (swiper.slides[activeIndex]) {\n        realIndex = parseInt(\n          swiper.slides[activeIndex].getAttribute(\"data-swiper-slide-index\") ||\n            activeIndex,\n          10\n        );\n      } else {\n        realIndex = activeIndex;\n      }\n      Object.assign(swiper, {\n        snapIndex,\n        realIndex,\n        previousIndex,\n        activeIndex,\n      });\n      swiper.emit(\"activeIndexChange\");\n      swiper.emit(\"snapIndexChange\");\n      if (previousRealIndex !== realIndex) {\n        swiper.emit(\"realIndexChange\");\n      }\n      if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n        swiper.emit(\"slideChange\");\n      }\n    }\n    function updateClickedSlide(e) {\n      const swiper = this;\n      const params = swiper.params;\n      const slide2 = e.closest(`.${params.slideClass}, swiper-slide`);\n      let slideFound = false;\n      let slideIndex;\n      if (slide2) {\n        for (let i = 0; i < swiper.slides.length; i += 1) {\n          if (swiper.slides[i] === slide2) {\n            slideFound = true;\n            slideIndex = i;\n            break;\n          }\n        }\n      }\n      if (slide2 && slideFound) {\n        swiper.clickedSlide = slide2;\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          swiper.clickedIndex = parseInt(\n            slide2.getAttribute(\"data-swiper-slide-index\"),\n            10\n          );\n        } else {\n          swiper.clickedIndex = slideIndex;\n        }\n      } else {\n        swiper.clickedSlide = void 0;\n        swiper.clickedIndex = void 0;\n        return;\n      }\n      if (\n        params.slideToClickedSlide &&\n        swiper.clickedIndex !== void 0 &&\n        swiper.clickedIndex !== swiper.activeIndex\n      ) {\n        swiper.slideToClickedSlide();\n      }\n    }\n    const update = {\n      updateSize,\n      updateSlides,\n      updateAutoHeight,\n      updateSlidesOffset,\n      updateSlidesProgress,\n      updateProgress,\n      updateSlidesClasses,\n      updateActiveIndex,\n      updateClickedSlide,\n    };\n    function getSwiperTranslate(axis = this.isHorizontal() ? \"x\" : \"y\") {\n      const swiper = this;\n      const {\n        params,\n        rtlTranslate: rtl,\n        translate: translate2,\n        wrapperEl,\n      } = swiper;\n      if (params.virtualTranslate) {\n        return rtl ? -translate2 : translate2;\n      }\n      if (params.cssMode) {\n        return translate2;\n      }\n      let currentTranslate = getTranslate(wrapperEl, axis);\n      if (rtl) currentTranslate = -currentTranslate;\n      return currentTranslate || 0;\n    }\n    function setTranslate(translate2, byController) {\n      const swiper = this;\n      const { rtlTranslate: rtl, params, wrapperEl, progress } = swiper;\n      let x = 0;\n      let y = 0;\n      const z = 0;\n      if (swiper.isHorizontal()) {\n        x = rtl ? -translate2 : translate2;\n      } else {\n        y = translate2;\n      }\n      if (params.roundLengths) {\n        x = Math.floor(x);\n        y = Math.floor(y);\n      }\n      if (params.cssMode) {\n        wrapperEl[swiper.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] =\n          swiper.isHorizontal() ? -x : -y;\n      } else if (!params.virtualTranslate) {\n        wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n      }\n      swiper.previousTranslate = swiper.translate;\n      swiper.translate = swiper.isHorizontal() ? x : y;\n      let newProgress;\n      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n      if (translatesDiff === 0) {\n        newProgress = 0;\n      } else {\n        newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;\n      }\n      if (newProgress !== progress) {\n        swiper.updateProgress(translate2);\n      }\n      swiper.emit(\"setTranslate\", swiper.translate, byController);\n    }\n    function minTranslate() {\n      return -this.snapGrid[0];\n    }\n    function maxTranslate() {\n      return -this.snapGrid[this.snapGrid.length - 1];\n    }\n    function translateTo(\n      translate2 = 0,\n      speed = this.params.speed,\n      runCallbacks = true,\n      translateBounds = true,\n      internal\n    ) {\n      const swiper = this;\n      const { params, wrapperEl } = swiper;\n      if (swiper.animating && params.preventInteractionOnTransition) {\n        return false;\n      }\n      const minTranslate2 = swiper.minTranslate();\n      const maxTranslate2 = swiper.maxTranslate();\n      let newTranslate;\n      if (translateBounds && translate2 > minTranslate2)\n        newTranslate = minTranslate2;\n      else if (translateBounds && translate2 < maxTranslate2)\n        newTranslate = maxTranslate2;\n      else newTranslate = translate2;\n      swiper.updateProgress(newTranslate);\n      if (params.cssMode) {\n        const isH = swiper.isHorizontal();\n        if (speed === 0) {\n          wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = -newTranslate;\n        } else {\n          if (!swiper.support.smoothScroll) {\n            animateCSSModeScroll({\n              swiper,\n              targetPosition: -newTranslate,\n              side: isH ? \"left\" : \"top\",\n            });\n            return true;\n          }\n          wrapperEl.scrollTo({\n            [isH ? \"left\" : \"top\"]: -newTranslate,\n            behavior: \"smooth\",\n          });\n        }\n        return true;\n      }\n      if (speed === 0) {\n        swiper.setTransition(0);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n          swiper.emit(\"beforeTransitionStart\", speed, internal);\n          swiper.emit(\"transitionEnd\");\n        }\n      } else {\n        swiper.setTransition(speed);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n          swiper.emit(\"beforeTransitionStart\", speed, internal);\n          swiper.emit(\"transitionStart\");\n        }\n        if (!swiper.animating) {\n          swiper.animating = true;\n          if (!swiper.onTranslateToWrapperTransitionEnd) {\n            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(\n              e\n            ) {\n              if (!swiper || swiper.destroyed) return;\n              if (e.target !== this) return;\n              swiper.wrapperEl.removeEventListener(\n                \"transitionend\",\n                swiper.onTranslateToWrapperTransitionEnd\n              );\n              swiper.onTranslateToWrapperTransitionEnd = null;\n              delete swiper.onTranslateToWrapperTransitionEnd;\n              if (runCallbacks) {\n                swiper.emit(\"transitionEnd\");\n              }\n            };\n          }\n          swiper.wrapperEl.addEventListener(\n            \"transitionend\",\n            swiper.onTranslateToWrapperTransitionEnd\n          );\n        }\n      }\n      return true;\n    }\n    const translate = {\n      getTranslate: getSwiperTranslate,\n      setTranslate,\n      minTranslate,\n      maxTranslate,\n      translateTo,\n    };\n    function setTransition(duration, byController) {\n      const swiper = this;\n      if (!swiper.params.cssMode) {\n        swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n      }\n      swiper.emit(\"setTransition\", duration, byController);\n    }\n    function transitionEmit({ swiper, runCallbacks, direction, step }) {\n      const { activeIndex, previousIndex } = swiper;\n      let dir = direction;\n      if (!dir) {\n        if (activeIndex > previousIndex) dir = \"next\";\n        else if (activeIndex < previousIndex) dir = \"prev\";\n        else dir = \"reset\";\n      }\n      swiper.emit(`transition${step}`);\n      if (runCallbacks && activeIndex !== previousIndex) {\n        if (dir === \"reset\") {\n          swiper.emit(`slideResetTransition${step}`);\n          return;\n        }\n        swiper.emit(`slideChangeTransition${step}`);\n        if (dir === \"next\") {\n          swiper.emit(`slideNextTransition${step}`);\n        } else {\n          swiper.emit(`slidePrevTransition${step}`);\n        }\n      }\n    }\n    function transitionStart(runCallbacks = true, direction) {\n      const swiper = this;\n      const { params } = swiper;\n      if (params.cssMode) return;\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n      transitionEmit({\n        swiper,\n        runCallbacks,\n        direction,\n        step: \"Start\",\n      });\n    }\n    function transitionEnd(runCallbacks = true, direction) {\n      const swiper = this;\n      const { params } = swiper;\n      swiper.animating = false;\n      if (params.cssMode) return;\n      swiper.setTransition(0);\n      transitionEmit({\n        swiper,\n        runCallbacks,\n        direction,\n        step: \"End\",\n      });\n    }\n    const transition = {\n      setTransition,\n      transitionStart,\n      transitionEnd,\n    };\n    function slideTo(\n      index = 0,\n      speed = this.params.speed,\n      runCallbacks = true,\n      internal,\n      initial\n    ) {\n      if (typeof index === \"string\") {\n        index = parseInt(index, 10);\n      }\n      const swiper = this;\n      let slideIndex = index;\n      if (slideIndex < 0) slideIndex = 0;\n      const {\n        params,\n        snapGrid,\n        slidesGrid,\n        previousIndex,\n        activeIndex,\n        rtlTranslate: rtl,\n        wrapperEl,\n        enabled,\n      } = swiper;\n      if (\n        (swiper.animating && params.preventInteractionOnTransition) ||\n        (!enabled && !internal && !initial)\n      ) {\n        return false;\n      }\n      const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n      let snapIndex =\n        skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n      const translate2 = -snapGrid[snapIndex];\n      if (params.normalizeSlideIndex) {\n        for (let i = 0; i < slidesGrid.length; i += 1) {\n          const normalizedTranslate = -Math.floor(translate2 * 100);\n          const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n          const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n          if (typeof slidesGrid[i + 1] !== \"undefined\") {\n            if (\n              normalizedTranslate >= normalizedGrid &&\n              normalizedTranslate <\n                normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2\n            ) {\n              slideIndex = i;\n            } else if (\n              normalizedTranslate >= normalizedGrid &&\n              normalizedTranslate < normalizedGridNext\n            ) {\n              slideIndex = i + 1;\n            }\n          } else if (normalizedTranslate >= normalizedGrid) {\n            slideIndex = i;\n          }\n        }\n      }\n      if (swiper.initialized && slideIndex !== activeIndex) {\n        if (\n          !swiper.allowSlideNext &&\n          translate2 < swiper.translate &&\n          translate2 < swiper.minTranslate()\n        ) {\n          return false;\n        }\n        if (\n          !swiper.allowSlidePrev &&\n          translate2 > swiper.translate &&\n          translate2 > swiper.maxTranslate()\n        ) {\n          if ((activeIndex || 0) !== slideIndex) {\n            return false;\n          }\n        }\n      }\n      if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n        swiper.emit(\"beforeSlideChangeStart\");\n      }\n      swiper.updateProgress(translate2);\n      let direction;\n      if (slideIndex > activeIndex) direction = \"next\";\n      else if (slideIndex < activeIndex) direction = \"prev\";\n      else direction = \"reset\";\n      if (\n        (rtl && -translate2 === swiper.translate) ||\n        (!rtl && translate2 === swiper.translate)\n      ) {\n        swiper.updateActiveIndex(slideIndex);\n        if (params.autoHeight) {\n          swiper.updateAutoHeight();\n        }\n        swiper.updateSlidesClasses();\n        if (params.effect !== \"slide\") {\n          swiper.setTranslate(translate2);\n        }\n        if (direction !== \"reset\") {\n          swiper.transitionStart(runCallbacks, direction);\n          swiper.transitionEnd(runCallbacks, direction);\n        }\n        return false;\n      }\n      if (params.cssMode) {\n        const isH = swiper.isHorizontal();\n        const t = rtl ? translate2 : -translate2;\n        if (speed === 0) {\n          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n          if (isVirtual) {\n            swiper.wrapperEl.style.scrollSnapType = \"none\";\n            swiper._immediateVirtual = true;\n          }\n          if (\n            isVirtual &&\n            !swiper._cssModeVirtualInitialSet &&\n            swiper.params.initialSlide > 0\n          ) {\n            swiper._cssModeVirtualInitialSet = true;\n            requestAnimationFrame(() => {\n              wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n            });\n          } else {\n            wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n          }\n          if (isVirtual) {\n            requestAnimationFrame(() => {\n              swiper.wrapperEl.style.scrollSnapType = \"\";\n              swiper._immediateVirtual = false;\n            });\n          }\n        } else {\n          if (!swiper.support.smoothScroll) {\n            animateCSSModeScroll({\n              swiper,\n              targetPosition: t,\n              side: isH ? \"left\" : \"top\",\n            });\n            return true;\n          }\n          wrapperEl.scrollTo({\n            [isH ? \"left\" : \"top\"]: t,\n            behavior: \"smooth\",\n          });\n        }\n        return true;\n      }\n      swiper.setTransition(speed);\n      swiper.setTranslate(translate2);\n      swiper.updateActiveIndex(slideIndex);\n      swiper.updateSlidesClasses();\n      swiper.emit(\"beforeTransitionStart\", speed, internal);\n      swiper.transitionStart(runCallbacks, direction);\n      if (speed === 0) {\n        swiper.transitionEnd(runCallbacks, direction);\n      } else if (!swiper.animating) {\n        swiper.animating = true;\n        if (!swiper.onSlideToWrapperTransitionEnd) {\n          swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e) {\n            if (!swiper || swiper.destroyed) return;\n            if (e.target !== this) return;\n            swiper.wrapperEl.removeEventListener(\n              \"transitionend\",\n              swiper.onSlideToWrapperTransitionEnd\n            );\n            swiper.onSlideToWrapperTransitionEnd = null;\n            delete swiper.onSlideToWrapperTransitionEnd;\n            swiper.transitionEnd(runCallbacks, direction);\n          };\n        }\n        swiper.wrapperEl.addEventListener(\n          \"transitionend\",\n          swiper.onSlideToWrapperTransitionEnd\n        );\n      }\n      return true;\n    }\n    function slideToLoop(\n      index = 0,\n      speed = this.params.speed,\n      runCallbacks = true,\n      internal\n    ) {\n      if (typeof index === \"string\") {\n        const indexAsNumber = parseInt(index, 10);\n        index = indexAsNumber;\n      }\n      const swiper = this;\n      let newIndex = index;\n      if (swiper.params.loop) {\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          newIndex = newIndex + swiper.virtual.slidesBefore;\n        } else {\n          newIndex = swiper.getSlideIndex(\n            swiper.slides.filter(\n              (slideEl) =>\n                slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === newIndex\n            )[0]\n          );\n        }\n      }\n      return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n    }\n    function slideNext(\n      speed = this.params.speed,\n      runCallbacks = true,\n      internal\n    ) {\n      const swiper = this;\n      const { enabled, params, animating } = swiper;\n      if (!enabled) return swiper;\n      let perGroup = params.slidesPerGroup;\n      if (\n        params.slidesPerView === \"auto\" &&\n        params.slidesPerGroup === 1 &&\n        params.slidesPerGroupAuto\n      ) {\n        perGroup = Math.max(swiper.slidesPerViewDynamic(\"current\", true), 1);\n      }\n      const increment =\n        swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding) return false;\n        swiper.loopFix({\n          direction: \"next\",\n        });\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n      }\n      if (params.rewind && swiper.isEnd) {\n        return swiper.slideTo(0, speed, runCallbacks, internal);\n      }\n      return swiper.slideTo(\n        swiper.activeIndex + increment,\n        speed,\n        runCallbacks,\n        internal\n      );\n    }\n    function slidePrev(\n      speed = this.params.speed,\n      runCallbacks = true,\n      internal\n    ) {\n      const swiper = this;\n      const { params, snapGrid, slidesGrid, rtlTranslate, enabled, animating } =\n        swiper;\n      if (!enabled) return swiper;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding) return false;\n        swiper.loopFix({\n          direction: \"prev\",\n        });\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n      }\n      const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;\n      function normalize(val) {\n        if (val < 0) return -Math.floor(Math.abs(val));\n        return Math.floor(val);\n      }\n      const normalizedTranslate = normalize(translate2);\n      const normalizedSnapGrid = snapGrid.map((val) => normalize(val));\n      let prevSnap =\n        snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n      if (typeof prevSnap === \"undefined\" && params.cssMode) {\n        let prevSnapIndex;\n        snapGrid.forEach((snap, snapIndex) => {\n          if (normalizedTranslate >= snap) {\n            prevSnapIndex = snapIndex;\n          }\n        });\n        if (typeof prevSnapIndex !== \"undefined\") {\n          prevSnap =\n            snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n        }\n      }\n      let prevIndex = 0;\n      if (typeof prevSnap !== \"undefined\") {\n        prevIndex = slidesGrid.indexOf(prevSnap);\n        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n        if (\n          params.slidesPerView === \"auto\" &&\n          params.slidesPerGroup === 1 &&\n          params.slidesPerGroupAuto\n        ) {\n          prevIndex =\n            prevIndex - swiper.slidesPerViewDynamic(\"previous\", true) + 1;\n          prevIndex = Math.max(prevIndex, 0);\n        }\n      }\n      if (params.rewind && swiper.isBeginning) {\n        const lastIndex =\n          swiper.params.virtual &&\n          swiper.params.virtual.enabled &&\n          swiper.virtual\n            ? swiper.virtual.slides.length - 1\n            : swiper.slides.length - 1;\n        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n      }\n      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n    }\n    function slideReset(\n      speed = this.params.speed,\n      runCallbacks = true,\n      internal\n    ) {\n      const swiper = this;\n      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n    }\n    function slideToClosest(\n      speed = this.params.speed,\n      runCallbacks = true,\n      internal,\n      threshold = 0.5\n    ) {\n      const swiper = this;\n      let index = swiper.activeIndex;\n      const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n      const snapIndex =\n        skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n      const translate2 = swiper.rtlTranslate\n        ? swiper.translate\n        : -swiper.translate;\n      if (translate2 >= swiper.snapGrid[snapIndex]) {\n        const currentSnap = swiper.snapGrid[snapIndex];\n        const nextSnap = swiper.snapGrid[snapIndex + 1];\n        if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {\n          index += swiper.params.slidesPerGroup;\n        }\n      } else {\n        const prevSnap = swiper.snapGrid[snapIndex - 1];\n        const currentSnap = swiper.snapGrid[snapIndex];\n        if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {\n          index -= swiper.params.slidesPerGroup;\n        }\n      }\n      index = Math.max(index, 0);\n      index = Math.min(index, swiper.slidesGrid.length - 1);\n      return swiper.slideTo(index, speed, runCallbacks, internal);\n    }\n    function slideToClickedSlide() {\n      const swiper = this;\n      const { params, slidesEl } = swiper;\n      const slidesPerView =\n        params.slidesPerView === \"auto\"\n          ? swiper.slidesPerViewDynamic()\n          : params.slidesPerView;\n      let slideToIndex = swiper.clickedIndex;\n      let realIndex;\n      const slideSelector = swiper.isElement\n        ? `swiper-slide`\n        : `.${params.slideClass}`;\n      if (params.loop) {\n        if (swiper.animating) return;\n        realIndex = parseInt(\n          swiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"),\n          10\n        );\n        if (params.centeredSlides) {\n          if (\n            slideToIndex < swiper.loopedSlides - slidesPerView / 2 ||\n            slideToIndex >\n              swiper.slides.length - swiper.loopedSlides + slidesPerView / 2\n          ) {\n            swiper.loopFix();\n            slideToIndex = swiper.getSlideIndex(\n              elementChildren(\n                slidesEl,\n                `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`\n              )[0]\n            );\n            nextTick(() => {\n              swiper.slideTo(slideToIndex);\n            });\n          } else {\n            swiper.slideTo(slideToIndex);\n          }\n        } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n          swiper.loopFix();\n          slideToIndex = swiper.getSlideIndex(\n            elementChildren(\n              slidesEl,\n              `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`\n            )[0]\n          );\n          nextTick(() => {\n            swiper.slideTo(slideToIndex);\n          });\n        } else {\n          swiper.slideTo(slideToIndex);\n        }\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    }\n    const slide = {\n      slideTo,\n      slideToLoop,\n      slideNext,\n      slidePrev,\n      slideReset,\n      slideToClosest,\n      slideToClickedSlide,\n    };\n    function loopCreate(slideRealIndex) {\n      const swiper = this;\n      const { params, slidesEl } = swiper;\n      if (!params.loop || (swiper.virtual && swiper.params.virtual.enabled))\n        return;\n      const slides = elementChildren(\n        slidesEl,\n        `.${params.slideClass}, swiper-slide`\n      );\n      slides.forEach((el, index) => {\n        el.setAttribute(\"data-swiper-slide-index\", index);\n      });\n      swiper.loopFix({\n        slideRealIndex,\n        direction: params.centeredSlides ? void 0 : \"next\",\n      });\n    }\n    function loopFix({\n      slideRealIndex,\n      slideTo: slideTo2 = true,\n      direction,\n      setTranslate: setTranslate2,\n      activeSlideIndex,\n      byController,\n      byMousewheel,\n    } = {}) {\n      const swiper = this;\n      if (!swiper.params.loop) return;\n      swiper.emit(\"beforeLoopFix\");\n      const { slides, allowSlidePrev, allowSlideNext, slidesEl, params } =\n        swiper;\n      swiper.allowSlidePrev = true;\n      swiper.allowSlideNext = true;\n      if (swiper.virtual && params.virtual.enabled) {\n        if (slideTo2) {\n          if (!params.centeredSlides && swiper.snapIndex === 0) {\n            swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n          } else if (\n            params.centeredSlides &&\n            swiper.snapIndex < params.slidesPerView\n          ) {\n            swiper.slideTo(\n              swiper.virtual.slides.length + swiper.snapIndex,\n              0,\n              false,\n              true\n            );\n          } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n            swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n          }\n        }\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        swiper.emit(\"loopFix\");\n        return;\n      }\n      const slidesPerView =\n        params.slidesPerView === \"auto\"\n          ? swiper.slidesPerViewDynamic()\n          : Math.ceil(parseFloat(params.slidesPerView, 10));\n      let loopedSlides = params.loopedSlides || slidesPerView;\n      if (loopedSlides % params.slidesPerGroup !== 0) {\n        loopedSlides +=\n          params.slidesPerGroup - (loopedSlides % params.slidesPerGroup);\n      }\n      swiper.loopedSlides = loopedSlides;\n      const prependSlidesIndexes = [];\n      const appendSlidesIndexes = [];\n      let activeIndex = swiper.activeIndex;\n      if (typeof activeSlideIndex === \"undefined\") {\n        activeSlideIndex = swiper.getSlideIndex(\n          swiper.slides.filter((el) =>\n            el.classList.contains(\"swiper-slide-active\")\n          )[0]\n        );\n      } else {\n        activeIndex = activeSlideIndex;\n      }\n      const isNext = direction === \"next\" || !direction;\n      const isPrev = direction === \"prev\" || !direction;\n      let slidesPrepended = 0;\n      let slidesAppended = 0;\n      if (activeSlideIndex < loopedSlides) {\n        slidesPrepended = Math.max(\n          loopedSlides - activeSlideIndex,\n          params.slidesPerGroup\n        );\n        for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n          const index = i - Math.floor(i / slides.length) * slides.length;\n          prependSlidesIndexes.push(slides.length - index - 1);\n        }\n      } else if (activeSlideIndex > swiper.slides.length - loopedSlides * 2) {\n        slidesAppended = Math.max(\n          activeSlideIndex - (swiper.slides.length - loopedSlides * 2),\n          params.slidesPerGroup\n        );\n        for (let i = 0; i < slidesAppended; i += 1) {\n          const index = i - Math.floor(i / slides.length) * slides.length;\n          appendSlidesIndexes.push(index);\n        }\n      }\n      if (isPrev) {\n        prependSlidesIndexes.forEach((index) => {\n          slidesEl.prepend(swiper.slides[index]);\n        });\n      }\n      if (isNext) {\n        appendSlidesIndexes.forEach((index) => {\n          slidesEl.append(swiper.slides[index]);\n        });\n      }\n      swiper.recalcSlides();\n      if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n      }\n      if (slideTo2) {\n        if (prependSlidesIndexes.length > 0 && isPrev) {\n          if (typeof slideRealIndex === \"undefined\") {\n            const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n            const newSlideTranslate =\n              swiper.slidesGrid[activeIndex + slidesPrepended];\n            const diff = newSlideTranslate - currentSlideTranslate;\n            if (byMousewheel) {\n              swiper.setTranslate(swiper.translate - diff);\n            } else {\n              swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n              if (setTranslate2) {\n                swiper.touches[swiper.isHorizontal() ? \"startX\" : \"startY\"] +=\n                  diff;\n              }\n            }\n          } else {\n            if (setTranslate2) {\n              swiper.slideToLoop(slideRealIndex, 0, false, true);\n            }\n          }\n        } else if (appendSlidesIndexes.length > 0 && isNext) {\n          if (typeof slideRealIndex === \"undefined\") {\n            const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n            const newSlideTranslate =\n              swiper.slidesGrid[activeIndex - slidesAppended];\n            const diff = newSlideTranslate - currentSlideTranslate;\n            if (byMousewheel) {\n              swiper.setTranslate(swiper.translate - diff);\n            } else {\n              swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n              if (setTranslate2) {\n                swiper.touches[swiper.isHorizontal() ? \"startX\" : \"startY\"] +=\n                  diff;\n              }\n            }\n          } else {\n            swiper.slideToLoop(slideRealIndex, 0, false, true);\n          }\n        }\n      }\n      swiper.allowSlidePrev = allowSlidePrev;\n      swiper.allowSlideNext = allowSlideNext;\n      if (swiper.controller && swiper.controller.control && !byController) {\n        const loopParams = {\n          slideRealIndex,\n          slideTo: false,\n          direction,\n          setTranslate: setTranslate2,\n          activeSlideIndex,\n          byController: true,\n        };\n        if (Array.isArray(swiper.controller.control)) {\n          swiper.controller.control.forEach((c) => {\n            if (c.params.loop) c.loopFix(loopParams);\n          });\n        } else if (\n          swiper.controller.control instanceof swiper.constructor &&\n          swiper.controller.control.params.loop\n        ) {\n          swiper.controller.control.loopFix(loopParams);\n        }\n      }\n      swiper.emit(\"loopFix\");\n    }\n    function loopDestroy() {\n      const swiper = this;\n      const { slides, params, slidesEl } = swiper;\n      if (!params.loop || (swiper.virtual && swiper.params.virtual.enabled))\n        return;\n      swiper.recalcSlides();\n      const newSlidesOrder = [];\n      slides.forEach((slideEl) => {\n        const index =\n          typeof slideEl.swiperSlideIndex === \"undefined\"\n            ? slideEl.getAttribute(\"data-swiper-slide-index\") * 1\n            : slideEl.swiperSlideIndex;\n        newSlidesOrder[index] = slideEl;\n      });\n      slides.forEach((slideEl) => {\n        slideEl.removeAttribute(\"data-swiper-slide-index\");\n      });\n      newSlidesOrder.forEach((slideEl) => {\n        slidesEl.append(slideEl);\n      });\n      swiper.recalcSlides();\n      swiper.slideTo(swiper.realIndex, 0);\n    }\n    const loop = {\n      loopCreate,\n      loopFix,\n      loopDestroy,\n    };\n    function setGrabCursor(moving) {\n      const swiper = this;\n      if (\n        !swiper.params.simulateTouch ||\n        (swiper.params.watchOverflow && swiper.isLocked) ||\n        swiper.params.cssMode\n      )\n        return;\n      const el =\n        swiper.params.touchEventsTarget === \"container\"\n          ? swiper.el\n          : swiper.wrapperEl;\n      if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n      }\n      el.style.cursor = \"move\";\n      el.style.cursor = moving ? \"grabbing\" : \"grab\";\n      if (swiper.isElement) {\n        requestAnimationFrame(() => {\n          swiper.__preventObserver__ = false;\n        });\n      }\n    }\n    function unsetGrabCursor() {\n      const swiper = this;\n      if (\n        (swiper.params.watchOverflow && swiper.isLocked) ||\n        swiper.params.cssMode\n      ) {\n        return;\n      }\n      if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n      }\n      swiper[\n        swiper.params.touchEventsTarget === \"container\" ? \"el\" : \"wrapperEl\"\n      ].style.cursor = \"\";\n      if (swiper.isElement) {\n        requestAnimationFrame(() => {\n          swiper.__preventObserver__ = false;\n        });\n      }\n    }\n    const grabCursor = {\n      setGrabCursor,\n      unsetGrabCursor,\n    };\n    function closestElement(selector, base = this) {\n      function __closestFrom(el) {\n        if (!el || el === getDocument() || el === getWindow()) return null;\n        if (el.assignedSlot) el = el.assignedSlot;\n        const found = el.closest(selector);\n        if (!found && !el.getRootNode) {\n          return null;\n        }\n        return found || __closestFrom(el.getRootNode().host);\n      }\n      return __closestFrom(base);\n    }\n    function onTouchStart(event2) {\n      const swiper = this;\n      const document2 = getDocument();\n      const window2 = getWindow();\n      const data = swiper.touchEventsData;\n      data.evCache.push(event2);\n      const { params, touches, enabled } = swiper;\n      if (!enabled) return;\n      if (!params.simulateTouch && event2.pointerType === \"mouse\") return;\n      if (swiper.animating && params.preventInteractionOnTransition) {\n        return;\n      }\n      if (!swiper.animating && params.cssMode && params.loop) {\n        swiper.loopFix();\n      }\n      let e = event2;\n      if (e.originalEvent) e = e.originalEvent;\n      let targetEl = e.target;\n      if (params.touchEventsTarget === \"wrapper\") {\n        if (!swiper.wrapperEl.contains(targetEl)) return;\n      }\n      if (\"which\" in e && e.which === 3) return;\n      if (\"button\" in e && e.button > 0) return;\n      if (data.isTouched && data.isMoved) return;\n      const swipingClassHasValue =\n        !!params.noSwipingClass && params.noSwipingClass !== \"\";\n      const eventPath = event2.composedPath\n        ? event2.composedPath()\n        : event2.path;\n      if (\n        swipingClassHasValue &&\n        e.target &&\n        e.target.shadowRoot &&\n        eventPath\n      ) {\n        targetEl = eventPath[0];\n      }\n      const noSwipingSelector = params.noSwipingSelector\n        ? params.noSwipingSelector\n        : `.${params.noSwipingClass}`;\n      const isTargetShadow = !!(e.target && e.target.shadowRoot);\n      if (\n        params.noSwiping &&\n        (isTargetShadow\n          ? closestElement(noSwipingSelector, targetEl)\n          : targetEl.closest(noSwipingSelector))\n      ) {\n        swiper.allowClick = true;\n        return;\n      }\n      if (params.swipeHandler) {\n        if (!targetEl.closest(params.swipeHandler)) return;\n      }\n      touches.currentX = e.pageX;\n      touches.currentY = e.pageY;\n      const startX = touches.currentX;\n      const startY = touches.currentY;\n      const edgeSwipeDetection =\n        params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n      const edgeSwipeThreshold =\n        params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n      if (\n        edgeSwipeDetection &&\n        (startX <= edgeSwipeThreshold ||\n          startX >= window2.innerWidth - edgeSwipeThreshold)\n      ) {\n        if (edgeSwipeDetection === \"prevent\") {\n          event2.preventDefault();\n        } else {\n          return;\n        }\n      }\n      Object.assign(data, {\n        isTouched: true,\n        isMoved: false,\n        allowTouchCallbacks: true,\n        isScrolling: void 0,\n        startMoving: void 0,\n      });\n      touches.startX = startX;\n      touches.startY = startY;\n      data.touchStartTime = now();\n      swiper.allowClick = true;\n      swiper.updateSize();\n      swiper.swipeDirection = void 0;\n      if (params.threshold > 0) data.allowThresholdMove = false;\n      let preventDefault = true;\n      if (targetEl.matches(data.focusableElements)) {\n        preventDefault = false;\n        if (targetEl.nodeName === \"SELECT\") {\n          data.isTouched = false;\n        }\n      }\n      if (\n        document2.activeElement &&\n        document2.activeElement.matches(data.focusableElements) &&\n        document2.activeElement !== targetEl\n      ) {\n        document2.activeElement.blur();\n      }\n      const shouldPreventDefault =\n        preventDefault &&\n        swiper.allowTouchMove &&\n        params.touchStartPreventDefault;\n      if (\n        (params.touchStartForcePreventDefault || shouldPreventDefault) &&\n        !targetEl.isContentEditable\n      ) {\n        e.preventDefault();\n      }\n      if (\n        swiper.params.freeMode &&\n        swiper.params.freeMode.enabled &&\n        swiper.freeMode &&\n        swiper.animating &&\n        !params.cssMode\n      ) {\n        swiper.freeMode.onTouchStart();\n      }\n      swiper.emit(\"touchStart\", e);\n    }\n    function onTouchMove(event2) {\n      const document2 = getDocument();\n      const swiper = this;\n      const data = swiper.touchEventsData;\n      const { params, touches, rtlTranslate: rtl, enabled } = swiper;\n      if (!enabled) return;\n      if (!params.simulateTouch && event2.pointerType === \"mouse\") return;\n      let e = event2;\n      if (e.originalEvent) e = e.originalEvent;\n      if (!data.isTouched) {\n        if (data.startMoving && data.isScrolling) {\n          swiper.emit(\"touchMoveOpposite\", e);\n        }\n        return;\n      }\n      const pointerIndex = data.evCache.findIndex(\n        (cachedEv) => cachedEv.pointerId === e.pointerId\n      );\n      if (pointerIndex >= 0) data.evCache[pointerIndex] = e;\n      const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n      const pageX = targetTouch.pageX;\n      const pageY = targetTouch.pageY;\n      if (e.preventedByNestedSwiper) {\n        touches.startX = pageX;\n        touches.startY = pageY;\n        return;\n      }\n      if (!swiper.allowTouchMove) {\n        if (!e.target.matches(data.focusableElements)) {\n          swiper.allowClick = false;\n        }\n        if (data.isTouched) {\n          Object.assign(touches, {\n            startX: pageX,\n            startY: pageY,\n            prevX: swiper.touches.currentX,\n            prevY: swiper.touches.currentY,\n            currentX: pageX,\n            currentY: pageY,\n          });\n          data.touchStartTime = now();\n        }\n        return;\n      }\n      if (params.touchReleaseOnEdges && !params.loop) {\n        if (swiper.isVertical()) {\n          if (\n            (pageY < touches.startY &&\n              swiper.translate <= swiper.maxTranslate()) ||\n            (pageY > touches.startY &&\n              swiper.translate >= swiper.minTranslate())\n          ) {\n            data.isTouched = false;\n            data.isMoved = false;\n            return;\n          }\n        } else if (\n          (pageX < touches.startX &&\n            swiper.translate <= swiper.maxTranslate()) ||\n          (pageX > touches.startX && swiper.translate >= swiper.minTranslate())\n        ) {\n          return;\n        }\n      }\n      if (document2.activeElement) {\n        if (\n          e.target === document2.activeElement &&\n          e.target.matches(data.focusableElements)\n        ) {\n          data.isMoved = true;\n          swiper.allowClick = false;\n          return;\n        }\n      }\n      if (data.allowTouchCallbacks) {\n        swiper.emit(\"touchMove\", e);\n      }\n      if (e.targetTouches && e.targetTouches.length > 1) return;\n      touches.currentX = pageX;\n      touches.currentY = pageY;\n      const diffX = touches.currentX - touches.startX;\n      const diffY = touches.currentY - touches.startY;\n      if (\n        swiper.params.threshold &&\n        Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold\n      )\n        return;\n      if (typeof data.isScrolling === \"undefined\") {\n        let touchAngle;\n        if (\n          (swiper.isHorizontal() && touches.currentY === touches.startY) ||\n          (swiper.isVertical() && touches.currentX === touches.startX)\n        ) {\n          data.isScrolling = false;\n        } else {\n          if (diffX * diffX + diffY * diffY >= 25) {\n            touchAngle =\n              (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;\n            data.isScrolling = swiper.isHorizontal()\n              ? touchAngle > params.touchAngle\n              : 90 - touchAngle > params.touchAngle;\n          }\n        }\n      }\n      if (data.isScrolling) {\n        swiper.emit(\"touchMoveOpposite\", e);\n      }\n      if (typeof data.startMoving === \"undefined\") {\n        if (\n          touches.currentX !== touches.startX ||\n          touches.currentY !== touches.startY\n        ) {\n          data.startMoving = true;\n        }\n      }\n      if (\n        data.isScrolling ||\n        (swiper.zoom &&\n          swiper.params.zoom &&\n          swiper.params.zoom.enabled &&\n          data.evCache.length > 1)\n      ) {\n        data.isTouched = false;\n        return;\n      }\n      if (!data.startMoving) {\n        return;\n      }\n      swiper.allowClick = false;\n      if (!params.cssMode && e.cancelable) {\n        e.preventDefault();\n      }\n      if (params.touchMoveStopPropagation && !params.nested) {\n        e.stopPropagation();\n      }\n      let diff = swiper.isHorizontal() ? diffX : diffY;\n      let touchesDiff = swiper.isHorizontal()\n        ? touches.currentX - touches.previousX\n        : touches.currentY - touches.previousY;\n      if (params.oneWayMovement) {\n        diff = Math.abs(diff) * (rtl ? 1 : -1);\n        touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n      }\n      touches.diff = diff;\n      diff *= params.touchRatio;\n      if (rtl) {\n        diff = -diff;\n        touchesDiff = -touchesDiff;\n      }\n      const prevTouchesDirection = swiper.touchesDirection;\n      swiper.swipeDirection = diff > 0 ? \"prev\" : \"next\";\n      swiper.touchesDirection = touchesDiff > 0 ? \"prev\" : \"next\";\n      const isLoop = swiper.params.loop && !params.cssMode;\n      if (!data.isMoved) {\n        if (isLoop) {\n          swiper.loopFix({\n            direction: swiper.swipeDirection,\n          });\n        }\n        data.startTranslate = swiper.getTranslate();\n        swiper.setTransition(0);\n        if (swiper.animating) {\n          const evt = new window.CustomEvent(\"transitionend\", {\n            bubbles: true,\n            cancelable: true,\n          });\n          swiper.wrapperEl.dispatchEvent(evt);\n        }\n        data.allowMomentumBounce = false;\n        if (\n          params.grabCursor &&\n          (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)\n        ) {\n          swiper.setGrabCursor(true);\n        }\n        swiper.emit(\"sliderFirstMove\", e);\n      }\n      let loopFixed;\n      if (\n        data.isMoved &&\n        prevTouchesDirection !== swiper.touchesDirection &&\n        isLoop &&\n        Math.abs(diff) >= 1\n      ) {\n        swiper.loopFix({\n          direction: swiper.swipeDirection,\n          setTranslate: true,\n        });\n        loopFixed = true;\n      }\n      swiper.emit(\"sliderMove\", e);\n      data.isMoved = true;\n      data.currentTranslate = diff + data.startTranslate;\n      let disableParentSwiper = true;\n      let resistanceRatio = params.resistanceRatio;\n      if (params.touchReleaseOnEdges) {\n        resistanceRatio = 0;\n      }\n      if (diff > 0) {\n        if (\n          isLoop &&\n          !loopFixed &&\n          data.currentTranslate >\n            (params.centeredSlides\n              ? swiper.minTranslate() - swiper.size / 2\n              : swiper.minTranslate())\n        ) {\n          swiper.loopFix({\n            direction: \"prev\",\n            setTranslate: true,\n            activeSlideIndex: 0,\n          });\n        }\n        if (data.currentTranslate > swiper.minTranslate()) {\n          disableParentSwiper = false;\n          if (params.resistance) {\n            data.currentTranslate =\n              swiper.minTranslate() -\n              1 +\n              (-swiper.minTranslate() + data.startTranslate + diff) **\n                resistanceRatio;\n          }\n        }\n      } else if (diff < 0) {\n        if (\n          isLoop &&\n          !loopFixed &&\n          data.currentTranslate <\n            (params.centeredSlides\n              ? swiper.maxTranslate() + swiper.size / 2\n              : swiper.maxTranslate())\n        ) {\n          swiper.loopFix({\n            direction: \"next\",\n            setTranslate: true,\n            activeSlideIndex:\n              swiper.slides.length -\n              (params.slidesPerView === \"auto\"\n                ? swiper.slidesPerViewDynamic()\n                : Math.ceil(parseFloat(params.slidesPerView, 10))),\n          });\n        }\n        if (data.currentTranslate < swiper.maxTranslate()) {\n          disableParentSwiper = false;\n          if (params.resistance) {\n            data.currentTranslate =\n              swiper.maxTranslate() +\n              1 -\n              (swiper.maxTranslate() - data.startTranslate - diff) **\n                resistanceRatio;\n          }\n        }\n      }\n      if (disableParentSwiper) {\n        e.preventedByNestedSwiper = true;\n      }\n      if (\n        !swiper.allowSlideNext &&\n        swiper.swipeDirection === \"next\" &&\n        data.currentTranslate < data.startTranslate\n      ) {\n        data.currentTranslate = data.startTranslate;\n      }\n      if (\n        !swiper.allowSlidePrev &&\n        swiper.swipeDirection === \"prev\" &&\n        data.currentTranslate > data.startTranslate\n      ) {\n        data.currentTranslate = data.startTranslate;\n      }\n      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n        data.currentTranslate = data.startTranslate;\n      }\n      if (params.threshold > 0) {\n        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n          if (!data.allowThresholdMove) {\n            data.allowThresholdMove = true;\n            touches.startX = touches.currentX;\n            touches.startY = touches.currentY;\n            data.currentTranslate = data.startTranslate;\n            touches.diff = swiper.isHorizontal()\n              ? touches.currentX - touches.startX\n              : touches.currentY - touches.startY;\n            return;\n          }\n        } else {\n          data.currentTranslate = data.startTranslate;\n          return;\n        }\n      }\n      if (!params.followFinger || params.cssMode) return;\n      if (\n        (params.freeMode && params.freeMode.enabled && swiper.freeMode) ||\n        params.watchSlidesProgress\n      ) {\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      if (\n        swiper.params.freeMode &&\n        params.freeMode.enabled &&\n        swiper.freeMode\n      ) {\n        swiper.freeMode.onTouchMove();\n      }\n      swiper.updateProgress(data.currentTranslate);\n      swiper.setTranslate(data.currentTranslate);\n    }\n    function onTouchEnd(event2) {\n      const swiper = this;\n      const data = swiper.touchEventsData;\n      const pointerIndex = data.evCache.findIndex(\n        (cachedEv) => cachedEv.pointerId === event2.pointerId\n      );\n      if (pointerIndex >= 0) {\n        data.evCache.splice(pointerIndex, 1);\n      }\n      if (\n        [\"pointercancel\", \"pointerout\", \"pointerleave\"].includes(event2.type)\n      ) {\n        const proceed =\n          event2.type === \"pointercancel\" &&\n          (swiper.browser.isSafari || swiper.browser.isWebView);\n        if (!proceed) {\n          return;\n        }\n      }\n      const {\n        params,\n        touches,\n        rtlTranslate: rtl,\n        slidesGrid,\n        enabled,\n      } = swiper;\n      if (!enabled) return;\n      if (!params.simulateTouch && event2.pointerType === \"mouse\") return;\n      let e = event2;\n      if (e.originalEvent) e = e.originalEvent;\n      if (data.allowTouchCallbacks) {\n        swiper.emit(\"touchEnd\", e);\n      }\n      data.allowTouchCallbacks = false;\n      if (!data.isTouched) {\n        if (data.isMoved && params.grabCursor) {\n          swiper.setGrabCursor(false);\n        }\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n      }\n      if (\n        params.grabCursor &&\n        data.isMoved &&\n        data.isTouched &&\n        (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)\n      ) {\n        swiper.setGrabCursor(false);\n      }\n      const touchEndTime = now();\n      const timeDiff = touchEndTime - data.touchStartTime;\n      if (swiper.allowClick) {\n        const pathTree = e.path || (e.composedPath && e.composedPath());\n        swiper.updateClickedSlide((pathTree && pathTree[0]) || e.target);\n        swiper.emit(\"tap click\", e);\n        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n          swiper.emit(\"doubleTap doubleClick\", e);\n        }\n      }\n      data.lastClickTime = now();\n      nextTick(() => {\n        if (!swiper.destroyed) swiper.allowClick = true;\n      });\n      if (\n        !data.isTouched ||\n        !data.isMoved ||\n        !swiper.swipeDirection ||\n        touches.diff === 0 ||\n        data.currentTranslate === data.startTranslate\n      ) {\n        data.isTouched = false;\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n      }\n      data.isTouched = false;\n      data.isMoved = false;\n      data.startMoving = false;\n      let currentPos;\n      if (params.followFinger) {\n        currentPos = rtl ? swiper.translate : -swiper.translate;\n      } else {\n        currentPos = -data.currentTranslate;\n      }\n      if (params.cssMode) {\n        return;\n      }\n      if (swiper.params.freeMode && params.freeMode.enabled) {\n        swiper.freeMode.onTouchEnd({\n          currentPos,\n        });\n        return;\n      }\n      let stopIndex = 0;\n      let groupSize = swiper.slidesSizesGrid[0];\n      for (\n        let i = 0;\n        i < slidesGrid.length;\n        i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup\n      ) {\n        const increment2 =\n          i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n        if (typeof slidesGrid[i + increment2] !== \"undefined\") {\n          if (\n            currentPos >= slidesGrid[i] &&\n            currentPos < slidesGrid[i + increment2]\n          ) {\n            stopIndex = i;\n            groupSize = slidesGrid[i + increment2] - slidesGrid[i];\n          }\n        } else if (currentPos >= slidesGrid[i]) {\n          stopIndex = i;\n          groupSize =\n            slidesGrid[slidesGrid.length - 1] -\n            slidesGrid[slidesGrid.length - 2];\n        }\n      }\n      let rewindFirstIndex = null;\n      let rewindLastIndex = null;\n      if (params.rewind) {\n        if (swiper.isBeginning) {\n          rewindLastIndex =\n            swiper.params.virtual &&\n            swiper.params.virtual.enabled &&\n            swiper.virtual\n              ? swiper.virtual.slides.length - 1\n              : swiper.slides.length - 1;\n        } else if (swiper.isEnd) {\n          rewindFirstIndex = 0;\n        }\n      }\n      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n      const increment =\n        stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n      if (timeDiff > params.longSwipesMs) {\n        if (!params.longSwipes) {\n          swiper.slideTo(swiper.activeIndex);\n          return;\n        }\n        if (swiper.swipeDirection === \"next\") {\n          if (ratio >= params.longSwipesRatio)\n            swiper.slideTo(\n              params.rewind && swiper.isEnd\n                ? rewindFirstIndex\n                : stopIndex + increment\n            );\n          else swiper.slideTo(stopIndex);\n        }\n        if (swiper.swipeDirection === \"prev\") {\n          if (ratio > 1 - params.longSwipesRatio) {\n            swiper.slideTo(stopIndex + increment);\n          } else if (\n            rewindLastIndex !== null &&\n            ratio < 0 &&\n            Math.abs(ratio) > params.longSwipesRatio\n          ) {\n            swiper.slideTo(rewindLastIndex);\n          } else {\n            swiper.slideTo(stopIndex);\n          }\n        }\n      } else {\n        if (!params.shortSwipes) {\n          swiper.slideTo(swiper.activeIndex);\n          return;\n        }\n        const isNavButtonTarget =\n          swiper.navigation &&\n          (e.target === swiper.navigation.nextEl ||\n            e.target === swiper.navigation.prevEl);\n        if (!isNavButtonTarget) {\n          if (swiper.swipeDirection === \"next\") {\n            swiper.slideTo(\n              rewindFirstIndex !== null\n                ? rewindFirstIndex\n                : stopIndex + increment\n            );\n          }\n          if (swiper.swipeDirection === \"prev\") {\n            swiper.slideTo(\n              rewindLastIndex !== null ? rewindLastIndex : stopIndex\n            );\n          }\n        } else if (e.target === swiper.navigation.nextEl) {\n          swiper.slideTo(stopIndex + increment);\n        } else {\n          swiper.slideTo(stopIndex);\n        }\n      }\n    }\n    let timeout;\n    function onResize() {\n      const swiper = this;\n      const { params, el } = swiper;\n      if (el && el.offsetWidth === 0) return;\n      if (params.breakpoints) {\n        swiper.setBreakpoint();\n      }\n      const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      swiper.allowSlideNext = true;\n      swiper.allowSlidePrev = true;\n      swiper.updateSize();\n      swiper.updateSlides();\n      swiper.updateSlidesClasses();\n      const isVirtualLoop = isVirtual && params.loop;\n      if (\n        (params.slidesPerView === \"auto\" || params.slidesPerView > 1) &&\n        swiper.isEnd &&\n        !swiper.isBeginning &&\n        !swiper.params.centeredSlides &&\n        !isVirtualLoop\n      ) {\n        swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n      } else {\n        if (swiper.params.loop && !isVirtual) {\n          swiper.slideToLoop(swiper.realIndex, 0, false, true);\n        } else {\n          swiper.slideTo(swiper.activeIndex, 0, false, true);\n        }\n      }\n      if (\n        swiper.autoplay &&\n        swiper.autoplay.running &&\n        swiper.autoplay.paused\n      ) {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => {\n          if (\n            swiper.autoplay &&\n            swiper.autoplay.running &&\n            swiper.autoplay.paused\n          ) {\n            swiper.autoplay.resume();\n          }\n        }, 500);\n      }\n      swiper.allowSlidePrev = allowSlidePrev;\n      swiper.allowSlideNext = allowSlideNext;\n      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n        swiper.checkOverflow();\n      }\n    }\n    function onClick(e) {\n      const swiper = this;\n      if (!swiper.enabled) return;\n      if (!swiper.allowClick) {\n        if (swiper.params.preventClicks) e.preventDefault();\n        if (swiper.params.preventClicksPropagation && swiper.animating) {\n          e.stopPropagation();\n          e.stopImmediatePropagation();\n        }\n      }\n    }\n    function onScroll() {\n      const swiper = this;\n      const { wrapperEl, rtlTranslate, enabled } = swiper;\n      if (!enabled) return;\n      swiper.previousTranslate = swiper.translate;\n      if (swiper.isHorizontal()) {\n        swiper.translate = -wrapperEl.scrollLeft;\n      } else {\n        swiper.translate = -wrapperEl.scrollTop;\n      }\n      if (swiper.translate === 0) swiper.translate = 0;\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n      let newProgress;\n      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n      if (translatesDiff === 0) {\n        newProgress = 0;\n      } else {\n        newProgress =\n          (swiper.translate - swiper.minTranslate()) / translatesDiff;\n      }\n      if (newProgress !== swiper.progress) {\n        swiper.updateProgress(\n          rtlTranslate ? -swiper.translate : swiper.translate\n        );\n      }\n      swiper.emit(\"setTranslate\", swiper.translate, false);\n    }\n    const processLazyPreloader = (swiper, imageEl) => {\n      if (!swiper || swiper.destroyed || !swiper.params) return;\n      const slideSelector = () =>\n        swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n      const slideEl = imageEl.closest(slideSelector());\n      if (slideEl) {\n        const lazyEl = slideEl.querySelector(\n          `.${swiper.params.lazyPreloaderClass}`\n        );\n        if (lazyEl) lazyEl.remove();\n      }\n    };\n    function onLoad(e) {\n      const swiper = this;\n      processLazyPreloader(swiper, e.target);\n      swiper.update();\n    }\n    let dummyEventAttached = false;\n    function dummyEventListener() {}\n    const events = (swiper, method) => {\n      const document2 = getDocument();\n      const { params, el, wrapperEl, device } = swiper;\n      const capture = !!params.nested;\n      const domMethod =\n        method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n      const swiperMethod = method;\n      el[domMethod](\"pointerdown\", swiper.onTouchStart, {\n        passive: false,\n      });\n      document2[domMethod](\"pointermove\", swiper.onTouchMove, {\n        passive: false,\n        capture,\n      });\n      document2[domMethod](\"pointerup\", swiper.onTouchEnd, {\n        passive: true,\n      });\n      document2[domMethod](\"pointercancel\", swiper.onTouchEnd, {\n        passive: true,\n      });\n      document2[domMethod](\"pointerout\", swiper.onTouchEnd, {\n        passive: true,\n      });\n      document2[domMethod](\"pointerleave\", swiper.onTouchEnd, {\n        passive: true,\n      });\n      if (params.preventClicks || params.preventClicksPropagation) {\n        el[domMethod](\"click\", swiper.onClick, true);\n      }\n      if (params.cssMode) {\n        wrapperEl[domMethod](\"scroll\", swiper.onScroll);\n      }\n      if (params.updateOnWindowResize) {\n        swiper[swiperMethod](\n          device.ios || device.android\n            ? \"resize orientationchange observerUpdate\"\n            : \"resize observerUpdate\",\n          onResize,\n          true\n        );\n      } else {\n        swiper[swiperMethod](\"observerUpdate\", onResize, true);\n      }\n      el[domMethod](\"load\", swiper.onLoad, {\n        capture: true,\n      });\n    };\n    function attachEvents() {\n      const swiper = this;\n      const document2 = getDocument();\n      const { params } = swiper;\n      swiper.onTouchStart = onTouchStart.bind(swiper);\n      swiper.onTouchMove = onTouchMove.bind(swiper);\n      swiper.onTouchEnd = onTouchEnd.bind(swiper);\n      if (params.cssMode) {\n        swiper.onScroll = onScroll.bind(swiper);\n      }\n      swiper.onClick = onClick.bind(swiper);\n      swiper.onLoad = onLoad.bind(swiper);\n      if (!dummyEventAttached) {\n        document2.addEventListener(\"touchstart\", dummyEventListener);\n        dummyEventAttached = true;\n      }\n      events(swiper, \"on\");\n    }\n    function detachEvents() {\n      const swiper = this;\n      events(swiper, \"off\");\n    }\n    const events$1 = {\n      attachEvents,\n      detachEvents,\n    };\n    const isGridEnabled = (swiper, params) => {\n      return swiper.grid && params.grid && params.grid.rows > 1;\n    };\n    function setBreakpoint() {\n      const swiper = this;\n      const { realIndex, initialized, params, el } = swiper;\n      const breakpoints2 = params.breakpoints;\n      if (\n        !breakpoints2 ||\n        (breakpoints2 && Object.keys(breakpoints2).length === 0)\n      )\n        return;\n      const breakpoint = swiper.getBreakpoint(\n        breakpoints2,\n        swiper.params.breakpointsBase,\n        swiper.el\n      );\n      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n      const breakpointOnlyParams =\n        breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;\n      const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n      const wasMultiRow = isGridEnabled(swiper, params);\n      const isMultiRow = isGridEnabled(swiper, breakpointParams);\n      const wasEnabled = params.enabled;\n      if (wasMultiRow && !isMultiRow) {\n        el.classList.remove(\n          `${params.containerModifierClass}grid`,\n          `${params.containerModifierClass}grid-column`\n        );\n        swiper.emitContainerClasses();\n      } else if (!wasMultiRow && isMultiRow) {\n        el.classList.add(`${params.containerModifierClass}grid`);\n        if (\n          (breakpointParams.grid.fill &&\n            breakpointParams.grid.fill === \"column\") ||\n          (!breakpointParams.grid.fill && params.grid.fill === \"column\")\n        ) {\n          el.classList.add(`${params.containerModifierClass}grid-column`);\n        }\n        swiper.emitContainerClasses();\n      }\n      [\"navigation\", \"pagination\", \"scrollbar\"].forEach((prop) => {\n        const wasModuleEnabled = params[prop] && params[prop].enabled;\n        const isModuleEnabled =\n          breakpointParams[prop] && breakpointParams[prop].enabled;\n        if (wasModuleEnabled && !isModuleEnabled) {\n          swiper[prop].disable();\n        }\n        if (!wasModuleEnabled && isModuleEnabled) {\n          swiper[prop].enable();\n        }\n      });\n      const directionChanged =\n        breakpointParams.direction &&\n        breakpointParams.direction !== params.direction;\n      const needsReLoop =\n        params.loop &&\n        (breakpointParams.slidesPerView !== params.slidesPerView ||\n          directionChanged);\n      if (directionChanged && initialized) {\n        swiper.changeDirection();\n      }\n      extend(swiper.params, breakpointParams);\n      const isEnabled = swiper.params.enabled;\n      Object.assign(swiper, {\n        allowTouchMove: swiper.params.allowTouchMove,\n        allowSlideNext: swiper.params.allowSlideNext,\n        allowSlidePrev: swiper.params.allowSlidePrev,\n      });\n      if (wasEnabled && !isEnabled) {\n        swiper.disable();\n      } else if (!wasEnabled && isEnabled) {\n        swiper.enable();\n      }\n      swiper.currentBreakpoint = breakpoint;\n      swiper.emit(\"_beforeBreakpoint\", breakpointParams);\n      if (needsReLoop && initialized) {\n        swiper.loopDestroy();\n        swiper.loopCreate(realIndex);\n        swiper.updateSlides();\n      }\n      swiper.emit(\"breakpoint\", breakpointParams);\n    }\n    function getBreakpoint(breakpoints2, base = \"window\", containerEl) {\n      if (!breakpoints2 || (base === \"container\" && !containerEl))\n        return void 0;\n      let breakpoint = false;\n      const window2 = getWindow();\n      const currentHeight =\n        base === \"window\" ? window2.innerHeight : containerEl.clientHeight;\n      const points = Object.keys(breakpoints2).map((point) => {\n        if (typeof point === \"string\" && point.indexOf(\"@\") === 0) {\n          const minRatio = parseFloat(point.substr(1));\n          const value = currentHeight * minRatio;\n          return {\n            value,\n            point,\n          };\n        }\n        return {\n          value: point,\n          point,\n        };\n      });\n      points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n      for (let i = 0; i < points.length; i += 1) {\n        const { point, value } = points[i];\n        if (base === \"window\") {\n          if (window2.matchMedia(`(min-width: ${value}px)`).matches) {\n            breakpoint = point;\n          }\n        } else if (value <= containerEl.clientWidth) {\n          breakpoint = point;\n        }\n      }\n      return breakpoint || \"max\";\n    }\n    const breakpoints = {\n      setBreakpoint,\n      getBreakpoint,\n    };\n    function prepareClasses(entries, prefix) {\n      const resultClasses = [];\n      entries.forEach((item) => {\n        if (typeof item === \"object\") {\n          Object.keys(item).forEach((classNames) => {\n            if (item[classNames]) {\n              resultClasses.push(prefix + classNames);\n            }\n          });\n        } else if (typeof item === \"string\") {\n          resultClasses.push(prefix + item);\n        }\n      });\n      return resultClasses;\n    }\n    function addClasses() {\n      const swiper = this;\n      const { classNames, params, rtl, el, device } = swiper;\n      const suffixes = prepareClasses(\n        [\n          \"initialized\",\n          params.direction,\n          {\n            \"free-mode\": swiper.params.freeMode && params.freeMode.enabled,\n          },\n          {\n            autoheight: params.autoHeight,\n          },\n          {\n            rtl: rtl,\n          },\n          {\n            grid: params.grid && params.grid.rows > 1,\n          },\n          {\n            \"grid-column\":\n              params.grid &&\n              params.grid.rows > 1 &&\n              params.grid.fill === \"column\",\n          },\n          {\n            android: device.android,\n          },\n          {\n            ios: device.ios,\n          },\n          {\n            \"css-mode\": params.cssMode,\n          },\n          {\n            centered: params.cssMode && params.centeredSlides,\n          },\n          {\n            \"watch-progress\": params.watchSlidesProgress,\n          },\n        ],\n        params.containerModifierClass\n      );\n      classNames.push(...suffixes);\n      el.classList.add(...classNames);\n      swiper.emitContainerClasses();\n    }\n    function removeClasses() {\n      const swiper = this;\n      const { el, classNames } = swiper;\n      el.classList.remove(...classNames);\n      swiper.emitContainerClasses();\n    }\n    const classes = {\n      addClasses,\n      removeClasses,\n    };\n    function checkOverflow() {\n      const swiper = this;\n      const { isLocked: wasLocked, params } = swiper;\n      const { slidesOffsetBefore } = params;\n      if (slidesOffsetBefore) {\n        const lastSlideIndex = swiper.slides.length - 1;\n        const lastSlideRightEdge =\n          swiper.slidesGrid[lastSlideIndex] +\n          swiper.slidesSizesGrid[lastSlideIndex] +\n          slidesOffsetBefore * 2;\n        swiper.isLocked = swiper.size > lastSlideRightEdge;\n      } else {\n        swiper.isLocked = swiper.snapGrid.length === 1;\n      }\n      if (params.allowSlideNext === true) {\n        swiper.allowSlideNext = !swiper.isLocked;\n      }\n      if (params.allowSlidePrev === true) {\n        swiper.allowSlidePrev = !swiper.isLocked;\n      }\n      if (wasLocked && wasLocked !== swiper.isLocked) {\n        swiper.isEnd = false;\n      }\n      if (wasLocked !== swiper.isLocked) {\n        swiper.emit(swiper.isLocked ? \"lock\" : \"unlock\");\n      }\n    }\n    const checkOverflow$1 = {\n      checkOverflow,\n    };\n    const defaults = {\n      init: true,\n      direction: \"horizontal\",\n      oneWayMovement: false,\n      touchEventsTarget: \"wrapper\",\n      initialSlide: 0,\n      speed: 300,\n      cssMode: false,\n      updateOnWindowResize: true,\n      resizeObserver: true,\n      nested: false,\n      createElements: false,\n      enabled: true,\n      focusableElements:\n        \"input, select, option, textarea, button, video, label\",\n      // Overrides\n      width: null,\n      height: null,\n      //\n      preventInteractionOnTransition: false,\n      // ssr\n      userAgent: null,\n      url: null,\n      // To support iOS's swipe-to-go-back gesture (when being used in-app).\n      edgeSwipeDetection: false,\n      edgeSwipeThreshold: 20,\n      // Autoheight\n      autoHeight: false,\n      // Set wrapper width\n      setWrapperSize: false,\n      // Virtual Translate\n      virtualTranslate: false,\n      // Effects\n      effect: \"slide\",\n      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n      // Breakpoints\n      breakpoints: void 0,\n      breakpointsBase: \"window\",\n      // Slides grid\n      spaceBetween: 0,\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      slidesPerGroupSkip: 0,\n      slidesPerGroupAuto: false,\n      centeredSlides: false,\n      centeredSlidesBounds: false,\n      slidesOffsetBefore: 0,\n      // in px\n      slidesOffsetAfter: 0,\n      // in px\n      normalizeSlideIndex: true,\n      centerInsufficientSlides: false,\n      // Disable swiper and hide navigation when container not overflow\n      watchOverflow: true,\n      // Round length\n      roundLengths: false,\n      // Touches\n      touchRatio: 1,\n      touchAngle: 45,\n      simulateTouch: true,\n      shortSwipes: true,\n      longSwipes: true,\n      longSwipesRatio: 0.5,\n      longSwipesMs: 300,\n      followFinger: true,\n      allowTouchMove: true,\n      threshold: 5,\n      touchMoveStopPropagation: false,\n      touchStartPreventDefault: true,\n      touchStartForcePreventDefault: false,\n      touchReleaseOnEdges: false,\n      // Unique Navigation Elements\n      uniqueNavElements: true,\n      // Resistance\n      resistance: true,\n      resistanceRatio: 0.85,\n      // Progress\n      watchSlidesProgress: false,\n      // Cursor\n      grabCursor: false,\n      // Clicks\n      preventClicks: true,\n      preventClicksPropagation: true,\n      slideToClickedSlide: false,\n      // loop\n      loop: false,\n      loopedSlides: null,\n      loopPreventsSliding: true,\n      // rewind\n      rewind: false,\n      // Swiping/no swiping\n      allowSlidePrev: true,\n      allowSlideNext: true,\n      swipeHandler: null,\n      // '.swipe-handler',\n      noSwiping: true,\n      noSwipingClass: \"swiper-no-swiping\",\n      noSwipingSelector: null,\n      // Passive Listeners\n      passiveListeners: true,\n      maxBackfaceHiddenSlides: 10,\n      // NS\n      containerModifierClass: \"swiper-\",\n      // NEW\n      slideClass: \"swiper-slide\",\n      slideActiveClass: \"swiper-slide-active\",\n      slideVisibleClass: \"swiper-slide-visible\",\n      slideNextClass: \"swiper-slide-next\",\n      slidePrevClass: \"swiper-slide-prev\",\n      wrapperClass: \"swiper-wrapper\",\n      lazyPreloaderClass: \"swiper-lazy-preloader\",\n      // Callbacks\n      runCallbacksOnInit: true,\n      // Internals\n      _emitClasses: false,\n    };\n    function moduleExtendParams(params, allModulesParams) {\n      return function extendParams(obj = {}) {\n        const moduleParamName = Object.keys(obj)[0];\n        const moduleParams = obj[moduleParamName];\n        if (typeof moduleParams !== \"object\" || moduleParams === null) {\n          extend(allModulesParams, obj);\n          return;\n        }\n        if (\n          [\"navigation\", \"pagination\", \"scrollbar\"].indexOf(moduleParamName) >=\n            0 &&\n          params[moduleParamName] === true\n        ) {\n          params[moduleParamName] = {\n            auto: true,\n          };\n        }\n        if (!(moduleParamName in params && \"enabled\" in moduleParams)) {\n          extend(allModulesParams, obj);\n          return;\n        }\n        if (params[moduleParamName] === true) {\n          params[moduleParamName] = {\n            enabled: true,\n          };\n        }\n        if (\n          typeof params[moduleParamName] === \"object\" &&\n          !(\"enabled\" in params[moduleParamName])\n        ) {\n          params[moduleParamName].enabled = true;\n        }\n        if (!params[moduleParamName])\n          params[moduleParamName] = {\n            enabled: false,\n          };\n        extend(allModulesParams, obj);\n      };\n    }\n    const prototypes = {\n      eventsEmitter,\n      update,\n      translate,\n      transition,\n      slide,\n      loop,\n      grabCursor,\n      events: events$1,\n      breakpoints,\n      checkOverflow: checkOverflow$1,\n      classes,\n    };\n    const extendedDefaults = {};\n    class Swiper {\n      constructor(...args) {\n        let el;\n        let params;\n        if (\n          args.length === 1 &&\n          args[0].constructor &&\n          Object.prototype.toString.call(args[0]).slice(8, -1) === \"Object\"\n        ) {\n          params = args[0];\n        } else {\n          [el, params] = args;\n        }\n        if (!params) params = {};\n        params = extend({}, params);\n        if (el && !params.el) params.el = el;\n        const document2 = getDocument();\n        if (\n          params.el &&\n          typeof params.el === \"string\" &&\n          document2.querySelectorAll(params.el).length > 1\n        ) {\n          const swipers = [];\n          document2.querySelectorAll(params.el).forEach((containerEl) => {\n            const newParams = extend({}, params, {\n              el: containerEl,\n            });\n            swipers.push(new Swiper(newParams));\n          });\n          return swipers;\n        }\n        const swiper = this;\n        swiper.__swiper__ = true;\n        swiper.support = getSupport();\n        swiper.device = getDevice({\n          userAgent: params.userAgent,\n        });\n        swiper.browser = getBrowser();\n        swiper.eventsListeners = {};\n        swiper.eventsAnyListeners = [];\n        swiper.modules = [...swiper.__modules__];\n        if (params.modules && Array.isArray(params.modules)) {\n          swiper.modules.push(...params.modules);\n        }\n        const allModulesParams = {};\n        swiper.modules.forEach((mod) => {\n          mod({\n            params,\n            swiper,\n            extendParams: moduleExtendParams(params, allModulesParams),\n            on: swiper.on.bind(swiper),\n            once: swiper.once.bind(swiper),\n            off: swiper.off.bind(swiper),\n            emit: swiper.emit.bind(swiper),\n          });\n        });\n        const swiperParams = extend({}, defaults, allModulesParams);\n        swiper.params = extend({}, swiperParams, extendedDefaults, params);\n        swiper.originalParams = extend({}, swiper.params);\n        swiper.passedParams = extend({}, params);\n        if (swiper.params && swiper.params.on) {\n          Object.keys(swiper.params.on).forEach((eventName) => {\n            swiper.on(eventName, swiper.params.on[eventName]);\n          });\n        }\n        if (swiper.params && swiper.params.onAny) {\n          swiper.onAny(swiper.params.onAny);\n        }\n        Object.assign(swiper, {\n          enabled: swiper.params.enabled,\n          el,\n          // Classes\n          classNames: [],\n          // Slides\n          slides: [],\n          slidesGrid: [],\n          snapGrid: [],\n          slidesSizesGrid: [],\n          // isDirection\n          isHorizontal() {\n            return swiper.params.direction === \"horizontal\";\n          },\n          isVertical() {\n            return swiper.params.direction === \"vertical\";\n          },\n          // Indexes\n          activeIndex: 0,\n          realIndex: 0,\n          //\n          isBeginning: true,\n          isEnd: false,\n          // Props\n          translate: 0,\n          previousTranslate: 0,\n          progress: 0,\n          velocity: 0,\n          animating: false,\n          // Locks\n          allowSlideNext: swiper.params.allowSlideNext,\n          allowSlidePrev: swiper.params.allowSlidePrev,\n          // Touch Events\n          touchEventsData: {\n            isTouched: void 0,\n            isMoved: void 0,\n            allowTouchCallbacks: void 0,\n            touchStartTime: void 0,\n            isScrolling: void 0,\n            currentTranslate: void 0,\n            startTranslate: void 0,\n            allowThresholdMove: void 0,\n            // Form elements to match\n            focusableElements: swiper.params.focusableElements,\n            // Last click time\n            lastClickTime: now(),\n            clickTimeout: void 0,\n            // Velocities\n            velocities: [],\n            allowMomentumBounce: void 0,\n            startMoving: void 0,\n            evCache: [],\n          },\n          // Clicks\n          allowClick: true,\n          // Touches\n          allowTouchMove: swiper.params.allowTouchMove,\n          touches: {\n            startX: 0,\n            startY: 0,\n            currentX: 0,\n            currentY: 0,\n            diff: 0,\n          },\n          // Images\n          imagesToLoad: [],\n          imagesLoaded: 0,\n        });\n        swiper.emit(\"_swiper\");\n        if (swiper.params.init) {\n          swiper.init();\n        }\n        return swiper;\n      }\n      getSlideIndex(slideEl) {\n        const { slidesEl, params } = this;\n        const slides = elementChildren(\n          slidesEl,\n          `.${params.slideClass}, swiper-slide`\n        );\n        const firstSlideIndex = elementIndex(slides[0]);\n        return elementIndex(slideEl) - firstSlideIndex;\n      }\n      recalcSlides() {\n        const swiper = this;\n        const { slidesEl, params } = swiper;\n        swiper.slides = elementChildren(\n          slidesEl,\n          `.${params.slideClass}, swiper-slide`\n        );\n      }\n      enable() {\n        const swiper = this;\n        if (swiper.enabled) return;\n        swiper.enabled = true;\n        if (swiper.params.grabCursor) {\n          swiper.setGrabCursor();\n        }\n        swiper.emit(\"enable\");\n      }\n      disable() {\n        const swiper = this;\n        if (!swiper.enabled) return;\n        swiper.enabled = false;\n        if (swiper.params.grabCursor) {\n          swiper.unsetGrabCursor();\n        }\n        swiper.emit(\"disable\");\n      }\n      setProgress(progress, speed) {\n        const swiper = this;\n        progress = Math.min(Math.max(progress, 0), 1);\n        const min = swiper.minTranslate();\n        const max = swiper.maxTranslate();\n        const current = (max - min) * progress + min;\n        swiper.translateTo(current, typeof speed === \"undefined\" ? 0 : speed);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      emitContainerClasses() {\n        const swiper = this;\n        if (!swiper.params._emitClasses || !swiper.el) return;\n        const cls = swiper.el.className.split(\" \").filter((className) => {\n          return (\n            className.indexOf(\"swiper\") === 0 ||\n            className.indexOf(swiper.params.containerModifierClass) === 0\n          );\n        });\n        swiper.emit(\"_containerClasses\", cls.join(\" \"));\n      }\n      getSlideClasses(slideEl) {\n        const swiper = this;\n        if (swiper.destroyed) return \"\";\n        return slideEl.className\n          .split(\" \")\n          .filter((className) => {\n            return (\n              className.indexOf(\"swiper-slide\") === 0 ||\n              className.indexOf(swiper.params.slideClass) === 0\n            );\n          })\n          .join(\" \");\n      }\n      emitSlidesClasses() {\n        const swiper = this;\n        if (!swiper.params._emitClasses || !swiper.el) return;\n        const updates = [];\n        swiper.slides.forEach((slideEl) => {\n          const classNames = swiper.getSlideClasses(slideEl);\n          updates.push({\n            slideEl,\n            classNames,\n          });\n          swiper.emit(\"_slideClass\", slideEl, classNames);\n        });\n        swiper.emit(\"_slideClasses\", updates);\n      }\n      slidesPerViewDynamic(view = \"current\", exact = false) {\n        const swiper = this;\n        const {\n          params,\n          slides,\n          slidesGrid,\n          slidesSizesGrid,\n          size: swiperSize,\n          activeIndex,\n        } = swiper;\n        let spv = 1;\n        if (params.centeredSlides) {\n          let slideSize = slides[activeIndex].swiperSlideSize;\n          let breakLoop;\n          for (let i = activeIndex + 1; i < slides.length; i += 1) {\n            if (slides[i] && !breakLoop) {\n              slideSize += slides[i].swiperSlideSize;\n              spv += 1;\n              if (slideSize > swiperSize) breakLoop = true;\n            }\n          }\n          for (let i = activeIndex - 1; i >= 0; i -= 1) {\n            if (slides[i] && !breakLoop) {\n              slideSize += slides[i].swiperSlideSize;\n              spv += 1;\n              if (slideSize > swiperSize) breakLoop = true;\n            }\n          }\n        } else {\n          if (view === \"current\") {\n            for (let i = activeIndex + 1; i < slides.length; i += 1) {\n              const slideInView = exact\n                ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] <\n                  swiperSize\n                : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n              if (slideInView) {\n                spv += 1;\n              }\n            }\n          } else {\n            for (let i = activeIndex - 1; i >= 0; i -= 1) {\n              const slideInView =\n                slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n              if (slideInView) {\n                spv += 1;\n              }\n            }\n          }\n        }\n        return spv;\n      }\n      update() {\n        const swiper = this;\n        if (!swiper || swiper.destroyed) return;\n        const { snapGrid, params } = swiper;\n        if (params.breakpoints) {\n          swiper.setBreakpoint();\n        }\n        [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(\n          (imageEl) => {\n            if (imageEl.complete) {\n              processLazyPreloader(swiper, imageEl);\n            }\n          }\n        );\n        swiper.updateSize();\n        swiper.updateSlides();\n        swiper.updateProgress();\n        swiper.updateSlidesClasses();\n        function setTranslate2() {\n          const translateValue = swiper.rtlTranslate\n            ? swiper.translate * -1\n            : swiper.translate;\n          const newTranslate = Math.min(\n            Math.max(translateValue, swiper.maxTranslate()),\n            swiper.minTranslate()\n          );\n          swiper.setTranslate(newTranslate);\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n        }\n        let translated;\n        if (swiper.params.freeMode && swiper.params.freeMode.enabled) {\n          setTranslate2();\n          if (swiper.params.autoHeight) {\n            swiper.updateAutoHeight();\n          }\n        } else {\n          if (\n            (swiper.params.slidesPerView === \"auto\" ||\n              swiper.params.slidesPerView > 1) &&\n            swiper.isEnd &&\n            !swiper.params.centeredSlides\n          ) {\n            translated = swiper.slideTo(\n              swiper.slides.length - 1,\n              0,\n              false,\n              true\n            );\n          } else {\n            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n          }\n          if (!translated) {\n            setTranslate2();\n          }\n        }\n        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n          swiper.checkOverflow();\n        }\n        swiper.emit(\"update\");\n      }\n      changeDirection(newDirection, needUpdate = true) {\n        const swiper = this;\n        const currentDirection = swiper.params.direction;\n        if (!newDirection) {\n          newDirection =\n            currentDirection === \"horizontal\" ? \"vertical\" : \"horizontal\";\n        }\n        if (\n          newDirection === currentDirection ||\n          (newDirection !== \"horizontal\" && newDirection !== \"vertical\")\n        ) {\n          return swiper;\n        }\n        swiper.el.classList.remove(\n          `${swiper.params.containerModifierClass}${currentDirection}`\n        );\n        swiper.el.classList.add(\n          `${swiper.params.containerModifierClass}${newDirection}`\n        );\n        swiper.emitContainerClasses();\n        swiper.params.direction = newDirection;\n        swiper.slides.forEach((slideEl) => {\n          if (newDirection === \"vertical\") {\n            slideEl.style.width = \"\";\n          } else {\n            slideEl.style.height = \"\";\n          }\n        });\n        swiper.emit(\"changeDirection\");\n        if (needUpdate) swiper.update();\n        return swiper;\n      }\n      changeLanguageDirection(direction) {\n        const swiper = this;\n        if (\n          (swiper.rtl && direction === \"rtl\") ||\n          (!swiper.rtl && direction === \"ltr\")\n        )\n          return;\n        swiper.rtl = direction === \"rtl\";\n        swiper.rtlTranslate =\n          swiper.params.direction === \"horizontal\" && swiper.rtl;\n        if (swiper.rtl) {\n          swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n          swiper.el.dir = \"rtl\";\n        } else {\n          swiper.el.classList.remove(\n            `${swiper.params.containerModifierClass}rtl`\n          );\n          swiper.el.dir = \"ltr\";\n        }\n        swiper.update();\n      }\n      mount(element) {\n        const swiper = this;\n        if (swiper.mounted) return true;\n        let el = element || swiper.params.el;\n        if (typeof el === \"string\") {\n          el = document.querySelector(el);\n        }\n        if (!el) {\n          return false;\n        }\n        el.swiper = swiper;\n        if (el.shadowEl) {\n          swiper.isElement = true;\n        }\n        const getWrapperSelector = () => {\n          return `.${(swiper.params.wrapperClass || \"\")\n            .trim()\n            .split(\" \")\n            .join(\".\")}`;\n        };\n        const getWrapper = () => {\n          if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n            const res = el.shadowRoot.querySelector(getWrapperSelector());\n            return res;\n          }\n          return elementChildren(el, getWrapperSelector())[0];\n        };\n        let wrapperEl = getWrapper();\n        if (!wrapperEl && swiper.params.createElements) {\n          wrapperEl = createElement(\"div\", swiper.params.wrapperClass);\n          el.append(wrapperEl);\n          elementChildren(el, `.${swiper.params.slideClass}`).forEach(\n            (slideEl) => {\n              wrapperEl.append(slideEl);\n            }\n          );\n        }\n        Object.assign(swiper, {\n          el,\n          wrapperEl,\n          slidesEl: swiper.isElement ? el : wrapperEl,\n          mounted: true,\n          // RTL\n          rtl:\n            el.dir.toLowerCase() === \"rtl\" ||\n            elementStyle(el, \"direction\") === \"rtl\",\n          rtlTranslate:\n            swiper.params.direction === \"horizontal\" &&\n            (el.dir.toLowerCase() === \"rtl\" ||\n              elementStyle(el, \"direction\") === \"rtl\"),\n          wrongRTL: elementStyle(wrapperEl, \"display\") === \"-webkit-box\",\n        });\n        return true;\n      }\n      init(el) {\n        const swiper = this;\n        if (swiper.initialized) return swiper;\n        const mounted = swiper.mount(el);\n        if (mounted === false) return swiper;\n        swiper.emit(\"beforeInit\");\n        if (swiper.params.breakpoints) {\n          swiper.setBreakpoint();\n        }\n        swiper.addClasses();\n        swiper.updateSize();\n        swiper.updateSlides();\n        if (swiper.params.watchOverflow) {\n          swiper.checkOverflow();\n        }\n        if (swiper.params.grabCursor && swiper.enabled) {\n          swiper.setGrabCursor();\n        }\n        if (\n          swiper.params.loop &&\n          swiper.virtual &&\n          swiper.params.virtual.enabled\n        ) {\n          swiper.slideTo(\n            swiper.params.initialSlide + swiper.virtual.slidesBefore,\n            0,\n            swiper.params.runCallbacksOnInit,\n            false,\n            true\n          );\n        } else {\n          swiper.slideTo(\n            swiper.params.initialSlide,\n            0,\n            swiper.params.runCallbacksOnInit,\n            false,\n            true\n          );\n        }\n        if (swiper.params.loop) {\n          swiper.loopCreate();\n        }\n        swiper.attachEvents();\n        [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(\n          (imageEl) => {\n            if (imageEl.complete) {\n              processLazyPreloader(swiper, imageEl);\n            } else {\n              imageEl.addEventListener(\"load\", (e) => {\n                processLazyPreloader(swiper, e.target);\n              });\n            }\n          }\n        );\n        swiper.initialized = true;\n        swiper.emit(\"init\");\n        swiper.emit(\"afterInit\");\n        return swiper;\n      }\n      destroy(deleteInstance = true, cleanStyles = true) {\n        const swiper = this;\n        const { params, el, wrapperEl, slides } = swiper;\n        if (typeof swiper.params === \"undefined\" || swiper.destroyed) {\n          return null;\n        }\n        swiper.emit(\"beforeDestroy\");\n        swiper.initialized = false;\n        swiper.detachEvents();\n        if (params.loop) {\n          swiper.loopDestroy();\n        }\n        if (cleanStyles) {\n          swiper.removeClasses();\n          el.removeAttribute(\"style\");\n          wrapperEl.removeAttribute(\"style\");\n          if (slides && slides.length) {\n            slides.forEach((slideEl) => {\n              slideEl.classList.remove(\n                params.slideVisibleClass,\n                params.slideActiveClass,\n                params.slideNextClass,\n                params.slidePrevClass\n              );\n              slideEl.removeAttribute(\"style\");\n              slideEl.removeAttribute(\"data-swiper-slide-index\");\n            });\n          }\n        }\n        swiper.emit(\"destroy\");\n        Object.keys(swiper.eventsListeners).forEach((eventName) => {\n          swiper.off(eventName);\n        });\n        if (deleteInstance !== false) {\n          swiper.el.swiper = null;\n          deleteProps(swiper);\n        }\n        swiper.destroyed = true;\n        return null;\n      }\n      static extendDefaults(newDefaults) {\n        extend(extendedDefaults, newDefaults);\n      }\n      static get extendedDefaults() {\n        return extendedDefaults;\n      }\n      static get defaults() {\n        return defaults;\n      }\n      static installModule(mod) {\n        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n        const modules = Swiper.prototype.__modules__;\n        if (typeof mod === \"function\" && modules.indexOf(mod) < 0) {\n          modules.push(mod);\n        }\n      }\n      static use(module) {\n        if (Array.isArray(module)) {\n          module.forEach((m) => Swiper.installModule(m));\n          return Swiper;\n        }\n        Swiper.installModule(module);\n        return Swiper;\n      }\n    }\n    Object.keys(prototypes).forEach((prototypeGroup) => {\n      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n      });\n    });\n    Swiper.use([Resize, Observer]);\n    function Virtual({ swiper, extendParams, on, emit }) {\n      extendParams({\n        virtual: {\n          enabled: false,\n          slides: [],\n          cache: true,\n          renderSlide: null,\n          renderExternal: null,\n          renderExternalUpdate: true,\n          addSlidesBefore: 0,\n          addSlidesAfter: 0,\n        },\n      });\n      let cssModeTimeout;\n      const document2 = getDocument();\n      swiper.virtual = {\n        cache: {},\n        from: void 0,\n        to: void 0,\n        slides: [],\n        offset: 0,\n        slidesGrid: [],\n      };\n      const tempDOM = document2.createElement(\"div\");\n      function renderSlide(slide2, index) {\n        const params = swiper.params.virtual;\n        if (params.cache && swiper.virtual.cache[index]) {\n          return swiper.virtual.cache[index];\n        }\n        let slideEl;\n        if (params.renderSlide) {\n          slideEl = params.renderSlide.call(swiper, slide2, index);\n          if (typeof slideEl === \"string\") {\n            tempDOM.innerHTML = slideEl;\n            slideEl = tempDOM.children[0];\n          }\n        } else if (swiper.isElement) {\n          slideEl = createElement(\"swiper-slide\");\n        } else {\n          slideEl = createElement(\"div\", swiper.params.slideClass);\n        }\n        slideEl.setAttribute(\"data-swiper-slide-index\", index);\n        if (!params.renderSlide) {\n          slideEl.innerHTML = slide2;\n        }\n        if (params.cache) swiper.virtual.cache[index] = slideEl;\n        return slideEl;\n      }\n      function update2(force) {\n        const {\n          slidesPerView,\n          slidesPerGroup,\n          centeredSlides,\n          loop: isLoop,\n        } = swiper.params;\n        const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;\n        const {\n          from: previousFrom,\n          to: previousTo,\n          slides,\n          slidesGrid: previousSlidesGrid,\n          offset: previousOffset,\n        } = swiper.virtual;\n        if (!swiper.params.cssMode) {\n          swiper.updateActiveIndex();\n        }\n        const activeIndex = swiper.activeIndex || 0;\n        let offsetProp;\n        if (swiper.rtlTranslate) offsetProp = \"right\";\n        else offsetProp = swiper.isHorizontal() ? \"left\" : \"top\";\n        let slidesAfter;\n        let slidesBefore;\n        if (centeredSlides) {\n          slidesAfter =\n            Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n          slidesBefore =\n            Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n        } else {\n          slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n          slidesBefore =\n            (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n        }\n        let from = activeIndex - slidesBefore;\n        let to = activeIndex + slidesAfter;\n        if (!isLoop) {\n          from = Math.max(from, 0);\n          to = Math.min(to, slides.length - 1);\n        }\n        let offset =\n          (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n        if (isLoop && activeIndex >= slidesBefore) {\n          from -= slidesBefore;\n          if (!centeredSlides) offset += swiper.slidesGrid[0];\n        } else if (isLoop && activeIndex < slidesBefore) {\n          from = -slidesBefore;\n          if (centeredSlides) offset += swiper.slidesGrid[0];\n        }\n        Object.assign(swiper.virtual, {\n          from,\n          to,\n          offset,\n          slidesGrid: swiper.slidesGrid,\n          slidesBefore,\n          slidesAfter,\n        });\n        function onRendered() {\n          swiper.updateSlides();\n          swiper.updateProgress();\n          swiper.updateSlidesClasses();\n          emit(\"virtualUpdate\");\n        }\n        if (previousFrom === from && previousTo === to && !force) {\n          if (\n            swiper.slidesGrid !== previousSlidesGrid &&\n            offset !== previousOffset\n          ) {\n            swiper.slides.forEach((slideEl) => {\n              slideEl.style[offsetProp] = `${offset}px`;\n            });\n          }\n          swiper.updateProgress();\n          emit(\"virtualUpdate\");\n          return;\n        }\n        if (swiper.params.virtual.renderExternal) {\n          swiper.params.virtual.renderExternal.call(swiper, {\n            offset,\n            from,\n            to,\n            slides: (function getSlides() {\n              const slidesToRender = [];\n              for (let i = from; i <= to; i += 1) {\n                slidesToRender.push(slides[i]);\n              }\n              return slidesToRender;\n            })(),\n          });\n          if (swiper.params.virtual.renderExternalUpdate) {\n            onRendered();\n          } else {\n            emit(\"virtualUpdate\");\n          }\n          return;\n        }\n        const prependIndexes = [];\n        const appendIndexes = [];\n        const getSlideIndex = (index) => {\n          let slideIndex = index;\n          if (index < 0) {\n            slideIndex = slides.length + index;\n          } else if (slideIndex >= slides.length) {\n            slideIndex = slideIndex - slides.length;\n          }\n          return slideIndex;\n        };\n        if (force) {\n          swiper.slidesEl\n            .querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`)\n            .forEach((slideEl) => {\n              slideEl.remove();\n            });\n        } else {\n          for (let i = previousFrom; i <= previousTo; i += 1) {\n            if (i < from || i > to) {\n              const slideIndex = getSlideIndex(i);\n              swiper.slidesEl\n                .querySelectorAll(\n                  `.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`\n                )\n                .forEach((slideEl) => {\n                  slideEl.remove();\n                });\n            }\n          }\n        }\n        const loopFrom = isLoop ? -slides.length : 0;\n        const loopTo = isLoop ? slides.length * 2 : slides.length;\n        for (let i = loopFrom; i < loopTo; i += 1) {\n          if (i >= from && i <= to) {\n            const slideIndex = getSlideIndex(i);\n            if (typeof previousTo === \"undefined\" || force) {\n              appendIndexes.push(slideIndex);\n            } else {\n              if (i > previousTo) appendIndexes.push(slideIndex);\n              if (i < previousFrom) prependIndexes.push(slideIndex);\n            }\n          }\n        }\n        appendIndexes.forEach((index) => {\n          swiper.slidesEl.append(renderSlide(slides[index], index));\n        });\n        if (isLoop) {\n          for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n            const index = prependIndexes[i];\n            swiper.slidesEl.prepend(renderSlide(slides[index], index));\n          }\n        } else {\n          prependIndexes.sort((a, b) => b - a);\n          prependIndexes.forEach((index) => {\n            swiper.slidesEl.prepend(renderSlide(slides[index], index));\n          });\n        }\n        elementChildren(swiper.slidesEl, \".swiper-slide, swiper-slide\").forEach(\n          (slideEl) => {\n            slideEl.style[offsetProp] = `${offset}px`;\n          }\n        );\n        onRendered();\n      }\n      function appendSlide2(slides) {\n        if (typeof slides === \"object\" && \"length\" in slides) {\n          for (let i = 0; i < slides.length; i += 1) {\n            if (slides[i]) swiper.virtual.slides.push(slides[i]);\n          }\n        } else {\n          swiper.virtual.slides.push(slides);\n        }\n        update2(true);\n      }\n      function prependSlide2(slides) {\n        const activeIndex = swiper.activeIndex;\n        let newActiveIndex = activeIndex + 1;\n        let numberOfNewSlides = 1;\n        if (Array.isArray(slides)) {\n          for (let i = 0; i < slides.length; i += 1) {\n            if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n          }\n          newActiveIndex = activeIndex + slides.length;\n          numberOfNewSlides = slides.length;\n        } else {\n          swiper.virtual.slides.unshift(slides);\n        }\n        if (swiper.params.virtual.cache) {\n          const cache = swiper.virtual.cache;\n          const newCache = {};\n          Object.keys(cache).forEach((cachedIndex) => {\n            const cachedEl = cache[cachedIndex];\n            const cachedElIndex = cachedEl.getAttribute(\n              \"data-swiper-slide-index\"\n            );\n            if (cachedElIndex) {\n              cachedEl.setAttribute(\n                \"data-swiper-slide-index\",\n                parseInt(cachedElIndex, 10) + numberOfNewSlides\n              );\n            }\n            newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n          });\n          swiper.virtual.cache = newCache;\n        }\n        update2(true);\n        swiper.slideTo(newActiveIndex, 0);\n      }\n      function removeSlide2(slidesIndexes) {\n        if (typeof slidesIndexes === \"undefined\" || slidesIndexes === null)\n          return;\n        let activeIndex = swiper.activeIndex;\n        if (Array.isArray(slidesIndexes)) {\n          for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n            swiper.virtual.slides.splice(slidesIndexes[i], 1);\n            if (swiper.params.virtual.cache) {\n              delete swiper.virtual.cache[slidesIndexes[i]];\n            }\n            if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n            activeIndex = Math.max(activeIndex, 0);\n          }\n        } else {\n          swiper.virtual.slides.splice(slidesIndexes, 1);\n          if (swiper.params.virtual.cache) {\n            delete swiper.virtual.cache[slidesIndexes];\n          }\n          if (slidesIndexes < activeIndex) activeIndex -= 1;\n          activeIndex = Math.max(activeIndex, 0);\n        }\n        update2(true);\n        swiper.slideTo(activeIndex, 0);\n      }\n      function removeAllSlides2() {\n        swiper.virtual.slides = [];\n        if (swiper.params.virtual.cache) {\n          swiper.virtual.cache = {};\n        }\n        update2(true);\n        swiper.slideTo(0, 0);\n      }\n      on(\"beforeInit\", () => {\n        if (!swiper.params.virtual.enabled) return;\n        let domSlidesAssigned;\n        if (typeof swiper.passedParams.virtual.slides === \"undefined\") {\n          const slides = [...swiper.slidesEl.children].filter((el) =>\n            el.matches(`.${swiper.params.slideClass}, swiper-slide`)\n          );\n          if (slides && slides.length) {\n            swiper.virtual.slides = [...slides];\n            domSlidesAssigned = true;\n            slides.forEach((slideEl, slideIndex) => {\n              slideEl.setAttribute(\"data-swiper-slide-index\", slideIndex);\n              swiper.virtual.cache[slideIndex] = slideEl;\n              slideEl.remove();\n            });\n          }\n        }\n        if (!domSlidesAssigned) {\n          swiper.virtual.slides = swiper.params.virtual.slides;\n        }\n        swiper.classNames.push(\n          `${swiper.params.containerModifierClass}virtual`\n        );\n        swiper.params.watchSlidesProgress = true;\n        swiper.originalParams.watchSlidesProgress = true;\n        if (!swiper.params.initialSlide) {\n          update2();\n        }\n      });\n      on(\"setTranslate\", () => {\n        if (!swiper.params.virtual.enabled) return;\n        if (swiper.params.cssMode && !swiper._immediateVirtual) {\n          clearTimeout(cssModeTimeout);\n          cssModeTimeout = setTimeout(() => {\n            update2();\n          }, 100);\n        } else {\n          update2();\n        }\n      });\n      on(\"init update resize\", () => {\n        if (!swiper.params.virtual.enabled) return;\n        if (swiper.params.cssMode) {\n          setCSSProperty(\n            swiper.wrapperEl,\n            \"--swiper-virtual-size\",\n            `${swiper.virtualSize}px`\n          );\n        }\n      });\n      Object.assign(swiper.virtual, {\n        appendSlide: appendSlide2,\n        prependSlide: prependSlide2,\n        removeSlide: removeSlide2,\n        removeAllSlides: removeAllSlides2,\n        update: update2,\n      });\n    }\n    function Keyboard({ swiper, extendParams, on, emit }) {\n      const document2 = getDocument();\n      const window2 = getWindow();\n      swiper.keyboard = {\n        enabled: false,\n      };\n      extendParams({\n        keyboard: {\n          enabled: false,\n          onlyInViewport: true,\n          pageUpDown: true,\n        },\n      });\n      function handle(event2) {\n        if (!swiper.enabled) return;\n        const { rtlTranslate: rtl } = swiper;\n        let e = event2;\n        if (e.originalEvent) e = e.originalEvent;\n        const kc = e.keyCode || e.charCode;\n        const pageUpDown = swiper.params.keyboard.pageUpDown;\n        const isPageUp = pageUpDown && kc === 33;\n        const isPageDown = pageUpDown && kc === 34;\n        const isArrowLeft = kc === 37;\n        const isArrowRight = kc === 39;\n        const isArrowUp = kc === 38;\n        const isArrowDown = kc === 40;\n        if (\n          !swiper.allowSlideNext &&\n          ((swiper.isHorizontal() && isArrowRight) ||\n            (swiper.isVertical() && isArrowDown) ||\n            isPageDown)\n        ) {\n          return false;\n        }\n        if (\n          !swiper.allowSlidePrev &&\n          ((swiper.isHorizontal() && isArrowLeft) ||\n            (swiper.isVertical() && isArrowUp) ||\n            isPageUp)\n        ) {\n          return false;\n        }\n        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n          return void 0;\n        }\n        if (\n          document2.activeElement &&\n          document2.activeElement.nodeName &&\n          (document2.activeElement.nodeName.toLowerCase() === \"input\" ||\n            document2.activeElement.nodeName.toLowerCase() === \"textarea\")\n        ) {\n          return void 0;\n        }\n        if (\n          swiper.params.keyboard.onlyInViewport &&\n          (isPageUp ||\n            isPageDown ||\n            isArrowLeft ||\n            isArrowRight ||\n            isArrowUp ||\n            isArrowDown)\n        ) {\n          let inView = false;\n          if (\n            elementParents(\n              swiper.el,\n              `.${swiper.params.slideClass}, swiper-slide`\n            ).length > 0 &&\n            elementParents(swiper.el, `.${swiper.params.slideActiveClass}`)\n              .length === 0\n          ) {\n            return void 0;\n          }\n          const el = swiper.el;\n          const swiperWidth = el.clientWidth;\n          const swiperHeight = el.clientHeight;\n          const windowWidth = window2.innerWidth;\n          const windowHeight = window2.innerHeight;\n          const swiperOffset = elementOffset(el);\n          if (rtl) swiperOffset.left -= el.scrollLeft;\n          const swiperCoord = [\n            [swiperOffset.left, swiperOffset.top],\n            [swiperOffset.left + swiperWidth, swiperOffset.top],\n            [swiperOffset.left, swiperOffset.top + swiperHeight],\n            [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight],\n          ];\n          for (let i = 0; i < swiperCoord.length; i += 1) {\n            const point = swiperCoord[i];\n            if (\n              point[0] >= 0 &&\n              point[0] <= windowWidth &&\n              point[1] >= 0 &&\n              point[1] <= windowHeight\n            ) {\n              if (point[0] === 0 && point[1] === 0) continue;\n              inView = true;\n            }\n          }\n          if (!inView) return void 0;\n        }\n        if (swiper.isHorizontal()) {\n          if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n            if (e.preventDefault) e.preventDefault();\n            else e.returnValue = false;\n          }\n          if (\n            ((isPageDown || isArrowRight) && !rtl) ||\n            ((isPageUp || isArrowLeft) && rtl)\n          )\n            swiper.slideNext();\n          if (\n            ((isPageUp || isArrowLeft) && !rtl) ||\n            ((isPageDown || isArrowRight) && rtl)\n          )\n            swiper.slidePrev();\n        } else {\n          if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n            if (e.preventDefault) e.preventDefault();\n            else e.returnValue = false;\n          }\n          if (isPageDown || isArrowDown) swiper.slideNext();\n          if (isPageUp || isArrowUp) swiper.slidePrev();\n        }\n        emit(\"keyPress\", kc);\n        return void 0;\n      }\n      function enable() {\n        if (swiper.keyboard.enabled) return;\n        document2.addEventListener(\"keydown\", handle);\n        swiper.keyboard.enabled = true;\n      }\n      function disable() {\n        if (!swiper.keyboard.enabled) return;\n        document2.removeEventListener(\"keydown\", handle);\n        swiper.keyboard.enabled = false;\n      }\n      on(\"init\", () => {\n        if (swiper.params.keyboard.enabled) {\n          enable();\n        }\n      });\n      on(\"destroy\", () => {\n        if (swiper.keyboard.enabled) {\n          disable();\n        }\n      });\n      Object.assign(swiper.keyboard, {\n        enable,\n        disable,\n      });\n    }\n    function Mousewheel({ swiper, extendParams, on, emit }) {\n      const window2 = getWindow();\n      extendParams({\n        mousewheel: {\n          enabled: false,\n          releaseOnEdges: false,\n          invert: false,\n          forceToAxis: false,\n          sensitivity: 1,\n          eventsTarget: \"container\",\n          thresholdDelta: null,\n          thresholdTime: null,\n        },\n      });\n      swiper.mousewheel = {\n        enabled: false,\n      };\n      let timeout2;\n      let lastScrollTime = now();\n      let lastEventBeforeSnap;\n      const recentWheelEvents = [];\n      function normalize(e) {\n        const PIXEL_STEP = 10;\n        const LINE_HEIGHT = 40;\n        const PAGE_HEIGHT = 800;\n        let sX = 0;\n        let sY = 0;\n        let pX = 0;\n        let pY = 0;\n        if (\"detail\" in e) {\n          sY = e.detail;\n        }\n        if (\"wheelDelta\" in e) {\n          sY = -e.wheelDelta / 120;\n        }\n        if (\"wheelDeltaY\" in e) {\n          sY = -e.wheelDeltaY / 120;\n        }\n        if (\"wheelDeltaX\" in e) {\n          sX = -e.wheelDeltaX / 120;\n        }\n        if (\"axis\" in e && e.axis === e.HORIZONTAL_AXIS) {\n          sX = sY;\n          sY = 0;\n        }\n        pX = sX * PIXEL_STEP;\n        pY = sY * PIXEL_STEP;\n        if (\"deltaY\" in e) {\n          pY = e.deltaY;\n        }\n        if (\"deltaX\" in e) {\n          pX = e.deltaX;\n        }\n        if (e.shiftKey && !pX) {\n          pX = pY;\n          pY = 0;\n        }\n        if ((pX || pY) && e.deltaMode) {\n          if (e.deltaMode === 1) {\n            pX *= LINE_HEIGHT;\n            pY *= LINE_HEIGHT;\n          } else {\n            pX *= PAGE_HEIGHT;\n            pY *= PAGE_HEIGHT;\n          }\n        }\n        if (pX && !sX) {\n          sX = pX < 1 ? -1 : 1;\n        }\n        if (pY && !sY) {\n          sY = pY < 1 ? -1 : 1;\n        }\n        return {\n          spinX: sX,\n          spinY: sY,\n          pixelX: pX,\n          pixelY: pY,\n        };\n      }\n      function handleMouseEnter() {\n        if (!swiper.enabled) return;\n        swiper.mouseEntered = true;\n      }\n      function handleMouseLeave() {\n        if (!swiper.enabled) return;\n        swiper.mouseEntered = false;\n      }\n      function animateSlider(newEvent) {\n        if (\n          swiper.params.mousewheel.thresholdDelta &&\n          newEvent.delta < swiper.params.mousewheel.thresholdDelta\n        ) {\n          return false;\n        }\n        if (\n          swiper.params.mousewheel.thresholdTime &&\n          now() - lastScrollTime < swiper.params.mousewheel.thresholdTime\n        ) {\n          return false;\n        }\n        if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n          return true;\n        }\n        if (newEvent.direction < 0) {\n          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n            swiper.slideNext();\n            emit(\"scroll\", newEvent.raw);\n          }\n        } else if (\n          (!swiper.isBeginning || swiper.params.loop) &&\n          !swiper.animating\n        ) {\n          swiper.slidePrev();\n          emit(\"scroll\", newEvent.raw);\n        }\n        lastScrollTime = new window2.Date().getTime();\n        return false;\n      }\n      function releaseScroll(newEvent) {\n        const params = swiper.params.mousewheel;\n        if (newEvent.direction < 0) {\n          if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n            return true;\n          }\n        } else if (\n          swiper.isBeginning &&\n          !swiper.params.loop &&\n          params.releaseOnEdges\n        ) {\n          return true;\n        }\n        return false;\n      }\n      function handle(event2) {\n        let e = event2;\n        let disableParentSwiper = true;\n        if (!swiper.enabled) return;\n        const params = swiper.params.mousewheel;\n        if (swiper.params.cssMode) {\n          e.preventDefault();\n        }\n        let targetEl = swiper.el;\n        if (swiper.params.mousewheel.eventsTarget !== \"container\") {\n          targetEl = document.querySelector(\n            swiper.params.mousewheel.eventsTarget\n          );\n        }\n        const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n        if (\n          !swiper.mouseEntered &&\n          !targetElContainsTarget &&\n          !params.releaseOnEdges\n        )\n          return true;\n        if (e.originalEvent) e = e.originalEvent;\n        let delta = 0;\n        const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n        const data = normalize(e);\n        if (params.forceToAxis) {\n          if (swiper.isHorizontal()) {\n            if (Math.abs(data.pixelX) > Math.abs(data.pixelY))\n              delta = -data.pixelX * rtlFactor;\n            else return true;\n          } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX))\n            delta = -data.pixelY;\n          else return true;\n        } else {\n          delta =\n            Math.abs(data.pixelX) > Math.abs(data.pixelY)\n              ? -data.pixelX * rtlFactor\n              : -data.pixelY;\n        }\n        if (delta === 0) return true;\n        if (params.invert) delta = -delta;\n        let positions = swiper.getTranslate() + delta * params.sensitivity;\n        if (positions >= swiper.minTranslate())\n          positions = swiper.minTranslate();\n        if (positions <= swiper.maxTranslate())\n          positions = swiper.maxTranslate();\n        disableParentSwiper = swiper.params.loop\n          ? true\n          : !(\n              positions === swiper.minTranslate() ||\n              positions === swiper.maxTranslate()\n            );\n        if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n        if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n          const newEvent = {\n            time: now(),\n            delta: Math.abs(delta),\n            direction: Math.sign(delta),\n            raw: event2,\n          };\n          if (recentWheelEvents.length >= 2) {\n            recentWheelEvents.shift();\n          }\n          const prevEvent = recentWheelEvents.length\n            ? recentWheelEvents[recentWheelEvents.length - 1]\n            : void 0;\n          recentWheelEvents.push(newEvent);\n          if (prevEvent) {\n            if (\n              newEvent.direction !== prevEvent.direction ||\n              newEvent.delta > prevEvent.delta ||\n              newEvent.time > prevEvent.time + 150\n            ) {\n              animateSlider(newEvent);\n            }\n          } else {\n            animateSlider(newEvent);\n          }\n          if (releaseScroll(newEvent)) {\n            return true;\n          }\n        } else {\n          const newEvent = {\n            time: now(),\n            delta: Math.abs(delta),\n            direction: Math.sign(delta),\n          };\n          const ignoreWheelEvents =\n            lastEventBeforeSnap &&\n            newEvent.time < lastEventBeforeSnap.time + 500 &&\n            newEvent.delta <= lastEventBeforeSnap.delta &&\n            newEvent.direction === lastEventBeforeSnap.direction;\n          if (!ignoreWheelEvents) {\n            lastEventBeforeSnap = void 0;\n            let position = swiper.getTranslate() + delta * params.sensitivity;\n            const wasBeginning = swiper.isBeginning;\n            const wasEnd = swiper.isEnd;\n            if (position >= swiper.minTranslate())\n              position = swiper.minTranslate();\n            if (position <= swiper.maxTranslate())\n              position = swiper.maxTranslate();\n            swiper.setTransition(0);\n            swiper.setTranslate(position);\n            swiper.updateProgress();\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n            if (\n              (!wasBeginning && swiper.isBeginning) ||\n              (!wasEnd && swiper.isEnd)\n            ) {\n              swiper.updateSlidesClasses();\n            }\n            if (swiper.params.loop) {\n              swiper.loopFix({\n                direction: newEvent.direction < 0 ? \"next\" : \"prev\",\n                byMousewheel: true,\n              });\n            }\n            if (swiper.params.freeMode.sticky) {\n              clearTimeout(timeout2);\n              timeout2 = void 0;\n              if (recentWheelEvents.length >= 15) {\n                recentWheelEvents.shift();\n              }\n              const prevEvent = recentWheelEvents.length\n                ? recentWheelEvents[recentWheelEvents.length - 1]\n                : void 0;\n              const firstEvent = recentWheelEvents[0];\n              recentWheelEvents.push(newEvent);\n              if (\n                prevEvent &&\n                (newEvent.delta > prevEvent.delta ||\n                  newEvent.direction !== prevEvent.direction)\n              ) {\n                recentWheelEvents.splice(0);\n              } else if (\n                recentWheelEvents.length >= 15 &&\n                newEvent.time - firstEvent.time < 500 &&\n                firstEvent.delta - newEvent.delta >= 1 &&\n                newEvent.delta <= 6\n              ) {\n                const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n                lastEventBeforeSnap = newEvent;\n                recentWheelEvents.splice(0);\n                timeout2 = nextTick(() => {\n                  swiper.slideToClosest(\n                    swiper.params.speed,\n                    true,\n                    void 0,\n                    snapToThreshold\n                  );\n                }, 0);\n              }\n              if (!timeout2) {\n                timeout2 = nextTick(() => {\n                  const snapToThreshold = 0.5;\n                  lastEventBeforeSnap = newEvent;\n                  recentWheelEvents.splice(0);\n                  swiper.slideToClosest(\n                    swiper.params.speed,\n                    true,\n                    void 0,\n                    snapToThreshold\n                  );\n                }, 500);\n              }\n            }\n            if (!ignoreWheelEvents) emit(\"scroll\", e);\n            if (\n              swiper.params.autoplay &&\n              swiper.params.autoplayDisableOnInteraction\n            )\n              swiper.autoplay.stop();\n            if (\n              position === swiper.minTranslate() ||\n              position === swiper.maxTranslate()\n            )\n              return true;\n          }\n        }\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n        return false;\n      }\n      function events2(method) {\n        let targetEl = swiper.el;\n        if (swiper.params.mousewheel.eventsTarget !== \"container\") {\n          targetEl = document.querySelector(\n            swiper.params.mousewheel.eventsTarget\n          );\n        }\n        targetEl[method](\"mouseenter\", handleMouseEnter);\n        targetEl[method](\"mouseleave\", handleMouseLeave);\n        targetEl[method](\"wheel\", handle);\n      }\n      function enable() {\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.removeEventListener(\"wheel\", handle);\n          return true;\n        }\n        if (swiper.mousewheel.enabled) return false;\n        events2(\"addEventListener\");\n        swiper.mousewheel.enabled = true;\n        return true;\n      }\n      function disable() {\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.addEventListener(event, handle);\n          return true;\n        }\n        if (!swiper.mousewheel.enabled) return false;\n        events2(\"removeEventListener\");\n        swiper.mousewheel.enabled = false;\n        return true;\n      }\n      on(\"init\", () => {\n        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n          disable();\n        }\n        if (swiper.params.mousewheel.enabled) enable();\n      });\n      on(\"destroy\", () => {\n        if (swiper.params.cssMode) {\n          enable();\n        }\n        if (swiper.mousewheel.enabled) disable();\n      });\n      Object.assign(swiper.mousewheel, {\n        enable,\n        disable,\n      });\n    }\n    function createElementIfNotDefined(\n      swiper,\n      originalParams,\n      params,\n      checkProps\n    ) {\n      if (swiper.params.createElements) {\n        Object.keys(checkProps).forEach((key) => {\n          if (!params[key] && params.auto === true) {\n            let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n            if (!element) {\n              element = createElement(\"div\", checkProps[key]);\n              element.className = checkProps[key];\n              swiper.el.append(element);\n            }\n            params[key] = element;\n            originalParams[key] = element;\n          }\n        });\n      }\n      return params;\n    }\n    function Navigation({ swiper, extendParams, on, emit }) {\n      extendParams({\n        navigation: {\n          nextEl: null,\n          prevEl: null,\n          hideOnClick: false,\n          disabledClass: \"swiper-button-disabled\",\n          hiddenClass: \"swiper-button-hidden\",\n          lockClass: \"swiper-button-lock\",\n          navigationDisabledClass: \"swiper-navigation-disabled\",\n        },\n      });\n      swiper.navigation = {\n        nextEl: null,\n        prevEl: null,\n      };\n      const makeElementsArray = (el) => {\n        if (!Array.isArray(el)) el = [el].filter((e) => !!e);\n        return el;\n      };\n      function getEl(el) {\n        let res;\n        if (el && typeof el === \"string\" && swiper.isElement) {\n          res = swiper.el.shadowRoot.querySelector(el);\n          if (res) return res;\n        }\n        if (el) {\n          if (typeof el === \"string\") res = [...document.querySelectorAll(el)];\n          if (\n            swiper.params.uniqueNavElements &&\n            typeof el === \"string\" &&\n            res.length > 1 &&\n            swiper.el.querySelectorAll(el).length === 1\n          ) {\n            res = swiper.el.querySelector(el);\n          }\n        }\n        if (el && !res) return el;\n        return res;\n      }\n      function toggleEl(el, disabled) {\n        const params = swiper.params.navigation;\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          if (subEl) {\n            subEl.classList[disabled ? \"add\" : \"remove\"](\n              ...params.disabledClass.split(\" \")\n            );\n            if (subEl.tagName === \"BUTTON\") subEl.disabled = disabled;\n            if (swiper.params.watchOverflow && swiper.enabled) {\n              subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](\n                params.lockClass\n              );\n            }\n          }\n        });\n      }\n      function update2() {\n        const { nextEl, prevEl } = swiper.navigation;\n        if (swiper.params.loop) {\n          toggleEl(prevEl, false);\n          toggleEl(nextEl, false);\n          return;\n        }\n        toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n        toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n      }\n      function onPrevClick(e) {\n        e.preventDefault();\n        if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind)\n          return;\n        swiper.slidePrev();\n        emit(\"navigationPrev\");\n      }\n      function onNextClick(e) {\n        e.preventDefault();\n        if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind)\n          return;\n        swiper.slideNext();\n        emit(\"navigationNext\");\n      }\n      function init() {\n        const params = swiper.params.navigation;\n        swiper.params.navigation = createElementIfNotDefined(\n          swiper,\n          swiper.originalParams.navigation,\n          swiper.params.navigation,\n          {\n            nextEl: \"swiper-button-next\",\n            prevEl: \"swiper-button-prev\",\n          }\n        );\n        if (!(params.nextEl || params.prevEl)) return;\n        let nextEl = getEl(params.nextEl);\n        let prevEl = getEl(params.prevEl);\n        Object.assign(swiper.navigation, {\n          nextEl,\n          prevEl,\n        });\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        const initButton = (el, dir) => {\n          if (el) {\n            el.addEventListener(\n              \"click\",\n              dir === \"next\" ? onNextClick : onPrevClick\n            );\n          }\n          if (!swiper.enabled && el) {\n            el.classList.add(...params.lockClass.split(\" \"));\n          }\n        };\n        nextEl.forEach((el) => initButton(el, \"next\"));\n        prevEl.forEach((el) => initButton(el, \"prev\"));\n      }\n      function destroy() {\n        let { nextEl, prevEl } = swiper.navigation;\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        const destroyButton = (el, dir) => {\n          el.removeEventListener(\n            \"click\",\n            dir === \"next\" ? onNextClick : onPrevClick\n          );\n          el.classList.remove(\n            ...swiper.params.navigation.disabledClass.split(\" \")\n          );\n        };\n        nextEl.forEach((el) => destroyButton(el, \"next\"));\n        prevEl.forEach((el) => destroyButton(el, \"prev\"));\n      }\n      on(\"init\", () => {\n        if (swiper.params.navigation.enabled === false) {\n          disable();\n        } else {\n          init();\n          update2();\n        }\n      });\n      on(\"toEdge fromEdge lock unlock\", () => {\n        update2();\n      });\n      on(\"destroy\", () => {\n        destroy();\n      });\n      on(\"enable disable\", () => {\n        let { nextEl, prevEl } = swiper.navigation;\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        [...nextEl, ...prevEl]\n          .filter((el) => !!el)\n          .forEach((el) =>\n            el.classList[swiper.enabled ? \"remove\" : \"add\"](\n              swiper.params.navigation.lockClass\n            )\n          );\n      });\n      on(\"click\", (_s, e) => {\n        let { nextEl, prevEl } = swiper.navigation;\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        const targetEl = e.target;\n        if (\n          swiper.params.navigation.hideOnClick &&\n          !prevEl.includes(targetEl) &&\n          !nextEl.includes(targetEl)\n        ) {\n          if (\n            swiper.pagination &&\n            swiper.params.pagination &&\n            swiper.params.pagination.clickable &&\n            (swiper.pagination.el === targetEl ||\n              swiper.pagination.el.contains(targetEl))\n          )\n            return;\n          let isHidden;\n          if (nextEl.length) {\n            isHidden = nextEl[0].classList.contains(\n              swiper.params.navigation.hiddenClass\n            );\n          } else if (prevEl.length) {\n            isHidden = prevEl[0].classList.contains(\n              swiper.params.navigation.hiddenClass\n            );\n          }\n          if (isHidden === true) {\n            emit(\"navigationShow\");\n          } else {\n            emit(\"navigationHide\");\n          }\n          [...nextEl, ...prevEl]\n            .filter((el) => !!el)\n            .forEach((el) =>\n              el.classList.toggle(swiper.params.navigation.hiddenClass)\n            );\n        }\n      });\n      const enable = () => {\n        swiper.el.classList.remove(\n          ...swiper.params.navigation.navigationDisabledClass.split(\" \")\n        );\n        init();\n        update2();\n      };\n      const disable = () => {\n        swiper.el.classList.add(\n          ...swiper.params.navigation.navigationDisabledClass.split(\" \")\n        );\n        destroy();\n      };\n      Object.assign(swiper.navigation, {\n        enable,\n        disable,\n        update: update2,\n        init,\n        destroy,\n      });\n    }\n    function classesToSelector(classes2 = \"\") {\n      return `.${classes2\n        .trim()\n        .replace(/([\\.:!\\/])/g, \"\\\\$1\")\n        .replace(/ /g, \".\")}`;\n    }\n    function Pagination({ swiper, extendParams, on, emit }) {\n      const pfx = \"swiper-pagination\";\n      extendParams({\n        pagination: {\n          el: null,\n          bulletElement: \"span\",\n          clickable: false,\n          hideOnClick: false,\n          renderBullet: null,\n          renderProgressbar: null,\n          renderFraction: null,\n          renderCustom: null,\n          progressbarOpposite: false,\n          type: \"bullets\",\n          // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n          dynamicBullets: false,\n          dynamicMainBullets: 1,\n          formatFractionCurrent: (number) => number,\n          formatFractionTotal: (number) => number,\n          bulletClass: `${pfx}-bullet`,\n          bulletActiveClass: `${pfx}-bullet-active`,\n          modifierClass: `${pfx}-`,\n          currentClass: `${pfx}-current`,\n          totalClass: `${pfx}-total`,\n          hiddenClass: `${pfx}-hidden`,\n          progressbarFillClass: `${pfx}-progressbar-fill`,\n          progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n          clickableClass: `${pfx}-clickable`,\n          lockClass: `${pfx}-lock`,\n          horizontalClass: `${pfx}-horizontal`,\n          verticalClass: `${pfx}-vertical`,\n          paginationDisabledClass: `${pfx}-disabled`,\n        },\n      });\n      swiper.pagination = {\n        el: null,\n        bullets: [],\n      };\n      let bulletSize;\n      let dynamicBulletIndex = 0;\n      const makeElementsArray = (el) => {\n        if (!Array.isArray(el)) el = [el].filter((e) => !!e);\n        return el;\n      };\n      function isPaginationDisabled() {\n        return (\n          !swiper.params.pagination.el ||\n          !swiper.pagination.el ||\n          (Array.isArray(swiper.pagination.el) &&\n            swiper.pagination.el.length === 0)\n        );\n      }\n      function setSideBullets(bulletEl, position) {\n        const { bulletActiveClass } = swiper.params.pagination;\n        if (!bulletEl) return;\n        bulletEl =\n          bulletEl[\n            `${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`\n          ];\n        if (bulletEl) {\n          bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n          bulletEl =\n            bulletEl[\n              `${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`\n            ];\n          if (bulletEl) {\n            bulletEl.classList.add(\n              `${bulletActiveClass}-${position}-${position}`\n            );\n          }\n        }\n      }\n      function onBulletClick(e) {\n        const bulletEl = e.target.closest(\n          classesToSelector(swiper.params.pagination.bulletClass)\n        );\n        if (!bulletEl) {\n          return;\n        }\n        e.preventDefault();\n        const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n        if (swiper.params.loop) {\n          if (swiper.realIndex === index) return;\n          if (\n            index < swiper.loopedSlides ||\n            index > swiper.slides.length - swiper.loopedSlides\n          ) {\n            swiper.loopFix({\n              direction: index < swiper.loopedSlides ? \"prev\" : \"next\",\n              activeSlideIndex: index,\n              slideTo: false,\n            });\n          }\n          swiper.slideToLoop(index);\n        } else {\n          swiper.slideTo(index);\n        }\n      }\n      function update2() {\n        const rtl = swiper.rtl;\n        const params = swiper.params.pagination;\n        if (isPaginationDisabled()) return;\n        let el = swiper.pagination.el;\n        el = makeElementsArray(el);\n        let current;\n        const slidesLength =\n          swiper.virtual && swiper.params.virtual.enabled\n            ? swiper.virtual.slides.length\n            : swiper.slides.length;\n        const total = swiper.params.loop\n          ? Math.ceil(slidesLength / swiper.params.slidesPerGroup)\n          : swiper.snapGrid.length;\n        if (swiper.params.loop) {\n          current =\n            swiper.params.slidesPerGroup > 1\n              ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup)\n              : swiper.realIndex;\n        } else if (typeof swiper.snapIndex !== \"undefined\") {\n          current = swiper.snapIndex;\n        } else {\n          current = swiper.activeIndex || 0;\n        }\n        if (\n          params.type === \"bullets\" &&\n          swiper.pagination.bullets &&\n          swiper.pagination.bullets.length > 0\n        ) {\n          const bullets = swiper.pagination.bullets;\n          let firstIndex;\n          let lastIndex;\n          let midIndex;\n          if (params.dynamicBullets) {\n            bulletSize = elementOuterSize(\n              bullets[0],\n              swiper.isHorizontal() ? \"width\" : \"height\",\n              true\n            );\n            el.forEach((subEl) => {\n              subEl.style[swiper.isHorizontal() ? \"width\" : \"height\"] = `${\n                bulletSize * (params.dynamicMainBullets + 4)\n              }px`;\n            });\n            if (\n              params.dynamicMainBullets > 1 &&\n              swiper.previousIndex !== void 0\n            ) {\n              dynamicBulletIndex += current - (swiper.previousIndex || 0);\n              if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n                dynamicBulletIndex = params.dynamicMainBullets - 1;\n              } else if (dynamicBulletIndex < 0) {\n                dynamicBulletIndex = 0;\n              }\n            }\n            firstIndex = Math.max(current - dynamicBulletIndex, 0);\n            lastIndex =\n              firstIndex +\n              (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n            midIndex = (lastIndex + firstIndex) / 2;\n          }\n          bullets.forEach((bulletEl) => {\n            bulletEl.classList.remove(\n              ...[\n                \"\",\n                \"-next\",\n                \"-next-next\",\n                \"-prev\",\n                \"-prev-prev\",\n                \"-main\",\n              ].map((suffix) => `${params.bulletActiveClass}${suffix}`)\n            );\n          });\n          if (el.length > 1) {\n            bullets.forEach((bullet) => {\n              const bulletIndex = elementIndex(bullet);\n              if (bulletIndex === current) {\n                bullet.classList.add(params.bulletActiveClass);\n              }\n              if (params.dynamicBullets) {\n                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n                  bullet.classList.add(`${params.bulletActiveClass}-main`);\n                }\n                if (bulletIndex === firstIndex) {\n                  setSideBullets(bullet, \"prev\");\n                }\n                if (bulletIndex === lastIndex) {\n                  setSideBullets(bullet, \"next\");\n                }\n              }\n            });\n          } else {\n            const bullet = bullets[current];\n            if (bullet) {\n              bullet.classList.add(params.bulletActiveClass);\n            }\n            if (params.dynamicBullets) {\n              const firstDisplayedBullet = bullets[firstIndex];\n              const lastDisplayedBullet = bullets[lastIndex];\n              for (let i = firstIndex; i <= lastIndex; i += 1) {\n                if (bullets[i]) {\n                  bullets[i].classList.add(`${params.bulletActiveClass}-main`);\n                }\n              }\n              setSideBullets(firstDisplayedBullet, \"prev\");\n              setSideBullets(lastDisplayedBullet, \"next\");\n            }\n          }\n          if (params.dynamicBullets) {\n            const dynamicBulletsLength = Math.min(\n              bullets.length,\n              params.dynamicMainBullets + 4\n            );\n            const bulletsOffset =\n              (bulletSize * dynamicBulletsLength - bulletSize) / 2 -\n              midIndex * bulletSize;\n            const offsetProp = rtl ? \"right\" : \"left\";\n            bullets.forEach((bullet) => {\n              bullet.style[\n                swiper.isHorizontal() ? offsetProp : \"top\"\n              ] = `${bulletsOffset}px`;\n            });\n          }\n        }\n        el.forEach((subEl, subElIndex) => {\n          if (params.type === \"fraction\") {\n            subEl\n              .querySelectorAll(classesToSelector(params.currentClass))\n              .forEach((fractionEl) => {\n                fractionEl.textContent = params.formatFractionCurrent(\n                  current + 1\n                );\n              });\n            subEl\n              .querySelectorAll(classesToSelector(params.totalClass))\n              .forEach((totalEl) => {\n                totalEl.textContent = params.formatFractionTotal(total);\n              });\n          }\n          if (params.type === \"progressbar\") {\n            let progressbarDirection;\n            if (params.progressbarOpposite) {\n              progressbarDirection = swiper.isHorizontal()\n                ? \"vertical\"\n                : \"horizontal\";\n            } else {\n              progressbarDirection = swiper.isHorizontal()\n                ? \"horizontal\"\n                : \"vertical\";\n            }\n            const scale = (current + 1) / total;\n            let scaleX = 1;\n            let scaleY = 1;\n            if (progressbarDirection === \"horizontal\") {\n              scaleX = scale;\n            } else {\n              scaleY = scale;\n            }\n            subEl\n              .querySelectorAll(classesToSelector(params.progressbarFillClass))\n              .forEach((progressEl) => {\n                progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n                progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n              });\n          }\n          if (params.type === \"custom\" && params.renderCustom) {\n            subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n            if (subElIndex === 0) emit(\"paginationRender\", subEl);\n          } else {\n            if (subElIndex === 0) emit(\"paginationRender\", subEl);\n            emit(\"paginationUpdate\", subEl);\n          }\n          if (swiper.params.watchOverflow && swiper.enabled) {\n            subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](\n              params.lockClass\n            );\n          }\n        });\n      }\n      function render() {\n        const params = swiper.params.pagination;\n        if (isPaginationDisabled()) return;\n        const slidesLength =\n          swiper.virtual && swiper.params.virtual.enabled\n            ? swiper.virtual.slides.length\n            : swiper.slides.length;\n        let el = swiper.pagination.el;\n        el = makeElementsArray(el);\n        let paginationHTML = \"\";\n        if (params.type === \"bullets\") {\n          let numberOfBullets = swiper.params.loop\n            ? Math.ceil(slidesLength / swiper.params.slidesPerGroup)\n            : swiper.snapGrid.length;\n          if (\n            swiper.params.freeMode &&\n            swiper.params.freeMode.enabled &&\n            numberOfBullets > slidesLength\n          ) {\n            numberOfBullets = slidesLength;\n          }\n          for (let i = 0; i < numberOfBullets; i += 1) {\n            if (params.renderBullet) {\n              paginationHTML += params.renderBullet.call(\n                swiper,\n                i,\n                params.bulletClass\n              );\n            } else {\n              paginationHTML += `<${params.bulletElement} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n            }\n          }\n        }\n        if (params.type === \"fraction\") {\n          if (params.renderFraction) {\n            paginationHTML = params.renderFraction.call(\n              swiper,\n              params.currentClass,\n              params.totalClass\n            );\n          } else {\n            paginationHTML = `<span class=\"${params.currentClass}\"></span> / <span class=\"${params.totalClass}\"></span>`;\n          }\n        }\n        if (params.type === \"progressbar\") {\n          if (params.renderProgressbar) {\n            paginationHTML = params.renderProgressbar.call(\n              swiper,\n              params.progressbarFillClass\n            );\n          } else {\n            paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n          }\n        }\n        el.forEach((subEl) => {\n          if (params.type !== \"custom\") {\n            subEl.innerHTML = paginationHTML || \"\";\n          }\n          if (params.type === \"bullets\") {\n            swiper.pagination.bullets = [\n              ...subEl.querySelectorAll(classesToSelector(params.bulletClass)),\n            ];\n          }\n        });\n        if (params.type !== \"custom\") {\n          emit(\"paginationRender\", el[0]);\n        }\n      }\n      function init() {\n        swiper.params.pagination = createElementIfNotDefined(\n          swiper,\n          swiper.originalParams.pagination,\n          swiper.params.pagination,\n          {\n            el: \"swiper-pagination\",\n          }\n        );\n        const params = swiper.params.pagination;\n        if (!params.el) return;\n        let el;\n        if (typeof params.el === \"string\" && swiper.isElement) {\n          el = swiper.el.shadowRoot.querySelector(params.el);\n        }\n        if (!el && typeof params.el === \"string\") {\n          el = [...document.querySelectorAll(params.el)];\n        }\n        if (!el) {\n          el = params.el;\n        }\n        if (!el || el.length === 0) return;\n        if (\n          swiper.params.uniqueNavElements &&\n          typeof params.el === \"string\" &&\n          Array.isArray(el) &&\n          el.length > 1\n        ) {\n          el = [...swiper.el.querySelectorAll(params.el)];\n          if (el.length > 1) {\n            el = el.filter((subEl) => {\n              if (elementParents(subEl, \".swiper\")[0] !== swiper.el)\n                return false;\n              return true;\n            })[0];\n          }\n        }\n        if (Array.isArray(el) && el.length === 1) el = el[0];\n        Object.assign(swiper.pagination, {\n          el,\n        });\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          if (params.type === \"bullets\" && params.clickable) {\n            subEl.classList.add(params.clickableClass);\n          }\n          subEl.classList.add(params.modifierClass + params.type);\n          subEl.classList.add(\n            swiper.isHorizontal()\n              ? params.horizontalClass\n              : params.verticalClass\n          );\n          if (params.type === \"bullets\" && params.dynamicBullets) {\n            subEl.classList.add(\n              `${params.modifierClass}${params.type}-dynamic`\n            );\n            dynamicBulletIndex = 0;\n            if (params.dynamicMainBullets < 1) {\n              params.dynamicMainBullets = 1;\n            }\n          }\n          if (params.type === \"progressbar\" && params.progressbarOpposite) {\n            subEl.classList.add(params.progressbarOppositeClass);\n          }\n          if (params.clickable) {\n            subEl.addEventListener(\"click\", onBulletClick);\n          }\n          if (!swiper.enabled) {\n            subEl.classList.add(params.lockClass);\n          }\n        });\n      }\n      function destroy() {\n        const params = swiper.params.pagination;\n        if (isPaginationDisabled()) return;\n        let el = swiper.pagination.el;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach((subEl) => {\n            subEl.classList.remove(params.hiddenClass);\n            subEl.classList.remove(params.modifierClass + params.type);\n            subEl.classList.remove(\n              swiper.isHorizontal()\n                ? params.horizontalClass\n                : params.verticalClass\n            );\n            if (params.clickable) {\n              subEl.removeEventListener(\"click\", onBulletClick);\n            }\n          });\n        }\n        if (swiper.pagination.bullets)\n          swiper.pagination.bullets.forEach((subEl) =>\n            subEl.classList.remove(params.bulletActiveClass)\n          );\n      }\n      on(\"init\", () => {\n        if (swiper.params.pagination.enabled === false) {\n          disable();\n        } else {\n          init();\n          render();\n          update2();\n        }\n      });\n      on(\"activeIndexChange\", () => {\n        if (typeof swiper.snapIndex === \"undefined\") {\n          update2();\n        }\n      });\n      on(\"snapIndexChange\", () => {\n        update2();\n      });\n      on(\"snapGridLengthChange\", () => {\n        render();\n        update2();\n      });\n      on(\"destroy\", () => {\n        destroy();\n      });\n      on(\"enable disable\", () => {\n        let { el } = swiper.pagination;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach((subEl) =>\n            subEl.classList[swiper.enabled ? \"remove\" : \"add\"](\n              swiper.params.pagination.lockClass\n            )\n          );\n        }\n      });\n      on(\"lock unlock\", () => {\n        update2();\n      });\n      on(\"click\", (_s, e) => {\n        const targetEl = e.target;\n        let { el } = swiper.pagination;\n        if (!Array.isArray(el)) el = [el].filter((element) => !!element);\n        if (\n          swiper.params.pagination.el &&\n          swiper.params.pagination.hideOnClick &&\n          el &&\n          el.length > 0 &&\n          !targetEl.classList.contains(swiper.params.pagination.bulletClass)\n        ) {\n          if (\n            swiper.navigation &&\n            ((swiper.navigation.nextEl &&\n              targetEl === swiper.navigation.nextEl) ||\n              (swiper.navigation.prevEl &&\n                targetEl === swiper.navigation.prevEl))\n          )\n            return;\n          const isHidden = el[0].classList.contains(\n            swiper.params.pagination.hiddenClass\n          );\n          if (isHidden === true) {\n            emit(\"paginationShow\");\n          } else {\n            emit(\"paginationHide\");\n          }\n          el.forEach((subEl) =>\n            subEl.classList.toggle(swiper.params.pagination.hiddenClass)\n          );\n        }\n      });\n      const enable = () => {\n        swiper.el.classList.remove(\n          swiper.params.pagination.paginationDisabledClass\n        );\n        let { el } = swiper.pagination;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach((subEl) =>\n            subEl.classList.remove(\n              swiper.params.pagination.paginationDisabledClass\n            )\n          );\n        }\n        init();\n        render();\n        update2();\n      };\n      const disable = () => {\n        swiper.el.classList.add(\n          swiper.params.pagination.paginationDisabledClass\n        );\n        let { el } = swiper.pagination;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach((subEl) =>\n            subEl.classList.add(\n              swiper.params.pagination.paginationDisabledClass\n            )\n          );\n        }\n        destroy();\n      };\n      Object.assign(swiper.pagination, {\n        enable,\n        disable,\n        render,\n        update: update2,\n        init,\n        destroy,\n      });\n    }\n    function Scrollbar({ swiper, extendParams, on, emit }) {\n      const document2 = getDocument();\n      let isTouched = false;\n      let timeout2 = null;\n      let dragTimeout = null;\n      let dragStartPos;\n      let dragSize;\n      let trackSize;\n      let divider;\n      extendParams({\n        scrollbar: {\n          el: null,\n          dragSize: \"auto\",\n          hide: false,\n          draggable: false,\n          snapOnRelease: true,\n          lockClass: \"swiper-scrollbar-lock\",\n          dragClass: \"swiper-scrollbar-drag\",\n          scrollbarDisabledClass: \"swiper-scrollbar-disabled\",\n          horizontalClass: `swiper-scrollbar-horizontal`,\n          verticalClass: `swiper-scrollbar-vertical`,\n        },\n      });\n      swiper.scrollbar = {\n        el: null,\n        dragEl: null,\n      };\n      function setTranslate2() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        const { scrollbar, rtlTranslate: rtl } = swiper;\n        const { dragEl, el } = scrollbar;\n        const params = swiper.params.scrollbar;\n        const progress = swiper.params.loop\n          ? swiper.progressLoop\n          : swiper.progress;\n        let newSize = dragSize;\n        let newPos = (trackSize - dragSize) * progress;\n        if (rtl) {\n          newPos = -newPos;\n          if (newPos > 0) {\n            newSize = dragSize - newPos;\n            newPos = 0;\n          } else if (-newPos + dragSize > trackSize) {\n            newSize = trackSize + newPos;\n          }\n        } else if (newPos < 0) {\n          newSize = dragSize + newPos;\n          newPos = 0;\n        } else if (newPos + dragSize > trackSize) {\n          newSize = trackSize - newPos;\n        }\n        if (swiper.isHorizontal()) {\n          dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n          dragEl.style.width = `${newSize}px`;\n        } else {\n          dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n          dragEl.style.height = `${newSize}px`;\n        }\n        if (params.hide) {\n          clearTimeout(timeout2);\n          el.style.opacity = 1;\n          timeout2 = setTimeout(() => {\n            el.style.opacity = 0;\n            el.style.transitionDuration = \"400ms\";\n          }, 1e3);\n        }\n      }\n      function setTransition2(duration) {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n      }\n      function updateSize2() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        const { scrollbar } = swiper;\n        const { dragEl, el } = scrollbar;\n        dragEl.style.width = \"\";\n        dragEl.style.height = \"\";\n        trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n        divider =\n          swiper.size /\n          (swiper.virtualSize +\n            swiper.params.slidesOffsetBefore -\n            (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n        if (swiper.params.scrollbar.dragSize === \"auto\") {\n          dragSize = trackSize * divider;\n        } else {\n          dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n        }\n        if (swiper.isHorizontal()) {\n          dragEl.style.width = `${dragSize}px`;\n        } else {\n          dragEl.style.height = `${dragSize}px`;\n        }\n        if (divider >= 1) {\n          el.style.display = \"none\";\n        } else {\n          el.style.display = \"\";\n        }\n        if (swiper.params.scrollbar.hide) {\n          el.style.opacity = 0;\n        }\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          scrollbar.el.classList[swiper.isLocked ? \"add\" : \"remove\"](\n            swiper.params.scrollbar.lockClass\n          );\n        }\n      }\n      function getPointerPosition(e) {\n        return swiper.isHorizontal() ? e.clientX : e.clientY;\n      }\n      function setDragPosition(e) {\n        const { scrollbar, rtlTranslate: rtl } = swiper;\n        const { el } = scrollbar;\n        let positionRatio;\n        positionRatio =\n          (getPointerPosition(e) -\n            elementOffset(el)[swiper.isHorizontal() ? \"left\" : \"top\"] -\n            (dragStartPos !== null ? dragStartPos : dragSize / 2)) /\n          (trackSize - dragSize);\n        positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n        if (rtl) {\n          positionRatio = 1 - positionRatio;\n        }\n        const position =\n          swiper.minTranslate() +\n          (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n        swiper.updateProgress(position);\n        swiper.setTranslate(position);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      function onDragStart(e) {\n        const params = swiper.params.scrollbar;\n        const { scrollbar, wrapperEl } = swiper;\n        const { el, dragEl } = scrollbar;\n        isTouched = true;\n        dragStartPos =\n          e.target === dragEl\n            ? getPointerPosition(e) -\n              e.target.getBoundingClientRect()[\n                swiper.isHorizontal() ? \"left\" : \"top\"\n              ]\n            : null;\n        e.preventDefault();\n        e.stopPropagation();\n        wrapperEl.style.transitionDuration = \"100ms\";\n        dragEl.style.transitionDuration = \"100ms\";\n        setDragPosition(e);\n        clearTimeout(dragTimeout);\n        el.style.transitionDuration = \"0ms\";\n        if (params.hide) {\n          el.style.opacity = 1;\n        }\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style[\"scroll-snap-type\"] = \"none\";\n        }\n        emit(\"scrollbarDragStart\", e);\n      }\n      function onDragMove(e) {\n        const { scrollbar, wrapperEl } = swiper;\n        const { el, dragEl } = scrollbar;\n        if (!isTouched) return;\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n        setDragPosition(e);\n        wrapperEl.style.transitionDuration = \"0ms\";\n        el.style.transitionDuration = \"0ms\";\n        dragEl.style.transitionDuration = \"0ms\";\n        emit(\"scrollbarDragMove\", e);\n      }\n      function onDragEnd(e) {\n        const params = swiper.params.scrollbar;\n        const { scrollbar, wrapperEl } = swiper;\n        const { el } = scrollbar;\n        if (!isTouched) return;\n        isTouched = false;\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style[\"scroll-snap-type\"] = \"\";\n          wrapperEl.style.transitionDuration = \"\";\n        }\n        if (params.hide) {\n          clearTimeout(dragTimeout);\n          dragTimeout = nextTick(() => {\n            el.style.opacity = 0;\n            el.style.transitionDuration = \"400ms\";\n          }, 1e3);\n        }\n        emit(\"scrollbarDragEnd\", e);\n        if (params.snapOnRelease) {\n          swiper.slideToClosest();\n        }\n      }\n      function events2(method) {\n        const { scrollbar, params } = swiper;\n        const el = scrollbar.el;\n        if (!el) return;\n        const target = el;\n        const activeListener = params.passiveListeners\n          ? {\n              passive: false,\n              capture: false,\n            }\n          : false;\n        const passiveListener = params.passiveListeners\n          ? {\n              passive: true,\n              capture: false,\n            }\n          : false;\n        if (!target) return;\n        const eventMethod =\n          method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n        target[eventMethod](\"pointerdown\", onDragStart, activeListener);\n        document2[eventMethod](\"pointermove\", onDragMove, activeListener);\n        document2[eventMethod](\"pointerup\", onDragEnd, passiveListener);\n      }\n      function enableDraggable() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        events2(\"on\");\n      }\n      function disableDraggable() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n        events2(\"off\");\n      }\n      function init() {\n        const { scrollbar, el: swiperEl } = swiper;\n        swiper.params.scrollbar = createElementIfNotDefined(\n          swiper,\n          swiper.originalParams.scrollbar,\n          swiper.params.scrollbar,\n          {\n            el: \"swiper-scrollbar\",\n          }\n        );\n        const params = swiper.params.scrollbar;\n        if (!params.el) return;\n        let el;\n        if (typeof params.el === \"string\" && swiper.isElement) {\n          el = swiper.el.shadowRoot.querySelector(params.el);\n        }\n        if (!el && typeof params.el === \"string\") {\n          el = document2.querySelectorAll(params.el);\n        } else if (!el) {\n          el = params.el;\n        }\n        if (\n          swiper.params.uniqueNavElements &&\n          typeof params.el === \"string\" &&\n          el.length > 1 &&\n          swiperEl.querySelectorAll(params.el).length === 1\n        ) {\n          el = swiperEl.querySelector(params.el);\n        }\n        if (el.length > 0) el = el[0];\n        el.classList.add(\n          swiper.isHorizontal() ? params.horizontalClass : params.verticalClass\n        );\n        let dragEl;\n        if (el) {\n          dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n          if (!dragEl) {\n            dragEl = createElement(\"div\", swiper.params.scrollbar.dragClass);\n            el.append(dragEl);\n          }\n        }\n        Object.assign(scrollbar, {\n          el,\n          dragEl,\n        });\n        if (params.draggable) {\n          enableDraggable();\n        }\n        if (el) {\n          el.classList[swiper.enabled ? \"remove\" : \"add\"](\n            swiper.params.scrollbar.lockClass\n          );\n        }\n      }\n      function destroy() {\n        const params = swiper.params.scrollbar;\n        const el = swiper.scrollbar.el;\n        if (el) {\n          el.classList.remove(\n            swiper.isHorizontal()\n              ? params.horizontalClass\n              : params.verticalClass\n          );\n        }\n        disableDraggable();\n      }\n      on(\"init\", () => {\n        if (swiper.params.scrollbar.enabled === false) {\n          disable();\n        } else {\n          init();\n          updateSize2();\n          setTranslate2();\n        }\n      });\n      on(\"update resize observerUpdate lock unlock\", () => {\n        updateSize2();\n      });\n      on(\"setTranslate\", () => {\n        setTranslate2();\n      });\n      on(\"setTransition\", (_s, duration) => {\n        setTransition2(duration);\n      });\n      on(\"enable disable\", () => {\n        const { el } = swiper.scrollbar;\n        if (el) {\n          el.classList[swiper.enabled ? \"remove\" : \"add\"](\n            swiper.params.scrollbar.lockClass\n          );\n        }\n      });\n      on(\"destroy\", () => {\n        destroy();\n      });\n      const enable = () => {\n        swiper.el.classList.remove(\n          swiper.params.scrollbar.scrollbarDisabledClass\n        );\n        if (swiper.scrollbar.el) {\n          swiper.scrollbar.el.classList.remove(\n            swiper.params.scrollbar.scrollbarDisabledClass\n          );\n        }\n        init();\n        updateSize2();\n        setTranslate2();\n      };\n      const disable = () => {\n        swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n        if (swiper.scrollbar.el) {\n          swiper.scrollbar.el.classList.add(\n            swiper.params.scrollbar.scrollbarDisabledClass\n          );\n        }\n        destroy();\n      };\n      Object.assign(swiper.scrollbar, {\n        enable,\n        disable,\n        updateSize: updateSize2,\n        setTranslate: setTranslate2,\n        init,\n        destroy,\n      });\n    }\n    function Parallax({ swiper, extendParams, on }) {\n      extendParams({\n        parallax: {\n          enabled: false,\n        },\n      });\n      const setTransform = (el, progress) => {\n        const { rtl } = swiper;\n        const rtlFactor = rtl ? -1 : 1;\n        const p = el.getAttribute(\"data-swiper-parallax\") || \"0\";\n        let x = el.getAttribute(\"data-swiper-parallax-x\");\n        let y = el.getAttribute(\"data-swiper-parallax-y\");\n        const scale = el.getAttribute(\"data-swiper-parallax-scale\");\n        const opacity = el.getAttribute(\"data-swiper-parallax-opacity\");\n        const rotate = el.getAttribute(\"data-swiper-parallax-rotate\");\n        if (x || y) {\n          x = x || \"0\";\n          y = y || \"0\";\n        } else if (swiper.isHorizontal()) {\n          x = p;\n          y = \"0\";\n        } else {\n          y = p;\n          x = \"0\";\n        }\n        if (x.indexOf(\"%\") >= 0) {\n          x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n        } else {\n          x = `${x * progress * rtlFactor}px`;\n        }\n        if (y.indexOf(\"%\") >= 0) {\n          y = `${parseInt(y, 10) * progress}%`;\n        } else {\n          y = `${y * progress}px`;\n        }\n        if (typeof opacity !== \"undefined\" && opacity !== null) {\n          const currentOpacity =\n            opacity - (opacity - 1) * (1 - Math.abs(progress));\n          el.style.opacity = currentOpacity;\n        }\n        let transform = `translate3d(${x}, ${y}, 0px)`;\n        if (typeof scale !== \"undefined\" && scale !== null) {\n          const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n          transform += ` scale(${currentScale})`;\n        }\n        if (rotate && typeof rotate !== \"undefined\" && rotate !== null) {\n          const currentRotate = rotate * progress * -1;\n          transform += ` rotate(${currentRotate}deg)`;\n        }\n        el.style.transform = transform;\n      };\n      const setTranslate2 = () => {\n        const { el, slides, progress, snapGrid } = swiper;\n        elementChildren(\n          el,\n          \"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\"\n        ).forEach((subEl) => {\n          setTransform(subEl, progress);\n        });\n        slides.forEach((slideEl, slideIndex) => {\n          let slideProgress = slideEl.progress;\n          if (\n            swiper.params.slidesPerGroup > 1 &&\n            swiper.params.slidesPerView !== \"auto\"\n          ) {\n            slideProgress +=\n              Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n          }\n          slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n          slideEl\n            .querySelectorAll(\n              \"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]\"\n            )\n            .forEach((subEl) => {\n              setTransform(subEl, slideProgress);\n            });\n        });\n      };\n      const setTransition2 = (duration = swiper.params.speed) => {\n        const { el } = swiper;\n        el.querySelectorAll(\n          \"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\"\n        ).forEach((parallaxEl) => {\n          let parallaxDuration =\n            parseInt(\n              parallaxEl.getAttribute(\"data-swiper-parallax-duration\"),\n              10\n            ) || duration;\n          if (duration === 0) parallaxDuration = 0;\n          parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n        });\n      };\n      on(\"beforeInit\", () => {\n        if (!swiper.params.parallax.enabled) return;\n        swiper.params.watchSlidesProgress = true;\n        swiper.originalParams.watchSlidesProgress = true;\n      });\n      on(\"init\", () => {\n        if (!swiper.params.parallax.enabled) return;\n        setTranslate2();\n      });\n      on(\"setTranslate\", () => {\n        if (!swiper.params.parallax.enabled) return;\n        setTranslate2();\n      });\n      on(\"setTransition\", (_swiper, duration) => {\n        if (!swiper.params.parallax.enabled) return;\n        setTransition2(duration);\n      });\n    }\n    function Zoom({ swiper, extendParams, on, emit }) {\n      const window2 = getWindow();\n      extendParams({\n        zoom: {\n          enabled: false,\n          maxRatio: 3,\n          minRatio: 1,\n          toggle: true,\n          containerClass: \"swiper-zoom-container\",\n          zoomedSlideClass: \"swiper-slide-zoomed\",\n        },\n      });\n      swiper.zoom = {\n        enabled: false,\n      };\n      let currentScale = 1;\n      let isScaling = false;\n      let fakeGestureTouched;\n      let fakeGestureMoved;\n      const evCache = [];\n      const gesture = {\n        slideEl: void 0,\n        slideWidth: void 0,\n        slideHeight: void 0,\n        imageEl: void 0,\n        imageWrapEl: void 0,\n        maxRatio: 3,\n      };\n      const image = {\n        isTouched: void 0,\n        isMoved: void 0,\n        currentX: void 0,\n        currentY: void 0,\n        minX: void 0,\n        minY: void 0,\n        maxX: void 0,\n        maxY: void 0,\n        width: void 0,\n        height: void 0,\n        startX: void 0,\n        startY: void 0,\n        touchesStart: {},\n        touchesCurrent: {},\n      };\n      const velocity = {\n        x: void 0,\n        y: void 0,\n        prevPositionX: void 0,\n        prevPositionY: void 0,\n        prevTime: void 0,\n      };\n      let scale = 1;\n      Object.defineProperty(swiper.zoom, \"scale\", {\n        get() {\n          return scale;\n        },\n        set(value) {\n          if (scale !== value) {\n            const imageEl = gesture.imageEl;\n            const slideEl = gesture.slideEl;\n            emit(\"zoomChange\", value, imageEl, slideEl);\n          }\n          scale = value;\n        },\n      });\n      function getDistanceBetweenTouches() {\n        if (evCache.length < 2) return 1;\n        const x1 = evCache[0].pageX;\n        const y1 = evCache[0].pageY;\n        const x2 = evCache[1].pageX;\n        const y2 = evCache[1].pageY;\n        const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n        return distance;\n      }\n      function getScaleOrigin() {\n        if (evCache.length < 2)\n          return {\n            x: null,\n            y: null,\n          };\n        const box = gesture.imageEl.getBoundingClientRect();\n        return [\n          (evCache[0].pageX +\n            (evCache[1].pageX - evCache[0].pageX) / 2 -\n            box.x) /\n            currentScale,\n          (evCache[0].pageY +\n            (evCache[1].pageY - evCache[0].pageY) / 2 -\n            box.y) /\n            currentScale,\n        ];\n      }\n      function getSlideSelector() {\n        return swiper.isElement\n          ? `swiper-slide`\n          : `.${swiper.params.slideClass}`;\n      }\n      function eventWithinSlide(e) {\n        const slideSelector = getSlideSelector();\n        if (e.target.matches(slideSelector)) return true;\n        if (\n          swiper.slides.filter((slideEl) => slideEl.contains(e.target)).length >\n          0\n        )\n          return true;\n        return false;\n      }\n      function eventWithinZoomContainer(e) {\n        const selector = `.${swiper.params.zoom.containerClass}`;\n        if (e.target.matches(selector)) return true;\n        if (\n          [...swiper.el.querySelectorAll(selector)].filter((containerEl) =>\n            containerEl.contains(e.target)\n          ).length > 0\n        )\n          return true;\n        return false;\n      }\n      function onGestureStart(e) {\n        if (e.pointerType === \"mouse\") {\n          evCache.splice(0, evCache.length);\n        }\n        if (!eventWithinSlide(e)) return;\n        const params = swiper.params.zoom;\n        fakeGestureTouched = false;\n        fakeGestureMoved = false;\n        evCache.push(e);\n        if (evCache.length < 2) {\n          return;\n        }\n        fakeGestureTouched = true;\n        gesture.scaleStart = getDistanceBetweenTouches();\n        if (!gesture.slideEl) {\n          gesture.slideEl = e.target.closest(\n            `.${swiper.params.slideClass}, swiper-slide`\n          );\n          if (!gesture.slideEl)\n            gesture.slideEl = swiper.slides[swiper.activeIndex];\n          let imageEl = gesture.slideEl.querySelector(\n            `.${params.containerClass}`\n          );\n          if (imageEl) {\n            imageEl = imageEl.querySelectorAll(\n              \"picture, img, svg, canvas, .swiper-zoom-target\"\n            )[0];\n          }\n          gesture.imageEl = imageEl;\n          if (imageEl) {\n            gesture.imageWrapEl = elementParents(\n              gesture.imageEl,\n              `.${params.containerClass}`\n            )[0];\n          } else {\n            gesture.imageWrapEl = void 0;\n          }\n          if (!gesture.imageWrapEl) {\n            gesture.imageEl = void 0;\n            return;\n          }\n          gesture.maxRatio =\n            gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") ||\n            params.maxRatio;\n        }\n        if (gesture.imageEl) {\n          const [originX, originY] = getScaleOrigin();\n          gesture.imageEl.style.transformOrigin = `${originX}px ${originY}px`;\n          gesture.imageEl.style.transitionDuration = \"0ms\";\n        }\n        isScaling = true;\n      }\n      function onGestureChange(e) {\n        if (!eventWithinSlide(e)) return;\n        const params = swiper.params.zoom;\n        const zoom = swiper.zoom;\n        const pointerIndex = evCache.findIndex(\n          (cachedEv) => cachedEv.pointerId === e.pointerId\n        );\n        if (pointerIndex >= 0) evCache[pointerIndex] = e;\n        if (evCache.length < 2) {\n          return;\n        }\n        fakeGestureMoved = true;\n        gesture.scaleMove = getDistanceBetweenTouches();\n        if (!gesture.imageEl) {\n          return;\n        }\n        zoom.scale = (gesture.scaleMove / gesture.scaleStart) * currentScale;\n        if (zoom.scale > gesture.maxRatio) {\n          zoom.scale =\n            gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n        }\n        if (zoom.scale < params.minRatio) {\n          zoom.scale =\n            params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n        }\n        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n      }\n      function onGestureEnd(e) {\n        if (!eventWithinSlide(e)) return;\n        if (e.pointerType === \"mouse\" && e.type === \"pointerout\") return;\n        const params = swiper.params.zoom;\n        const zoom = swiper.zoom;\n        const pointerIndex = evCache.findIndex(\n          (cachedEv) => cachedEv.pointerId === e.pointerId\n        );\n        if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n        if (!fakeGestureTouched || !fakeGestureMoved) {\n          return;\n        }\n        fakeGestureTouched = false;\n        fakeGestureMoved = false;\n        if (!gesture.imageEl) return;\n        zoom.scale = Math.max(\n          Math.min(zoom.scale, gesture.maxRatio),\n          params.minRatio\n        );\n        gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n        currentScale = zoom.scale;\n        isScaling = false;\n        if (zoom.scale === 1) gesture.slideEl = void 0;\n      }\n      function onTouchStart2(e) {\n        const device = swiper.device;\n        if (!gesture.imageEl) return;\n        if (image.isTouched) return;\n        if (device.android && e.cancelable) e.preventDefault();\n        image.isTouched = true;\n        image.touchesStart.x = e.pageX;\n        image.touchesStart.y = e.pageY;\n      }\n      function onTouchMove2(e) {\n        if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n        const zoom = swiper.zoom;\n        if (!gesture.imageEl) return;\n        swiper.allowClick = false;\n        if (!image.isTouched || !gesture.slideEl) return;\n        if (!image.isMoved) {\n          image.width = gesture.imageEl.offsetWidth;\n          image.height = gesture.imageEl.offsetHeight;\n          image.startX = getTranslate(gesture.imageWrapEl, \"x\") || 0;\n          image.startY = getTranslate(gesture.imageWrapEl, \"y\") || 0;\n          gesture.slideWidth = gesture.slideEl.offsetWidth;\n          gesture.slideHeight = gesture.slideEl.offsetHeight;\n          gesture.imageWrapEl.style.transitionDuration = \"0ms\";\n        }\n        const scaledWidth = image.width * zoom.scale;\n        const scaledHeight = image.height * zoom.scale;\n        if (\n          scaledWidth < gesture.slideWidth &&\n          scaledHeight < gesture.slideHeight\n        )\n          return;\n        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n        image.maxX = -image.minX;\n        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n        image.maxY = -image.minY;\n        image.touchesCurrent.x =\n          evCache.length > 0 ? evCache[0].pageX : e.pageX;\n        image.touchesCurrent.y =\n          evCache.length > 0 ? evCache[0].pageY : e.pageY;\n        if (!image.isMoved && !isScaling) {\n          if (\n            swiper.isHorizontal() &&\n            ((Math.floor(image.minX) === Math.floor(image.startX) &&\n              image.touchesCurrent.x < image.touchesStart.x) ||\n              (Math.floor(image.maxX) === Math.floor(image.startX) &&\n                image.touchesCurrent.x > image.touchesStart.x))\n          ) {\n            image.isTouched = false;\n            return;\n          }\n          if (\n            !swiper.isHorizontal() &&\n            ((Math.floor(image.minY) === Math.floor(image.startY) &&\n              image.touchesCurrent.y < image.touchesStart.y) ||\n              (Math.floor(image.maxY) === Math.floor(image.startY) &&\n                image.touchesCurrent.y > image.touchesStart.y))\n          ) {\n            image.isTouched = false;\n            return;\n          }\n        }\n        if (e.cancelable) {\n          e.preventDefault();\n        }\n        e.stopPropagation();\n        image.isMoved = true;\n        image.currentX =\n          image.touchesCurrent.x - image.touchesStart.x + image.startX;\n        image.currentY =\n          image.touchesCurrent.y - image.touchesStart.y + image.startY;\n        if (image.currentX < image.minX) {\n          image.currentX =\n            image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n        }\n        if (image.currentX > image.maxX) {\n          image.currentX =\n            image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n        }\n        if (image.currentY < image.minY) {\n          image.currentY =\n            image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n        }\n        if (image.currentY > image.maxY) {\n          image.currentY =\n            image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n        }\n        if (!velocity.prevPositionX)\n          velocity.prevPositionX = image.touchesCurrent.x;\n        if (!velocity.prevPositionY)\n          velocity.prevPositionY = image.touchesCurrent.y;\n        if (!velocity.prevTime) velocity.prevTime = Date.now();\n        velocity.x =\n          (image.touchesCurrent.x - velocity.prevPositionX) /\n          (Date.now() - velocity.prevTime) /\n          2;\n        velocity.y =\n          (image.touchesCurrent.y - velocity.prevPositionY) /\n          (Date.now() - velocity.prevTime) /\n          2;\n        if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2)\n          velocity.x = 0;\n        if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2)\n          velocity.y = 0;\n        velocity.prevPositionX = image.touchesCurrent.x;\n        velocity.prevPositionY = image.touchesCurrent.y;\n        velocity.prevTime = Date.now();\n        gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n      }\n      function onTouchEnd2() {\n        const zoom = swiper.zoom;\n        if (!gesture.imageEl) return;\n        if (!image.isTouched || !image.isMoved) {\n          image.isTouched = false;\n          image.isMoved = false;\n          return;\n        }\n        image.isTouched = false;\n        image.isMoved = false;\n        let momentumDurationX = 300;\n        let momentumDurationY = 300;\n        const momentumDistanceX = velocity.x * momentumDurationX;\n        const newPositionX = image.currentX + momentumDistanceX;\n        const momentumDistanceY = velocity.y * momentumDurationY;\n        const newPositionY = image.currentY + momentumDistanceY;\n        if (velocity.x !== 0)\n          momentumDurationX = Math.abs(\n            (newPositionX - image.currentX) / velocity.x\n          );\n        if (velocity.y !== 0)\n          momentumDurationY = Math.abs(\n            (newPositionY - image.currentY) / velocity.y\n          );\n        const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n        image.currentX = newPositionX;\n        image.currentY = newPositionY;\n        const scaledWidth = image.width * zoom.scale;\n        const scaledHeight = image.height * zoom.scale;\n        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n        image.maxX = -image.minX;\n        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n        image.maxY = -image.minY;\n        image.currentX = Math.max(\n          Math.min(image.currentX, image.maxX),\n          image.minX\n        );\n        image.currentY = Math.max(\n          Math.min(image.currentY, image.maxY),\n          image.minY\n        );\n        gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n        gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n      }\n      function onTransitionEnd() {\n        const zoom = swiper.zoom;\n        if (gesture.slideEl && swiper.previousIndex !== swiper.activeIndex) {\n          if (gesture.imageEl) {\n            gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n          }\n          if (gesture.imageWrapEl) {\n            gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n          }\n          zoom.scale = 1;\n          currentScale = 1;\n          gesture.slideEl = void 0;\n          gesture.imageEl = void 0;\n          gesture.imageWrapEl = void 0;\n        }\n      }\n      function zoomIn(e) {\n        const zoom = swiper.zoom;\n        const params = swiper.params.zoom;\n        if (!gesture.slideEl) {\n          if (e && e.target) {\n            gesture.slideEl = e.target.closest(\n              `.${swiper.params.slideClass}, swiper-slide`\n            );\n          }\n          if (!gesture.slideEl) {\n            if (\n              swiper.params.virtual &&\n              swiper.params.virtual.enabled &&\n              swiper.virtual\n            ) {\n              gesture.slideEl = elementChildren(\n                swiper.slidesEl,\n                `.${swiper.params.slideActiveClass}`\n              )[0];\n            } else {\n              gesture.slideEl = swiper.slides[swiper.activeIndex];\n            }\n          }\n          let imageEl = gesture.slideEl.querySelector(\n            `.${params.containerClass}`\n          );\n          if (imageEl) {\n            imageEl = imageEl.querySelectorAll(\n              \"picture, img, svg, canvas, .swiper-zoom-target\"\n            )[0];\n          }\n          gesture.imageEl = imageEl;\n          if (imageEl) {\n            gesture.imageWrapEl = elementParents(\n              gesture.imageEl,\n              `.${params.containerClass}`\n            )[0];\n          } else {\n            gesture.imageWrapEl = void 0;\n          }\n        }\n        if (!gesture.imageEl || !gesture.imageWrapEl) return;\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style.overflow = \"hidden\";\n          swiper.wrapperEl.style.touchAction = \"none\";\n        }\n        gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n        let touchX;\n        let touchY;\n        let offsetX;\n        let offsetY;\n        let diffX;\n        let diffY;\n        let translateX;\n        let translateY;\n        let imageWidth;\n        let imageHeight;\n        let scaledWidth;\n        let scaledHeight;\n        let translateMinX;\n        let translateMinY;\n        let translateMaxX;\n        let translateMaxY;\n        let slideWidth;\n        let slideHeight;\n        if (typeof image.touchesStart.x === \"undefined\" && e) {\n          touchX = e.pageX;\n          touchY = e.pageY;\n        } else {\n          touchX = image.touchesStart.x;\n          touchY = image.touchesStart.y;\n        }\n        const forceZoomRatio = typeof e === \"number\" ? e : null;\n        if (currentScale === 1 && forceZoomRatio) {\n          touchX = void 0;\n          touchY = void 0;\n        }\n        zoom.scale =\n          forceZoomRatio ||\n          gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") ||\n          params.maxRatio;\n        currentScale =\n          forceZoomRatio ||\n          gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") ||\n          params.maxRatio;\n        if (e && !(currentScale === 1 && forceZoomRatio)) {\n          slideWidth = gesture.slideEl.offsetWidth;\n          slideHeight = gesture.slideEl.offsetHeight;\n          offsetX = elementOffset(gesture.slideEl).left + window2.scrollX;\n          offsetY = elementOffset(gesture.slideEl).top + window2.scrollY;\n          diffX = offsetX + slideWidth / 2 - touchX;\n          diffY = offsetY + slideHeight / 2 - touchY;\n          imageWidth = gesture.imageEl.offsetWidth;\n          imageHeight = gesture.imageEl.offsetHeight;\n          scaledWidth = imageWidth * zoom.scale;\n          scaledHeight = imageHeight * zoom.scale;\n          translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n          translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n          translateMaxX = -translateMinX;\n          translateMaxY = -translateMinY;\n          translateX = diffX * zoom.scale;\n          translateY = diffY * zoom.scale;\n          if (translateX < translateMinX) {\n            translateX = translateMinX;\n          }\n          if (translateX > translateMaxX) {\n            translateX = translateMaxX;\n          }\n          if (translateY < translateMinY) {\n            translateY = translateMinY;\n          }\n          if (translateY > translateMaxY) {\n            translateY = translateMaxY;\n          }\n        } else {\n          translateX = 0;\n          translateY = 0;\n        }\n        gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n        gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n        gesture.imageEl.style.transitionDuration = \"300ms\";\n        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n      }\n      function zoomOut() {\n        const zoom = swiper.zoom;\n        const params = swiper.params.zoom;\n        if (!gesture.slideEl) {\n          if (\n            swiper.params.virtual &&\n            swiper.params.virtual.enabled &&\n            swiper.virtual\n          ) {\n            gesture.slideEl = elementChildren(\n              swiper.slidesEl,\n              `.${swiper.params.slideActiveClass}`\n            )[0];\n          } else {\n            gesture.slideEl = swiper.slides[swiper.activeIndex];\n          }\n          let imageEl = gesture.slideEl.querySelector(\n            `.${params.containerClass}`\n          );\n          if (imageEl) {\n            imageEl = imageEl.querySelectorAll(\n              \"picture, img, svg, canvas, .swiper-zoom-target\"\n            )[0];\n          }\n          gesture.imageEl = imageEl;\n          if (imageEl) {\n            gesture.imageWrapEl = elementParents(\n              gesture.imageEl,\n              `.${params.containerClass}`\n            )[0];\n          } else {\n            gesture.imageWrapEl = void 0;\n          }\n        }\n        if (!gesture.imageEl || !gesture.imageWrapEl) return;\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style.overflow = \"\";\n          swiper.wrapperEl.style.touchAction = \"\";\n        }\n        zoom.scale = 1;\n        currentScale = 1;\n        gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n        gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n        gesture.imageEl.style.transitionDuration = \"300ms\";\n        gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n        gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n        gesture.slideEl = void 0;\n      }\n      function zoomToggle(e) {\n        const zoom = swiper.zoom;\n        if (zoom.scale && zoom.scale !== 1) {\n          zoomOut();\n        } else {\n          zoomIn(e);\n        }\n      }\n      function getListeners() {\n        const passiveListener = swiper.params.passiveListeners\n          ? {\n              passive: true,\n              capture: false,\n            }\n          : false;\n        const activeListenerWithCapture = swiper.params.passiveListeners\n          ? {\n              passive: false,\n              capture: true,\n            }\n          : true;\n        return {\n          passiveListener,\n          activeListenerWithCapture,\n        };\n      }\n      function enable() {\n        const zoom = swiper.zoom;\n        if (zoom.enabled) return;\n        zoom.enabled = true;\n        const { passiveListener, activeListenerWithCapture } = getListeners();\n        swiper.wrapperEl.addEventListener(\n          \"pointerdown\",\n          onGestureStart,\n          passiveListener\n        );\n        swiper.wrapperEl.addEventListener(\n          \"pointermove\",\n          onGestureChange,\n          activeListenerWithCapture\n        );\n        [\"pointerup\", \"pointercancel\", \"pointerout\"].forEach((eventName) => {\n          swiper.wrapperEl.addEventListener(\n            eventName,\n            onGestureEnd,\n            passiveListener\n          );\n        });\n        swiper.wrapperEl.addEventListener(\n          \"pointermove\",\n          onTouchMove2,\n          activeListenerWithCapture\n        );\n      }\n      function disable() {\n        const zoom = swiper.zoom;\n        if (!zoom.enabled) return;\n        zoom.enabled = false;\n        const { passiveListener, activeListenerWithCapture } = getListeners();\n        swiper.wrapperEl.removeEventListener(\n          \"pointerdown\",\n          onGestureStart,\n          passiveListener\n        );\n        swiper.wrapperEl.removeEventListener(\n          \"pointermove\",\n          onGestureChange,\n          activeListenerWithCapture\n        );\n        [\"pointerup\", \"pointercancel\", \"pointerout\"].forEach((eventName) => {\n          swiper.wrapperEl.removeEventListener(\n            eventName,\n            onGestureEnd,\n            passiveListener\n          );\n        });\n        swiper.wrapperEl.removeEventListener(\n          \"pointermove\",\n          onTouchMove2,\n          activeListenerWithCapture\n        );\n      }\n      on(\"init\", () => {\n        if (swiper.params.zoom.enabled) {\n          enable();\n        }\n      });\n      on(\"destroy\", () => {\n        disable();\n      });\n      on(\"touchStart\", (_s, e) => {\n        if (!swiper.zoom.enabled) return;\n        onTouchStart2(e);\n      });\n      on(\"touchEnd\", (_s, e) => {\n        if (!swiper.zoom.enabled) return;\n        onTouchEnd2(e);\n      });\n      on(\"doubleTap\", (_s, e) => {\n        if (\n          !swiper.animating &&\n          swiper.params.zoom.enabled &&\n          swiper.zoom.enabled &&\n          swiper.params.zoom.toggle\n        ) {\n          zoomToggle(e);\n        }\n      });\n      on(\"transitionEnd\", () => {\n        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n          onTransitionEnd();\n        }\n      });\n      on(\"slideChange\", () => {\n        if (\n          swiper.zoom.enabled &&\n          swiper.params.zoom.enabled &&\n          swiper.params.cssMode\n        ) {\n          onTransitionEnd();\n        }\n      });\n      Object.assign(swiper.zoom, {\n        enable,\n        disable,\n        in: zoomIn,\n        out: zoomOut,\n        toggle: zoomToggle,\n      });\n    }\n    function Controller({ swiper, extendParams, on }) {\n      extendParams({\n        controller: {\n          control: void 0,\n          inverse: false,\n          by: \"slide\",\n          // or 'container'\n        },\n      });\n      swiper.controller = {\n        control: void 0,\n      };\n      function LinearSpline(x, y) {\n        const binarySearch = (function search() {\n          let maxIndex;\n          let minIndex;\n          let guess;\n          return (array, val) => {\n            minIndex = -1;\n            maxIndex = array.length;\n            while (maxIndex - minIndex > 1) {\n              guess = (maxIndex + minIndex) >> 1;\n              if (array[guess] <= val) {\n                minIndex = guess;\n              } else {\n                maxIndex = guess;\n              }\n            }\n            return maxIndex;\n          };\n        })();\n        this.x = x;\n        this.y = y;\n        this.lastIndex = x.length - 1;\n        let i1;\n        let i3;\n        this.interpolate = function interpolate(x2) {\n          if (!x2) return 0;\n          i3 = binarySearch(this.x, x2);\n          i1 = i3 - 1;\n          return (\n            ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) /\n              (this.x[i3] - this.x[i1]) +\n            this.y[i1]\n          );\n        };\n        return this;\n      }\n      function getInterpolateFunction(c) {\n        if (!swiper.controller.spline) {\n          swiper.controller.spline = swiper.params.loop\n            ? new LinearSpline(swiper.slidesGrid, c.slidesGrid)\n            : new LinearSpline(swiper.snapGrid, c.snapGrid);\n        }\n      }\n      function setTranslate2(_t, byController) {\n        const controlled = swiper.controller.control;\n        let multiplier;\n        let controlledTranslate;\n        const Swiper2 = swiper.constructor;\n        function setControlledTranslate(c) {\n          const translate2 = swiper.rtlTranslate\n            ? -swiper.translate\n            : swiper.translate;\n          if (swiper.params.controller.by === \"slide\") {\n            getInterpolateFunction(c);\n            controlledTranslate = -swiper.controller.spline.interpolate(\n              -translate2\n            );\n          }\n          if (\n            !controlledTranslate ||\n            swiper.params.controller.by === \"container\"\n          ) {\n            multiplier =\n              (c.maxTranslate() - c.minTranslate()) /\n              (swiper.maxTranslate() - swiper.minTranslate());\n            controlledTranslate =\n              (translate2 - swiper.minTranslate()) * multiplier +\n              c.minTranslate();\n          }\n          if (swiper.params.controller.inverse) {\n            controlledTranslate = c.maxTranslate() - controlledTranslate;\n          }\n          c.updateProgress(controlledTranslate);\n          c.setTranslate(controlledTranslate, swiper);\n          c.updateActiveIndex();\n          c.updateSlidesClasses();\n        }\n        if (Array.isArray(controlled)) {\n          for (let i = 0; i < controlled.length; i += 1) {\n            if (\n              controlled[i] !== byController &&\n              controlled[i] instanceof Swiper2\n            ) {\n              setControlledTranslate(controlled[i]);\n            }\n          }\n        } else if (\n          controlled instanceof Swiper2 &&\n          byController !== controlled\n        ) {\n          setControlledTranslate(controlled);\n        }\n      }\n      function setTransition2(duration, byController) {\n        const Swiper2 = swiper.constructor;\n        const controlled = swiper.controller.control;\n        let i;\n        function setControlledTransition(c) {\n          c.setTransition(duration, swiper);\n          if (duration !== 0) {\n            c.transitionStart();\n            if (c.params.autoHeight) {\n              nextTick(() => {\n                c.updateAutoHeight();\n              });\n            }\n            elementTransitionEnd(c.wrapperEl, () => {\n              if (!controlled) return;\n              c.transitionEnd();\n            });\n          }\n        }\n        if (Array.isArray(controlled)) {\n          for (i = 0; i < controlled.length; i += 1) {\n            if (\n              controlled[i] !== byController &&\n              controlled[i] instanceof Swiper2\n            ) {\n              setControlledTransition(controlled[i]);\n            }\n          }\n        } else if (\n          controlled instanceof Swiper2 &&\n          byController !== controlled\n        ) {\n          setControlledTransition(controlled);\n        }\n      }\n      function removeSpline() {\n        if (!swiper.controller.control) return;\n        if (swiper.controller.spline) {\n          swiper.controller.spline = void 0;\n          delete swiper.controller.spline;\n        }\n      }\n      on(\"beforeInit\", () => {\n        if (\n          typeof window !== \"undefined\" && // eslint-disable-line\n          (typeof swiper.params.controller.control === \"string\" ||\n            swiper.params.controller.control instanceof HTMLElement)\n        ) {\n          const controlElement = document.querySelector(\n            swiper.params.controller.control\n          );\n          if (controlElement && controlElement.swiper) {\n            swiper.controller.control = controlElement.swiper;\n          } else if (controlElement) {\n            const onControllerSwiper = (e) => {\n              swiper.controller.control = e.detail[0];\n              swiper.update();\n              controlElement.removeEventListener(\"init\", onControllerSwiper);\n            };\n            controlElement.addEventListener(\"init\", onControllerSwiper);\n          }\n          return;\n        }\n        swiper.controller.control = swiper.params.controller.control;\n      });\n      on(\"update\", () => {\n        removeSpline();\n      });\n      on(\"resize\", () => {\n        removeSpline();\n      });\n      on(\"observerUpdate\", () => {\n        removeSpline();\n      });\n      on(\"setTranslate\", (_s, translate2, byController) => {\n        if (!swiper.controller.control) return;\n        swiper.controller.setTranslate(translate2, byController);\n      });\n      on(\"setTransition\", (_s, duration, byController) => {\n        if (!swiper.controller.control) return;\n        swiper.controller.setTransition(duration, byController);\n      });\n      Object.assign(swiper.controller, {\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n      });\n    }\n    function A11y({ swiper, extendParams, on }) {\n      extendParams({\n        a11y: {\n          enabled: true,\n          notificationClass: \"swiper-notification\",\n          prevSlideMessage: \"Previous slide\",\n          nextSlideMessage: \"Next slide\",\n          firstSlideMessage: \"This is the first slide\",\n          lastSlideMessage: \"This is the last slide\",\n          paginationBulletMessage: \"Go to slide {{index}}\",\n          slideLabelMessage: \"{{index}} / {{slidesLength}}\",\n          containerMessage: null,\n          containerRoleDescriptionMessage: null,\n          itemRoleDescriptionMessage: null,\n          slideRole: \"group\",\n          id: null,\n        },\n      });\n      swiper.a11y = {\n        clicked: false,\n      };\n      let liveRegion = null;\n      function notify(message) {\n        const notification = liveRegion;\n        if (notification.length === 0) return;\n        notification.innerHTML = \"\";\n        notification.innerHTML = message;\n      }\n      const makeElementsArray = (el) => {\n        if (!Array.isArray(el)) el = [el].filter((e) => !!e);\n        return el;\n      };\n      function getRandomNumber(size = 16) {\n        const randomChar = () => Math.round(16 * Math.random()).toString(16);\n        return \"x\".repeat(size).replace(/x/g, randomChar);\n      }\n      function makeElFocusable(el) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"tabIndex\", \"0\");\n        });\n      }\n      function makeElNotFocusable(el) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"tabIndex\", \"-1\");\n        });\n      }\n      function addElRole(el, role) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"role\", role);\n        });\n      }\n      function addElRoleDescription(el, description) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"aria-roledescription\", description);\n        });\n      }\n      function addElControls(el, controls) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"aria-controls\", controls);\n        });\n      }\n      function addElLabel(el, label) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"aria-label\", label);\n        });\n      }\n      function addElId(el, id) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"id\", id);\n        });\n      }\n      function addElLive(el, live) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"aria-live\", live);\n        });\n      }\n      function disableEl(el) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"aria-disabled\", true);\n        });\n      }\n      function enableEl(el) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"aria-disabled\", false);\n        });\n      }\n      function onEnterOrSpaceKey(e) {\n        if (e.keyCode !== 13 && e.keyCode !== 32) return;\n        const params = swiper.params.a11y;\n        const targetEl = e.target;\n        if (\n          swiper.pagination &&\n          swiper.pagination.el &&\n          (targetEl === swiper.pagination.el ||\n            swiper.pagination.el.contains(e.target))\n        ) {\n          if (\n            !e.target.matches(\n              classesToSelector(swiper.params.pagination.bulletClass)\n            )\n          )\n            return;\n        }\n        if (\n          swiper.navigation &&\n          swiper.navigation.nextEl &&\n          targetEl === swiper.navigation.nextEl\n        ) {\n          if (!(swiper.isEnd && !swiper.params.loop)) {\n            swiper.slideNext();\n          }\n          if (swiper.isEnd) {\n            notify(params.lastSlideMessage);\n          } else {\n            notify(params.nextSlideMessage);\n          }\n        }\n        if (\n          swiper.navigation &&\n          swiper.navigation.prevEl &&\n          targetEl === swiper.navigation.prevEl\n        ) {\n          if (!(swiper.isBeginning && !swiper.params.loop)) {\n            swiper.slidePrev();\n          }\n          if (swiper.isBeginning) {\n            notify(params.firstSlideMessage);\n          } else {\n            notify(params.prevSlideMessage);\n          }\n        }\n        if (\n          swiper.pagination &&\n          targetEl.matches(\n            classesToSelector(swiper.params.pagination.bulletClass)\n          )\n        ) {\n          targetEl.click();\n        }\n      }\n      function updateNavigation() {\n        if (swiper.params.loop || swiper.params.rewind || !swiper.navigation)\n          return;\n        const { nextEl, prevEl } = swiper.navigation;\n        if (prevEl) {\n          if (swiper.isBeginning) {\n            disableEl(prevEl);\n            makeElNotFocusable(prevEl);\n          } else {\n            enableEl(prevEl);\n            makeElFocusable(prevEl);\n          }\n        }\n        if (nextEl) {\n          if (swiper.isEnd) {\n            disableEl(nextEl);\n            makeElNotFocusable(nextEl);\n          } else {\n            enableEl(nextEl);\n            makeElFocusable(nextEl);\n          }\n        }\n      }\n      function hasPagination() {\n        return (\n          swiper.pagination &&\n          swiper.pagination.bullets &&\n          swiper.pagination.bullets.length\n        );\n      }\n      function hasClickablePagination() {\n        return hasPagination() && swiper.params.pagination.clickable;\n      }\n      function updatePagination() {\n        const params = swiper.params.a11y;\n        if (!hasPagination()) return;\n        swiper.pagination.bullets.forEach((bulletEl) => {\n          if (swiper.params.pagination.clickable) {\n            makeElFocusable(bulletEl);\n            if (!swiper.params.pagination.renderBullet) {\n              addElRole(bulletEl, \"button\");\n              addElLabel(\n                bulletEl,\n                params.paginationBulletMessage.replace(\n                  /\\{\\{index\\}\\}/,\n                  elementIndex(bulletEl) + 1\n                )\n              );\n            }\n          }\n          if (\n            bulletEl.matches(`.${swiper.params.pagination.bulletActiveClass}`)\n          ) {\n            bulletEl.setAttribute(\"aria-current\", \"true\");\n          } else {\n            bulletEl.removeAttribute(\"aria-current\");\n          }\n        });\n      }\n      const initNavEl = (el, wrapperId, message) => {\n        makeElFocusable(el);\n        if (el.tagName !== \"BUTTON\") {\n          addElRole(el, \"button\");\n          el.addEventListener(\"keydown\", onEnterOrSpaceKey);\n        }\n        addElLabel(el, message);\n        addElControls(el, wrapperId);\n      };\n      const handlePointerDown = () => {\n        swiper.a11y.clicked = true;\n      };\n      const handlePointerUp = () => {\n        requestAnimationFrame(() => {\n          requestAnimationFrame(() => {\n            if (!swiper.destroyed) {\n              swiper.a11y.clicked = false;\n            }\n          });\n        });\n      };\n      const handleFocus = (e) => {\n        if (swiper.a11y.clicked) return;\n        const slideEl = e.target.closest(\n          `.${swiper.params.slideClass}, swiper-slide`\n        );\n        if (!slideEl || !swiper.slides.includes(slideEl)) return;\n        const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n        const isVisible =\n          swiper.params.watchSlidesProgress &&\n          swiper.visibleSlides &&\n          swiper.visibleSlides.includes(slideEl);\n        if (isActive || isVisible) return;\n        if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents)\n          return;\n        if (swiper.isHorizontal()) {\n          swiper.el.scrollLeft = 0;\n        } else {\n          swiper.el.scrollTop = 0;\n        }\n        swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n      };\n      const initSlides = () => {\n        const params = swiper.params.a11y;\n        if (params.itemRoleDescriptionMessage) {\n          addElRoleDescription(\n            swiper.slides,\n            params.itemRoleDescriptionMessage\n          );\n        }\n        if (params.slideRole) {\n          addElRole(swiper.slides, params.slideRole);\n        }\n        const slidesLength = swiper.slides.length;\n        if (params.slideLabelMessage) {\n          swiper.slides.forEach((slideEl, index) => {\n            const slideIndex = swiper.params.loop\n              ? parseInt(slideEl.getAttribute(\"data-swiper-slide-index\"), 10)\n              : index;\n            const ariaLabelMessage = params.slideLabelMessage\n              .replace(/\\{\\{index\\}\\}/, slideIndex + 1)\n              .replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n            addElLabel(slideEl, ariaLabelMessage);\n          });\n        }\n      };\n      const init = () => {\n        const params = swiper.params.a11y;\n        swiper.el.append(liveRegion);\n        const containerEl = swiper.el;\n        if (params.containerRoleDescriptionMessage) {\n          addElRoleDescription(\n            containerEl,\n            params.containerRoleDescriptionMessage\n          );\n        }\n        if (params.containerMessage) {\n          addElLabel(containerEl, params.containerMessage);\n        }\n        const wrapperEl = swiper.wrapperEl;\n        const wrapperId =\n          params.id ||\n          wrapperEl.getAttribute(\"id\") ||\n          `swiper-wrapper-${getRandomNumber(16)}`;\n        const live =\n          swiper.params.autoplay && swiper.params.autoplay.enabled\n            ? \"off\"\n            : \"polite\";\n        addElId(wrapperEl, wrapperId);\n        addElLive(wrapperEl, live);\n        initSlides();\n        let { nextEl, prevEl } = swiper.navigation ? swiper.navigation : {};\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        if (nextEl) {\n          nextEl.forEach((el) =>\n            initNavEl(el, wrapperId, params.nextSlideMessage)\n          );\n        }\n        if (prevEl) {\n          prevEl.forEach((el) =>\n            initNavEl(el, wrapperId, params.prevSlideMessage)\n          );\n        }\n        if (hasClickablePagination()) {\n          const paginationEl = Array.isArray(swiper.pagination.el)\n            ? swiper.pagination.el\n            : [swiper.pagination.el];\n          paginationEl.forEach((el) => {\n            el.addEventListener(\"keydown\", onEnterOrSpaceKey);\n          });\n        }\n        swiper.el.addEventListener(\"focus\", handleFocus, true);\n        swiper.el.addEventListener(\"pointerdown\", handlePointerDown, true);\n        swiper.el.addEventListener(\"pointerup\", handlePointerUp, true);\n      };\n      function destroy() {\n        if (liveRegion && liveRegion.length > 0) liveRegion.remove();\n        let { nextEl, prevEl } = swiper.navigation ? swiper.navigation : {};\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        if (nextEl) {\n          nextEl.forEach((el) =>\n            el.removeEventListener(\"keydown\", onEnterOrSpaceKey)\n          );\n        }\n        if (prevEl) {\n          prevEl.forEach((el) =>\n            el.removeEventListener(\"keydown\", onEnterOrSpaceKey)\n          );\n        }\n        if (hasClickablePagination()) {\n          const paginationEl = Array.isArray(swiper.pagination.el)\n            ? swiper.pagination.el\n            : [swiper.pagination.el];\n          paginationEl.forEach((el) => {\n            el.removeEventListener(\"keydown\", onEnterOrSpaceKey);\n          });\n        }\n        swiper.el.removeEventListener(\"focus\", handleFocus, true);\n        swiper.el.removeEventListener(\"pointerdown\", handlePointerDown, true);\n        swiper.el.removeEventListener(\"pointerup\", handlePointerUp, true);\n      }\n      on(\"beforeInit\", () => {\n        liveRegion = createElement(\n          \"span\",\n          swiper.params.a11y.notificationClass\n        );\n        liveRegion.setAttribute(\"aria-live\", \"assertive\");\n        liveRegion.setAttribute(\"aria-atomic\", \"true\");\n        if (swiper.isElement) {\n          liveRegion.setAttribute(\"slot\", \"container-end\");\n        }\n      });\n      on(\"afterInit\", () => {\n        if (!swiper.params.a11y.enabled) return;\n        init();\n      });\n      on(\n        \"slidesLengthChange snapGridLengthChange slidesGridLengthChange\",\n        () => {\n          if (!swiper.params.a11y.enabled) return;\n          initSlides();\n        }\n      );\n      on(\"fromEdge toEdge afterInit lock unlock\", () => {\n        if (!swiper.params.a11y.enabled) return;\n        updateNavigation();\n      });\n      on(\"paginationUpdate\", () => {\n        if (!swiper.params.a11y.enabled) return;\n        updatePagination();\n      });\n      on(\"destroy\", () => {\n        if (!swiper.params.a11y.enabled) return;\n        destroy();\n      });\n    }\n    function History({ swiper, extendParams, on }) {\n      extendParams({\n        history: {\n          enabled: false,\n          root: \"\",\n          replaceState: false,\n          key: \"slides\",\n          keepQuery: false,\n        },\n      });\n      let initialized = false;\n      let paths = {};\n      const slugify = (text) => {\n        return text\n          .toString()\n          .replace(/\\s+/g, \"-\")\n          .replace(/[^\\w-]+/g, \"\")\n          .replace(/--+/g, \"-\")\n          .replace(/^-+/, \"\")\n          .replace(/-+$/, \"\");\n      };\n      const getPathValues = (urlOverride) => {\n        const window2 = getWindow();\n        let location;\n        if (urlOverride) {\n          location = new URL(urlOverride);\n        } else {\n          location = window2.location;\n        }\n        const pathArray = location.pathname\n          .slice(1)\n          .split(\"/\")\n          .filter((part) => part !== \"\");\n        const total = pathArray.length;\n        const key = pathArray[total - 2];\n        const value = pathArray[total - 1];\n        return {\n          key,\n          value,\n        };\n      };\n      const setHistory = (key, index) => {\n        const window2 = getWindow();\n        if (!initialized || !swiper.params.history.enabled) return;\n        let location;\n        if (swiper.params.url) {\n          location = new URL(swiper.params.url);\n        } else {\n          location = window2.location;\n        }\n        const slide2 = swiper.slides[index];\n        let value = slugify(slide2.getAttribute(\"data-history\"));\n        if (swiper.params.history.root.length > 0) {\n          let root = swiper.params.history.root;\n          if (root[root.length - 1] === \"/\")\n            root = root.slice(0, root.length - 1);\n          value = `${root}/${key ? `${key}/` : \"\"}${value}`;\n        } else if (!location.pathname.includes(key)) {\n          value = `${key ? `${key}/` : \"\"}${value}`;\n        }\n        if (swiper.params.history.keepQuery) {\n          value += location.search;\n        }\n        const currentState = window2.history.state;\n        if (currentState && currentState.value === value) {\n          return;\n        }\n        if (swiper.params.history.replaceState) {\n          window2.history.replaceState(\n            {\n              value,\n            },\n            null,\n            value\n          );\n        } else {\n          window2.history.pushState(\n            {\n              value,\n            },\n            null,\n            value\n          );\n        }\n      };\n      const scrollToSlide = (speed, value, runCallbacks) => {\n        if (value) {\n          for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n            const slide2 = swiper.slides[i];\n            const slideHistory = slugify(slide2.getAttribute(\"data-history\"));\n            if (slideHistory === value) {\n              const index = swiper.getSlideIndex(slide2);\n              swiper.slideTo(index, speed, runCallbacks);\n            }\n          }\n        } else {\n          swiper.slideTo(0, speed, runCallbacks);\n        }\n      };\n      const setHistoryPopState = () => {\n        paths = getPathValues(swiper.params.url);\n        scrollToSlide(swiper.params.speed, paths.value, false);\n      };\n      const init = () => {\n        const window2 = getWindow();\n        if (!swiper.params.history) return;\n        if (!window2.history || !window2.history.pushState) {\n          swiper.params.history.enabled = false;\n          swiper.params.hashNavigation.enabled = true;\n          return;\n        }\n        initialized = true;\n        paths = getPathValues(swiper.params.url);\n        if (!paths.key && !paths.value) {\n          if (!swiper.params.history.replaceState) {\n            window2.addEventListener(\"popstate\", setHistoryPopState);\n          }\n          return;\n        }\n        scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n        if (!swiper.params.history.replaceState) {\n          window2.addEventListener(\"popstate\", setHistoryPopState);\n        }\n      };\n      const destroy = () => {\n        const window2 = getWindow();\n        if (!swiper.params.history.replaceState) {\n          window2.removeEventListener(\"popstate\", setHistoryPopState);\n        }\n      };\n      on(\"init\", () => {\n        if (swiper.params.history.enabled) {\n          init();\n        }\n      });\n      on(\"destroy\", () => {\n        if (swiper.params.history.enabled) {\n          destroy();\n        }\n      });\n      on(\"transitionEnd _freeModeNoMomentumRelease\", () => {\n        if (initialized) {\n          setHistory(swiper.params.history.key, swiper.activeIndex);\n        }\n      });\n      on(\"slideChange\", () => {\n        if (initialized && swiper.params.cssMode) {\n          setHistory(swiper.params.history.key, swiper.activeIndex);\n        }\n      });\n    }\n    function HashNavigation({ swiper, extendParams, emit, on }) {\n      let initialized = false;\n      const document2 = getDocument();\n      const window2 = getWindow();\n      extendParams({\n        hashNavigation: {\n          enabled: false,\n          replaceState: false,\n          watchState: false,\n        },\n      });\n      const onHashChange = () => {\n        emit(\"hashChange\");\n        const newHash = document2.location.hash.replace(\"#\", \"\");\n        const activeSlideHash =\n          swiper.slides[swiper.activeIndex].getAttribute(\"data-hash\");\n        if (newHash !== activeSlideHash) {\n          const newIndex = swiper.getSlideIndex(\n            elementChildren(\n              swiper.slidesEl,\n              `.${swiper.params.slideClass}[data-hash=\"${newHash}\"], swiper-slide[data-hash=\"${newHash}\"]`\n            )[0]\n          );\n          if (typeof newIndex === \"undefined\") return;\n          swiper.slideTo(newIndex);\n        }\n      };\n      const setHash = () => {\n        if (!initialized || !swiper.params.hashNavigation.enabled) return;\n        if (\n          swiper.params.hashNavigation.replaceState &&\n          window2.history &&\n          window2.history.replaceState\n        ) {\n          window2.history.replaceState(\n            null,\n            null,\n            `#${swiper.slides[swiper.activeIndex].getAttribute(\"data-hash\")}` ||\n              \"\"\n          );\n          emit(\"hashSet\");\n        } else {\n          const slide2 = swiper.slides[swiper.activeIndex];\n          const hash =\n            slide2.getAttribute(\"data-hash\") ||\n            slide2.getAttribute(\"data-history\");\n          document2.location.hash = hash || \"\";\n          emit(\"hashSet\");\n        }\n      };\n      const init = () => {\n        if (\n          !swiper.params.hashNavigation.enabled ||\n          (swiper.params.history && swiper.params.history.enabled)\n        )\n          return;\n        initialized = true;\n        const hash = document2.location.hash.replace(\"#\", \"\");\n        if (hash) {\n          const speed = 0;\n          for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n            const slide2 = swiper.slides[i];\n            const slideHash =\n              slide2.getAttribute(\"data-hash\") ||\n              slide2.getAttribute(\"data-history\");\n            if (slideHash === hash) {\n              const index = swiper.getSlideIndex(slide2);\n              swiper.slideTo(\n                index,\n                speed,\n                swiper.params.runCallbacksOnInit,\n                true\n              );\n            }\n          }\n        }\n        if (swiper.params.hashNavigation.watchState) {\n          window2.addEventListener(\"hashchange\", onHashChange);\n        }\n      };\n      const destroy = () => {\n        if (swiper.params.hashNavigation.watchState) {\n          window2.removeEventListener(\"hashchange\", onHashChange);\n        }\n      };\n      on(\"init\", () => {\n        if (swiper.params.hashNavigation.enabled) {\n          init();\n        }\n      });\n      on(\"destroy\", () => {\n        if (swiper.params.hashNavigation.enabled) {\n          destroy();\n        }\n      });\n      on(\"transitionEnd _freeModeNoMomentumRelease\", () => {\n        if (initialized) {\n          setHash();\n        }\n      });\n      on(\"slideChange\", () => {\n        if (initialized && swiper.params.cssMode) {\n          setHash();\n        }\n      });\n    }\n    function Autoplay({ swiper, extendParams, on, emit, params }) {\n      swiper.autoplay = {\n        running: false,\n        paused: false,\n        timeLeft: 0,\n      };\n      extendParams({\n        autoplay: {\n          enabled: false,\n          delay: 3e3,\n          waitForTransition: true,\n          disableOnInteraction: true,\n          stopOnLastSlide: false,\n          reverseDirection: false,\n          pauseOnMouseEnter: false,\n        },\n      });\n      let timeout2;\n      let raf;\n      let autoplayDelayTotal =\n        params && params.autoplay ? params.autoplay.delay : 3e3;\n      let autoplayDelayCurrent =\n        params && params.autoplay ? params.autoplay.delay : 3e3;\n      let autoplayTimeLeft;\n      let autoplayStartTime = /* @__PURE__ */ new Date().getTime;\n      let wasPaused;\n      let isTouched;\n      let pausedByTouch;\n      let touchStartTimeout;\n      let slideChanged;\n      let pausedByInteraction;\n      function onTransitionEnd(e) {\n        if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n        if (e.target !== swiper.wrapperEl) return;\n        swiper.wrapperEl.removeEventListener(\"transitionend\", onTransitionEnd);\n        resume();\n      }\n      const calcTimeLeft = () => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        if (swiper.autoplay.paused) {\n          wasPaused = true;\n        } else if (wasPaused) {\n          autoplayDelayCurrent = autoplayTimeLeft;\n          wasPaused = false;\n        }\n        const timeLeft = swiper.autoplay.paused\n          ? autoplayTimeLeft\n          : autoplayStartTime +\n            autoplayDelayCurrent -\n            /* @__PURE__ */ new Date().getTime();\n        swiper.autoplay.timeLeft = timeLeft;\n        emit(\"autoplayTimeLeft\", timeLeft, timeLeft / autoplayDelayTotal);\n        raf = requestAnimationFrame(() => {\n          calcTimeLeft();\n        });\n      };\n      const getSlideDelay = () => {\n        let activeSlideEl;\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          activeSlideEl = swiper.slides.filter((slideEl) =>\n            slideEl.classList.contains(\"swiper-slide-active\")\n          )[0];\n        } else {\n          activeSlideEl = swiper.slides[swiper.activeIndex];\n        }\n        if (!activeSlideEl) return void 0;\n        const currentSlideDelay = parseInt(\n          activeSlideEl.getAttribute(\"data-swiper-autoplay\"),\n          10\n        );\n        return currentSlideDelay;\n      };\n      const run = (delayForce) => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        cancelAnimationFrame(raf);\n        calcTimeLeft();\n        let delay =\n          typeof delayForce === \"undefined\"\n            ? swiper.params.autoplay.delay\n            : delayForce;\n        autoplayDelayTotal = swiper.params.autoplay.delay;\n        autoplayDelayCurrent = swiper.params.autoplay.delay;\n        const currentSlideDelay = getSlideDelay();\n        if (\n          !Number.isNaN(currentSlideDelay) &&\n          currentSlideDelay > 0 &&\n          typeof delayForce === \"undefined\"\n        ) {\n          delay = currentSlideDelay;\n          autoplayDelayTotal = currentSlideDelay;\n          autoplayDelayCurrent = currentSlideDelay;\n        }\n        autoplayTimeLeft = delay;\n        const speed = swiper.params.speed;\n        const proceed = () => {\n          if (!swiper || swiper.destroyed) return;\n          if (swiper.params.autoplay.reverseDirection) {\n            if (\n              !swiper.isBeginning ||\n              swiper.params.loop ||\n              swiper.params.rewind\n            ) {\n              swiper.slidePrev(speed, true, true);\n              emit(\"autoplay\");\n            } else if (!swiper.params.autoplay.stopOnLastSlide) {\n              swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n              emit(\"autoplay\");\n            }\n          } else {\n            if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n              swiper.slideNext(speed, true, true);\n              emit(\"autoplay\");\n            } else if (!swiper.params.autoplay.stopOnLastSlide) {\n              swiper.slideTo(0, speed, true, true);\n              emit(\"autoplay\");\n            }\n          }\n          if (swiper.params.cssMode) {\n            autoplayStartTime = /* @__PURE__ */ new Date().getTime();\n            requestAnimationFrame(() => {\n              run();\n            });\n          }\n        };\n        if (delay > 0) {\n          clearTimeout(timeout2);\n          timeout2 = setTimeout(() => {\n            proceed();\n          }, delay);\n        } else {\n          requestAnimationFrame(() => {\n            proceed();\n          });\n        }\n        return delay;\n      };\n      const start = () => {\n        swiper.autoplay.running = true;\n        run();\n        emit(\"autoplayStart\");\n      };\n      const stop = () => {\n        swiper.autoplay.running = false;\n        clearTimeout(timeout2);\n        cancelAnimationFrame(raf);\n        emit(\"autoplayStop\");\n      };\n      const pause = (internal, reset) => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        clearTimeout(timeout2);\n        if (!internal) {\n          pausedByInteraction = true;\n        }\n        const proceed = () => {\n          emit(\"autoplayPause\");\n          if (swiper.params.autoplay.waitForTransition) {\n            swiper.wrapperEl.addEventListener(\"transitionend\", onTransitionEnd);\n          } else {\n            resume();\n          }\n        };\n        swiper.autoplay.paused = true;\n        if (reset) {\n          if (slideChanged) {\n            autoplayTimeLeft = swiper.params.autoplay.delay;\n          }\n          slideChanged = false;\n          proceed();\n          return;\n        }\n        const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n        autoplayTimeLeft =\n          delay - /* @__PURE__ */ (new Date().getTime() - autoplayStartTime);\n        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n        if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n        proceed();\n      };\n      const resume = () => {\n        if (\n          (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) ||\n          swiper.destroyed ||\n          !swiper.autoplay.running\n        )\n          return;\n        autoplayStartTime = /* @__PURE__ */ new Date().getTime();\n        if (pausedByInteraction) {\n          pausedByInteraction = false;\n          run(autoplayTimeLeft);\n        } else {\n          run();\n        }\n        swiper.autoplay.paused = false;\n        emit(\"autoplayResume\");\n      };\n      const onVisibilityChange = () => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        const document2 = getDocument();\n        if (document2.visibilityState === \"hidden\") {\n          pausedByInteraction = true;\n          pause(true);\n        }\n        if (document2.visibilityState === \"visible\") {\n          resume();\n        }\n      };\n      const onPointerEnter = (e) => {\n        if (e.pointerType !== \"mouse\") return;\n        pausedByInteraction = true;\n        pause(true);\n      };\n      const onPointerLeave = (e) => {\n        if (e.pointerType !== \"mouse\") return;\n        if (swiper.autoplay.paused) {\n          resume();\n        }\n      };\n      const attachMouseEvents = () => {\n        if (swiper.params.autoplay.pauseOnMouseEnter) {\n          swiper.el.addEventListener(\"pointerenter\", onPointerEnter);\n          swiper.el.addEventListener(\"pointerleave\", onPointerLeave);\n        }\n      };\n      const detachMouseEvents = () => {\n        swiper.el.removeEventListener(\"pointerenter\", onPointerEnter);\n        swiper.el.removeEventListener(\"pointerleave\", onPointerLeave);\n      };\n      const attachDocumentEvents = () => {\n        const document2 = getDocument();\n        document2.addEventListener(\"visibilitychange\", onVisibilityChange);\n      };\n      const detachDocumentEvents = () => {\n        const document2 = getDocument();\n        document2.removeEventListener(\"visibilitychange\", onVisibilityChange);\n      };\n      on(\"init\", () => {\n        if (swiper.params.autoplay.enabled) {\n          attachMouseEvents();\n          attachDocumentEvents();\n          autoplayStartTime = /* @__PURE__ */ new Date().getTime();\n          start();\n        }\n      });\n      on(\"destroy\", () => {\n        detachMouseEvents();\n        detachDocumentEvents();\n        if (swiper.autoplay.running) {\n          stop();\n        }\n      });\n      on(\"beforeTransitionStart\", (_s, speed, internal) => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        if (internal || !swiper.params.autoplay.disableOnInteraction) {\n          pause(true, true);\n        } else {\n          stop();\n        }\n      });\n      on(\"sliderFirstMove\", () => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        if (swiper.params.autoplay.disableOnInteraction) {\n          stop();\n          return;\n        }\n        isTouched = true;\n        pausedByTouch = false;\n        pausedByInteraction = false;\n        touchStartTimeout = setTimeout(() => {\n          pausedByInteraction = true;\n          pausedByTouch = true;\n          pause(true);\n        }, 200);\n      });\n      on(\"touchEnd\", () => {\n        if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n        clearTimeout(touchStartTimeout);\n        clearTimeout(timeout2);\n        if (swiper.params.autoplay.disableOnInteraction) {\n          pausedByTouch = false;\n          isTouched = false;\n          return;\n        }\n        if (pausedByTouch && swiper.params.cssMode) resume();\n        pausedByTouch = false;\n        isTouched = false;\n      });\n      on(\"slideChange\", () => {\n        if (swiper.destroyed || !swiper.autoplay.running) return;\n        slideChanged = true;\n      });\n      Object.assign(swiper.autoplay, {\n        start,\n        stop,\n        pause,\n        resume,\n      });\n    }\n    function Thumb({ swiper, extendParams, on }) {\n      extendParams({\n        thumbs: {\n          swiper: null,\n          multipleActiveThumbs: true,\n          autoScrollOffset: 0,\n          slideThumbActiveClass: \"swiper-slide-thumb-active\",\n          thumbsContainerClass: \"swiper-thumbs\",\n        },\n      });\n      let initialized = false;\n      let swiperCreated = false;\n      swiper.thumbs = {\n        swiper: null,\n      };\n      function onThumbClick() {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n        const clickedIndex = thumbsSwiper.clickedIndex;\n        const clickedSlide = thumbsSwiper.clickedSlide;\n        if (\n          clickedSlide &&\n          clickedSlide.classList.contains(\n            swiper.params.thumbs.slideThumbActiveClass\n          )\n        )\n          return;\n        if (typeof clickedIndex === \"undefined\" || clickedIndex === null)\n          return;\n        let slideToIndex;\n        if (thumbsSwiper.params.loop) {\n          slideToIndex = parseInt(\n            thumbsSwiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"),\n            10\n          );\n        } else {\n          slideToIndex = clickedIndex;\n        }\n        if (swiper.params.loop) {\n          swiper.slideToLoop(slideToIndex);\n        } else {\n          swiper.slideTo(slideToIndex);\n        }\n      }\n      function init() {\n        const { thumbs: thumbsParams } = swiper.params;\n        if (initialized) return false;\n        initialized = true;\n        const SwiperClass = swiper.constructor;\n        if (thumbsParams.swiper instanceof SwiperClass) {\n          swiper.thumbs.swiper = thumbsParams.swiper;\n          Object.assign(swiper.thumbs.swiper.originalParams, {\n            watchSlidesProgress: true,\n            slideToClickedSlide: false,\n          });\n          Object.assign(swiper.thumbs.swiper.params, {\n            watchSlidesProgress: true,\n            slideToClickedSlide: false,\n          });\n          swiper.thumbs.swiper.update();\n        } else if (isObject(thumbsParams.swiper)) {\n          const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n          Object.assign(thumbsSwiperParams, {\n            watchSlidesProgress: true,\n            slideToClickedSlide: false,\n          });\n          swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n          swiperCreated = true;\n        }\n        swiper.thumbs.swiper.el.classList.add(\n          swiper.params.thumbs.thumbsContainerClass\n        );\n        swiper.thumbs.swiper.on(\"tap\", onThumbClick);\n        return true;\n      }\n      function update2(initial) {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n        const slidesPerView =\n          thumbsSwiper.params.slidesPerView === \"auto\"\n            ? thumbsSwiper.slidesPerViewDynamic()\n            : thumbsSwiper.params.slidesPerView;\n        let thumbsToActivate = 1;\n        const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n        if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n          thumbsToActivate = swiper.params.slidesPerView;\n        }\n        if (!swiper.params.thumbs.multipleActiveThumbs) {\n          thumbsToActivate = 1;\n        }\n        thumbsToActivate = Math.floor(thumbsToActivate);\n        thumbsSwiper.slides.forEach((slideEl) =>\n          slideEl.classList.remove(thumbActiveClass)\n        );\n        if (\n          thumbsSwiper.params.loop ||\n          (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)\n        ) {\n          for (let i = 0; i < thumbsToActivate; i += 1) {\n            elementChildren(\n              thumbsSwiper.slidesEl,\n              `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`\n            ).forEach((slideEl) => {\n              slideEl.classList.add(thumbActiveClass);\n            });\n          }\n        } else {\n          for (let i = 0; i < thumbsToActivate; i += 1) {\n            if (thumbsSwiper.slides[swiper.realIndex + i]) {\n              thumbsSwiper.slides[swiper.realIndex + i].classList.add(\n                thumbActiveClass\n              );\n            }\n          }\n        }\n        const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n        const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n        if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n          const currentThumbsIndex = thumbsSwiper.activeIndex;\n          let newThumbsIndex;\n          let direction;\n          if (thumbsSwiper.params.loop) {\n            const newThumbsSlide = thumbsSwiper.slides.filter(\n              (slideEl) =>\n                slideEl.getAttribute(\"data-swiper-slide-index\") ===\n                `${swiper.realIndex}`\n            )[0];\n            newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n            direction =\n              swiper.activeIndex > swiper.previousIndex ? \"next\" : \"prev\";\n          } else {\n            newThumbsIndex = swiper.realIndex;\n            direction = newThumbsIndex > swiper.previousIndex ? \"next\" : \"prev\";\n          }\n          if (useOffset) {\n            newThumbsIndex +=\n              direction === \"next\" ? autoScrollOffset : -1 * autoScrollOffset;\n          }\n          if (\n            thumbsSwiper.visibleSlidesIndexes &&\n            thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0\n          ) {\n            if (thumbsSwiper.params.centeredSlides) {\n              if (newThumbsIndex > currentThumbsIndex) {\n                newThumbsIndex =\n                  newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n              } else {\n                newThumbsIndex =\n                  newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n              }\n            } else if (\n              newThumbsIndex > currentThumbsIndex &&\n              thumbsSwiper.params.slidesPerGroup === 1\n            ) {\n            }\n            thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);\n          }\n        }\n      }\n      on(\"beforeInit\", () => {\n        const { thumbs } = swiper.params;\n        if (!thumbs || !thumbs.swiper) return;\n        if (\n          typeof thumbs.swiper === \"string\" ||\n          thumbs.swiper instanceof HTMLElement\n        ) {\n          const document2 = getDocument();\n          const getThumbsElementAndInit = () => {\n            const thumbsElement =\n              typeof thumbs.swiper === \"string\"\n                ? document2.querySelector(thumbs.swiper)\n                : thumbs.swiper;\n            if (thumbsElement && thumbsElement.swiper) {\n              thumbs.swiper = thumbsElement.swiper;\n              init();\n              update2(true);\n            } else if (thumbsElement) {\n              const onThumbsSwiper = (e) => {\n                thumbs.swiper = e.detail[0];\n                thumbsElement.removeEventListener(\"init\", onThumbsSwiper);\n                init();\n                update2(true);\n                thumbs.swiper.update();\n                swiper.update();\n              };\n              thumbsElement.addEventListener(\"init\", onThumbsSwiper);\n            }\n            return thumbsElement;\n          };\n          const watchForThumbsToAppear = () => {\n            if (swiper.destroyed) return;\n            const thumbsElement = getThumbsElementAndInit();\n            if (!thumbsElement) {\n              requestAnimationFrame(watchForThumbsToAppear);\n            }\n          };\n          requestAnimationFrame(watchForThumbsToAppear);\n        } else {\n          init();\n          update2(true);\n        }\n      });\n      on(\"slideChange update resize observerUpdate\", () => {\n        update2();\n      });\n      on(\"setTransition\", (_s, duration) => {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n        thumbsSwiper.setTransition(duration);\n      });\n      on(\"beforeDestroy\", () => {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n        if (swiperCreated) {\n          thumbsSwiper.destroy();\n        }\n      });\n      Object.assign(swiper.thumbs, {\n        init,\n        update: update2,\n      });\n    }\n    function freeMode({ swiper, extendParams, emit, once }) {\n      extendParams({\n        freeMode: {\n          enabled: false,\n          momentum: true,\n          momentumRatio: 1,\n          momentumBounce: true,\n          momentumBounceRatio: 1,\n          momentumVelocityRatio: 1,\n          sticky: false,\n          minimumVelocity: 0.02,\n        },\n      });\n      function onTouchStart2() {\n        const translate2 = swiper.getTranslate();\n        swiper.setTranslate(translate2);\n        swiper.setTransition(0);\n        swiper.touchEventsData.velocities.length = 0;\n        swiper.freeMode.onTouchEnd({\n          currentPos: swiper.rtl ? swiper.translate : -swiper.translate,\n        });\n      }\n      function onTouchMove2() {\n        const { touchEventsData: data, touches } = swiper;\n        if (data.velocities.length === 0) {\n          data.velocities.push({\n            position: touches[swiper.isHorizontal() ? \"startX\" : \"startY\"],\n            time: data.touchStartTime,\n          });\n        }\n        data.velocities.push({\n          position: touches[swiper.isHorizontal() ? \"currentX\" : \"currentY\"],\n          time: now(),\n        });\n      }\n      function onTouchEnd2({ currentPos }) {\n        const {\n          params,\n          wrapperEl,\n          rtlTranslate: rtl,\n          snapGrid,\n          touchEventsData: data,\n        } = swiper;\n        const touchEndTime = now();\n        const timeDiff = touchEndTime - data.touchStartTime;\n        if (currentPos < -swiper.minTranslate()) {\n          swiper.slideTo(swiper.activeIndex);\n          return;\n        }\n        if (currentPos > -swiper.maxTranslate()) {\n          if (swiper.slides.length < snapGrid.length) {\n            swiper.slideTo(snapGrid.length - 1);\n          } else {\n            swiper.slideTo(swiper.slides.length - 1);\n          }\n          return;\n        }\n        if (params.freeMode.momentum) {\n          if (data.velocities.length > 1) {\n            const lastMoveEvent = data.velocities.pop();\n            const velocityEvent = data.velocities.pop();\n            const distance = lastMoveEvent.position - velocityEvent.position;\n            const time = lastMoveEvent.time - velocityEvent.time;\n            swiper.velocity = distance / time;\n            swiper.velocity /= 2;\n            if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n              swiper.velocity = 0;\n            }\n            if (time > 150 || now() - lastMoveEvent.time > 300) {\n              swiper.velocity = 0;\n            }\n          } else {\n            swiper.velocity = 0;\n          }\n          swiper.velocity *= params.freeMode.momentumVelocityRatio;\n          data.velocities.length = 0;\n          let momentumDuration = 1e3 * params.freeMode.momentumRatio;\n          const momentumDistance = swiper.velocity * momentumDuration;\n          let newPosition = swiper.translate + momentumDistance;\n          if (rtl) newPosition = -newPosition;\n          let doBounce = false;\n          let afterBouncePosition;\n          const bounceAmount =\n            Math.abs(swiper.velocity) *\n            20 *\n            params.freeMode.momentumBounceRatio;\n          let needsLoopFix;\n          if (newPosition < swiper.maxTranslate()) {\n            if (params.freeMode.momentumBounce) {\n              if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n                newPosition = swiper.maxTranslate() - bounceAmount;\n              }\n              afterBouncePosition = swiper.maxTranslate();\n              doBounce = true;\n              data.allowMomentumBounce = true;\n            } else {\n              newPosition = swiper.maxTranslate();\n            }\n            if (params.loop && params.centeredSlides) needsLoopFix = true;\n          } else if (newPosition > swiper.minTranslate()) {\n            if (params.freeMode.momentumBounce) {\n              if (newPosition - swiper.minTranslate() > bounceAmount) {\n                newPosition = swiper.minTranslate() + bounceAmount;\n              }\n              afterBouncePosition = swiper.minTranslate();\n              doBounce = true;\n              data.allowMomentumBounce = true;\n            } else {\n              newPosition = swiper.minTranslate();\n            }\n            if (params.loop && params.centeredSlides) needsLoopFix = true;\n          } else if (params.freeMode.sticky) {\n            let nextSlide;\n            for (let j = 0; j < snapGrid.length; j += 1) {\n              if (snapGrid[j] > -newPosition) {\n                nextSlide = j;\n                break;\n              }\n            }\n            if (\n              Math.abs(snapGrid[nextSlide] - newPosition) <\n                Math.abs(snapGrid[nextSlide - 1] - newPosition) ||\n              swiper.swipeDirection === \"next\"\n            ) {\n              newPosition = snapGrid[nextSlide];\n            } else {\n              newPosition = snapGrid[nextSlide - 1];\n            }\n            newPosition = -newPosition;\n          }\n          if (needsLoopFix) {\n            once(\"transitionEnd\", () => {\n              swiper.loopFix();\n            });\n          }\n          if (swiper.velocity !== 0) {\n            if (rtl) {\n              momentumDuration = Math.abs(\n                (-newPosition - swiper.translate) / swiper.velocity\n              );\n            } else {\n              momentumDuration = Math.abs(\n                (newPosition - swiper.translate) / swiper.velocity\n              );\n            }\n            if (params.freeMode.sticky) {\n              const moveDistance = Math.abs(\n                (rtl ? -newPosition : newPosition) - swiper.translate\n              );\n              const currentSlideSize =\n                swiper.slidesSizesGrid[swiper.activeIndex];\n              if (moveDistance < currentSlideSize) {\n                momentumDuration = params.speed;\n              } else if (moveDistance < 2 * currentSlideSize) {\n                momentumDuration = params.speed * 1.5;\n              } else {\n                momentumDuration = params.speed * 2.5;\n              }\n            }\n          } else if (params.freeMode.sticky) {\n            swiper.slideToClosest();\n            return;\n          }\n          if (params.freeMode.momentumBounce && doBounce) {\n            swiper.updateProgress(afterBouncePosition);\n            swiper.setTransition(momentumDuration);\n            swiper.setTranslate(newPosition);\n            swiper.transitionStart(true, swiper.swipeDirection);\n            swiper.animating = true;\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed || !data.allowMomentumBounce)\n                return;\n              emit(\"momentumBounce\");\n              swiper.setTransition(params.speed);\n              setTimeout(() => {\n                swiper.setTranslate(afterBouncePosition);\n                elementTransitionEnd(wrapperEl, () => {\n                  if (!swiper || swiper.destroyed) return;\n                  swiper.transitionEnd();\n                });\n              }, 0);\n            });\n          } else if (swiper.velocity) {\n            emit(\"_freeModeNoMomentumRelease\");\n            swiper.updateProgress(newPosition);\n            swiper.setTransition(momentumDuration);\n            swiper.setTranslate(newPosition);\n            swiper.transitionStart(true, swiper.swipeDirection);\n            if (!swiper.animating) {\n              swiper.animating = true;\n              elementTransitionEnd(wrapperEl, () => {\n                if (!swiper || swiper.destroyed) return;\n                swiper.transitionEnd();\n              });\n            }\n          } else {\n            swiper.updateProgress(newPosition);\n          }\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n        } else if (params.freeMode.sticky) {\n          swiper.slideToClosest();\n          return;\n        } else if (params.freeMode) {\n          emit(\"_freeModeNoMomentumRelease\");\n        }\n        if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n          swiper.updateProgress();\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n        }\n      }\n      Object.assign(swiper, {\n        freeMode: {\n          onTouchStart: onTouchStart2,\n          onTouchMove: onTouchMove2,\n          onTouchEnd: onTouchEnd2,\n        },\n      });\n    }\n    function Grid({ swiper, extendParams }) {\n      extendParams({\n        grid: {\n          rows: 1,\n          fill: \"column\",\n        },\n      });\n      let slidesNumberEvenToRows;\n      let slidesPerRow;\n      let numFullColumns;\n      const initSlides = (slidesLength) => {\n        const { slidesPerView } = swiper.params;\n        const { rows, fill } = swiper.params.grid;\n        slidesPerRow = slidesNumberEvenToRows / rows;\n        numFullColumns = Math.floor(slidesLength / rows);\n        if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n          slidesNumberEvenToRows = slidesLength;\n        } else {\n          slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n        }\n        if (slidesPerView !== \"auto\" && fill === \"row\") {\n          slidesNumberEvenToRows = Math.max(\n            slidesNumberEvenToRows,\n            slidesPerView * rows\n          );\n        }\n      };\n      const updateSlide = (i, slide2, slidesLength, getDirectionLabel) => {\n        const { slidesPerGroup, spaceBetween } = swiper.params;\n        const { rows, fill } = swiper.params.grid;\n        let newSlideOrderIndex;\n        let column;\n        let row;\n        if (fill === \"row\" && slidesPerGroup > 1) {\n          const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n          const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n          const columnsInGroup =\n            groupIndex === 0\n              ? slidesPerGroup\n              : Math.min(\n                  Math.ceil(\n                    (slidesLength - groupIndex * rows * slidesPerGroup) / rows\n                  ),\n                  slidesPerGroup\n                );\n          row = Math.floor(slideIndexInGroup / columnsInGroup);\n          column =\n            slideIndexInGroup -\n            row * columnsInGroup +\n            groupIndex * slidesPerGroup;\n          newSlideOrderIndex = column + (row * slidesNumberEvenToRows) / rows;\n          slide2.style.order = newSlideOrderIndex;\n        } else if (fill === \"column\") {\n          column = Math.floor(i / rows);\n          row = i - column * rows;\n          if (\n            column > numFullColumns ||\n            (column === numFullColumns && row === rows - 1)\n          ) {\n            row += 1;\n            if (row >= rows) {\n              row = 0;\n              column += 1;\n            }\n          }\n        } else {\n          row = Math.floor(i / slidesPerRow);\n          column = i - row * slidesPerRow;\n        }\n        slide2.style[getDirectionLabel(\"margin-top\")] =\n          row !== 0 ? spaceBetween && `${spaceBetween}px` : \"\";\n      };\n      const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n        const { spaceBetween, centeredSlides, roundLengths } = swiper.params;\n        const { rows } = swiper.params.grid;\n        swiper.virtualSize =\n          (slideSize + spaceBetween) * slidesNumberEvenToRows;\n        swiper.virtualSize =\n          Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n        swiper.wrapperEl.style[getDirectionLabel(\"width\")] = `${\n          swiper.virtualSize + spaceBetween\n        }px`;\n        if (centeredSlides) {\n          const newSlidesGrid = [];\n          for (let i = 0; i < snapGrid.length; i += 1) {\n            let slidesGridItem = snapGrid[i];\n            if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n            if (snapGrid[i] < swiper.virtualSize + snapGrid[0])\n              newSlidesGrid.push(slidesGridItem);\n          }\n          snapGrid.splice(0, snapGrid.length);\n          snapGrid.push(...newSlidesGrid);\n        }\n      };\n      swiper.grid = {\n        initSlides,\n        updateSlide,\n        updateWrapperSize,\n      };\n    }\n    function appendSlide(slides) {\n      const swiper = this;\n      const { params, slidesEl } = swiper;\n      if (params.loop) {\n        swiper.loopDestroy();\n      }\n      const appendElement = (slideEl) => {\n        if (typeof slideEl === \"string\") {\n          const tempDOM = document.createElement(\"div\");\n          tempDOM.innerHTML = slideEl;\n          slidesEl.append(tempDOM.children[0]);\n          tempDOM.innerHTML = \"\";\n        } else {\n          slidesEl.append(slideEl);\n        }\n      };\n      if (typeof slides === \"object\" && \"length\" in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) appendElement(slides[i]);\n        }\n      } else {\n        appendElement(slides);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n    }\n    function prependSlide(slides) {\n      const swiper = this;\n      const { params, activeIndex, slidesEl } = swiper;\n      if (params.loop) {\n        swiper.loopDestroy();\n      }\n      let newActiveIndex = activeIndex + 1;\n      const prependElement = (slideEl) => {\n        if (typeof slideEl === \"string\") {\n          const tempDOM = document.createElement(\"div\");\n          tempDOM.innerHTML = slideEl;\n          slidesEl.prepend(tempDOM.children[0]);\n          tempDOM.innerHTML = \"\";\n        } else {\n          slidesEl.prepend(slideEl);\n        }\n      };\n      if (typeof slides === \"object\" && \"length\" in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) prependElement(slides[i]);\n        }\n        newActiveIndex = activeIndex + slides.length;\n      } else {\n        prependElement(slides);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n      swiper.slideTo(newActiveIndex, 0, false);\n    }\n    function addSlide(index, slides) {\n      const swiper = this;\n      const { params, activeIndex, slidesEl } = swiper;\n      let activeIndexBuffer = activeIndex;\n      if (params.loop) {\n        activeIndexBuffer -= swiper.loopedSlides;\n        swiper.loopDestroy();\n        swiper.recalcSlides();\n      }\n      const baseLength = swiper.slides.length;\n      if (index <= 0) {\n        swiper.prependSlide(slides);\n        return;\n      }\n      if (index >= baseLength) {\n        swiper.appendSlide(slides);\n        return;\n      }\n      let newActiveIndex =\n        activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n      const slidesBuffer = [];\n      for (let i = baseLength - 1; i >= index; i -= 1) {\n        const currentSlide = swiper.slides[i];\n        currentSlide.remove();\n        slidesBuffer.unshift(currentSlide);\n      }\n      if (typeof slides === \"object\" && \"length\" in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) slidesEl.append(slides[i]);\n        }\n        newActiveIndex =\n          activeIndexBuffer > index\n            ? activeIndexBuffer + slides.length\n            : activeIndexBuffer;\n      } else {\n        slidesEl.append(slides);\n      }\n      for (let i = 0; i < slidesBuffer.length; i += 1) {\n        slidesEl.append(slidesBuffer[i]);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n      if (params.loop) {\n        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n      } else {\n        swiper.slideTo(newActiveIndex, 0, false);\n      }\n    }\n    function removeSlide(slidesIndexes) {\n      const swiper = this;\n      const { params, activeIndex } = swiper;\n      let activeIndexBuffer = activeIndex;\n      if (params.loop) {\n        activeIndexBuffer -= swiper.loopedSlides;\n        swiper.loopDestroy();\n      }\n      let newActiveIndex = activeIndexBuffer;\n      let indexToRemove;\n      if (typeof slidesIndexes === \"object\" && \"length\" in slidesIndexes) {\n        for (let i = 0; i < slidesIndexes.length; i += 1) {\n          indexToRemove = slidesIndexes[i];\n          if (swiper.slides[indexToRemove])\n            swiper.slides[indexToRemove].remove();\n          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n        }\n        newActiveIndex = Math.max(newActiveIndex, 0);\n      } else {\n        indexToRemove = slidesIndexes;\n        if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n        newActiveIndex = Math.max(newActiveIndex, 0);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n      if (params.loop) {\n        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n      } else {\n        swiper.slideTo(newActiveIndex, 0, false);\n      }\n    }\n    function removeAllSlides() {\n      const swiper = this;\n      const slidesIndexes = [];\n      for (let i = 0; i < swiper.slides.length; i += 1) {\n        slidesIndexes.push(i);\n      }\n      swiper.removeSlide(slidesIndexes);\n    }\n    function Manipulation({ swiper }) {\n      Object.assign(swiper, {\n        appendSlide: appendSlide.bind(swiper),\n        prependSlide: prependSlide.bind(swiper),\n        addSlide: addSlide.bind(swiper),\n        removeSlide: removeSlide.bind(swiper),\n        removeAllSlides: removeAllSlides.bind(swiper),\n      });\n    }\n    function effectInit(params) {\n      const {\n        effect,\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        overwriteParams,\n        perspective,\n        recreateShadows,\n        getEffectParams,\n      } = params;\n      on(\"beforeInit\", () => {\n        if (swiper.params.effect !== effect) return;\n        swiper.classNames.push(\n          `${swiper.params.containerModifierClass}${effect}`\n        );\n        if (perspective && perspective()) {\n          swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n        }\n        const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n        Object.assign(swiper.params, overwriteParamsResult);\n        Object.assign(swiper.originalParams, overwriteParamsResult);\n      });\n      on(\"setTranslate\", () => {\n        if (swiper.params.effect !== effect) return;\n        setTranslate2();\n      });\n      on(\"setTransition\", (_s, duration) => {\n        if (swiper.params.effect !== effect) return;\n        setTransition2(duration);\n      });\n      on(\"transitionEnd\", () => {\n        if (swiper.params.effect !== effect) return;\n        if (recreateShadows) {\n          if (!getEffectParams || !getEffectParams().slideShadows) return;\n          swiper.slides.forEach((slideEl) => {\n            slideEl\n              .querySelectorAll(\n                \".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\"\n              )\n              .forEach((shadowEl) => shadowEl.remove());\n          });\n          recreateShadows();\n        }\n      });\n      let requireUpdateOnVirtual;\n      on(\"virtualUpdate\", () => {\n        if (swiper.params.effect !== effect) return;\n        if (!swiper.slides.length) {\n          requireUpdateOnVirtual = true;\n        }\n        requestAnimationFrame(() => {\n          if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n            setTranslate2();\n            requireUpdateOnVirtual = false;\n          }\n        });\n      });\n    }\n    function effectTarget(effectParams, slideEl) {\n      const transformEl = getSlideTransformEl(slideEl);\n      if (transformEl !== slideEl) {\n        transformEl.style.backfaceVisibility = \"hidden\";\n        transformEl.style[\"-webkit-backface-visibility\"] = \"hidden\";\n      }\n      return transformEl;\n    }\n    function effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements,\n      allSlides,\n    }) {\n      const { activeIndex } = swiper;\n      const getSlide = (el) => {\n        if (!el.parentElement) {\n          const slide2 = swiper.slides.filter(\n            (slideEl) => slideEl.shadowEl && slideEl.shadowEl === el.parentNode\n          )[0];\n          return slide2;\n        }\n        return el.parentElement;\n      };\n      if (swiper.params.virtualTranslate && duration !== 0) {\n        let eventTriggered = false;\n        let transitionEndTarget;\n        if (allSlides) {\n          transitionEndTarget = transformElements;\n        } else {\n          transitionEndTarget = transformElements.filter((transformEl) => {\n            const el = transformEl.classList.contains(\"swiper-slide-transform\")\n              ? getSlide(transformEl)\n              : transformEl;\n            return swiper.getSlideIndex(el) === activeIndex;\n          });\n        }\n        transitionEndTarget.forEach((el) => {\n          elementTransitionEnd(el, () => {\n            if (eventTriggered) return;\n            if (!swiper || swiper.destroyed) return;\n            eventTriggered = true;\n            swiper.animating = false;\n            const evt = new window.CustomEvent(\"transitionend\", {\n              bubbles: true,\n              cancelable: true,\n            });\n            swiper.wrapperEl.dispatchEvent(evt);\n          });\n        });\n      }\n    }\n    function EffectFade({ swiper, extendParams, on }) {\n      extendParams({\n        fadeEffect: {\n          crossFade: false,\n        },\n      });\n      const setTranslate2 = () => {\n        const { slides } = swiper;\n        const params = swiper.params.fadeEffect;\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = swiper.slides[i];\n          const offset = slideEl.swiperSlideOffset;\n          let tx = -offset;\n          if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n          let ty = 0;\n          if (!swiper.isHorizontal()) {\n            ty = tx;\n            tx = 0;\n          }\n          const slideOpacity = swiper.params.fadeEffect.crossFade\n            ? Math.max(1 - Math.abs(slideEl.progress), 0)\n            : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.opacity = slideOpacity;\n          targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n        }\n      };\n      const setTransition2 = (duration) => {\n        const transformElements = swiper.slides.map((slideEl) =>\n          getSlideTransformEl(slideEl)\n        );\n        transformElements.forEach((el) => {\n          el.style.transitionDuration = `${duration}ms`;\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements,\n          allSlides: true,\n        });\n      };\n      effectInit({\n        effect: \"fade\",\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        overwriteParams: () => ({\n          slidesPerView: 1,\n          slidesPerGroup: 1,\n          watchSlidesProgress: true,\n          spaceBetween: 0,\n          virtualTranslate: !swiper.params.cssMode,\n        }),\n      });\n    }\n    function EffectCube({ swiper, extendParams, on }) {\n      extendParams({\n        cubeEffect: {\n          slideShadows: true,\n          shadow: true,\n          shadowOffset: 20,\n          shadowScale: 0.94,\n        },\n      });\n      const createSlideShadows = (slideEl, progress, isHorizontal) => {\n        let shadowBefore = isHorizontal\n          ? slideEl.querySelector(\".swiper-slide-shadow-left\")\n          : slideEl.querySelector(\".swiper-slide-shadow-top\");\n        let shadowAfter = isHorizontal\n          ? slideEl.querySelector(\".swiper-slide-shadow-right\")\n          : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n        if (!shadowBefore) {\n          shadowBefore = createElement(\n            \"div\",\n            `swiper-slide-shadow-${isHorizontal ? \"left\" : \"top\"}`\n          );\n          slideEl.append(shadowBefore);\n        }\n        if (!shadowAfter) {\n          shadowAfter = createElement(\n            \"div\",\n            `swiper-slide-shadow-${isHorizontal ? \"right\" : \"bottom\"}`\n          );\n          slideEl.append(shadowAfter);\n        }\n        if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n        if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n      };\n      const recreateShadows = () => {\n        const isHorizontal = swiper.isHorizontal();\n        swiper.slides.forEach((slideEl) => {\n          const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          createSlideShadows(slideEl, progress, isHorizontal);\n        });\n      };\n      const setTranslate2 = () => {\n        const {\n          el,\n          wrapperEl,\n          slides,\n          width: swiperWidth,\n          height: swiperHeight,\n          rtlTranslate: rtl,\n          size: swiperSize,\n          browser: browser2,\n        } = swiper;\n        const params = swiper.params.cubeEffect;\n        const isHorizontal = swiper.isHorizontal();\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        let wrapperRotate = 0;\n        let cubeShadowEl;\n        if (params.shadow) {\n          if (isHorizontal) {\n            cubeShadowEl = swiper.slidesEl.querySelector(\".swiper-cube-shadow\");\n            if (!cubeShadowEl) {\n              cubeShadowEl = createElement(\"div\", \"swiper-cube-shadow\");\n              swiper.slidesEl.append(cubeShadowEl);\n            }\n            cubeShadowEl.style.height = `${swiperWidth}px`;\n          } else {\n            cubeShadowEl = el.querySelector(\".swiper-cube-shadow\");\n            if (!cubeShadowEl) {\n              cubeShadowEl = createElement(\"div\", \"swiper-cube-shadow\");\n              el.append(cubeShadowEl);\n            }\n          }\n        }\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          let slideIndex = i;\n          if (isVirtual) {\n            slideIndex = parseInt(\n              slideEl.getAttribute(\"data-swiper-slide-index\"),\n              10\n            );\n          }\n          let slideAngle = slideIndex * 90;\n          let round = Math.floor(slideAngle / 360);\n          if (rtl) {\n            slideAngle = -slideAngle;\n            round = Math.floor(-slideAngle / 360);\n          }\n          const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          let tx = 0;\n          let ty = 0;\n          let tz = 0;\n          if (slideIndex % 4 === 0) {\n            tx = -round * 4 * swiperSize;\n            tz = 0;\n          } else if ((slideIndex - 1) % 4 === 0) {\n            tx = 0;\n            tz = -round * 4 * swiperSize;\n          } else if ((slideIndex - 2) % 4 === 0) {\n            tx = swiperSize + round * 4 * swiperSize;\n            tz = swiperSize;\n          } else if ((slideIndex - 3) % 4 === 0) {\n            tx = -swiperSize;\n            tz = 3 * swiperSize + swiperSize * 4 * round;\n          }\n          if (rtl) {\n            tx = -tx;\n          }\n          if (!isHorizontal) {\n            ty = tx;\n            tx = 0;\n          }\n          const transform = `rotateX(${\n            isHorizontal ? 0 : -slideAngle\n          }deg) rotateY(${\n            isHorizontal ? slideAngle : 0\n          }deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n          if (progress <= 1 && progress > -1) {\n            wrapperRotate = slideIndex * 90 + progress * 90;\n            if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n          }\n          slideEl.style.transform = transform;\n          if (params.slideShadows) {\n            createSlideShadows(slideEl, progress, isHorizontal);\n          }\n        }\n        wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n        wrapperEl.style[\"-webkit-transform-origin\"] = `50% 50% -${\n          swiperSize / 2\n        }px`;\n        if (params.shadow) {\n          if (isHorizontal) {\n            cubeShadowEl.style.transform = `translate3d(0px, ${\n              swiperWidth / 2 + params.shadowOffset\n            }px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${\n              params.shadowScale\n            })`;\n          } else {\n            const shadowAngle =\n              Math.abs(wrapperRotate) -\n              Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n            const multiplier =\n              1.5 -\n              (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2 +\n                Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2);\n            const scale1 = params.shadowScale;\n            const scale2 = params.shadowScale / multiplier;\n            const offset = params.shadowOffset;\n            cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${\n              swiperHeight / 2 + offset\n            }px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n          }\n        }\n        const zFactor =\n          (browser2.isSafari || browser2.isWebView) &&\n          browser2.needPerspectiveFix\n            ? -swiperSize / 2\n            : 0;\n        wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${\n          swiper.isHorizontal() ? 0 : wrapperRotate\n        }deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n        wrapperEl.style.setProperty(\n          \"--swiper-cube-translate-z\",\n          `${zFactor}px`\n        );\n      };\n      const setTransition2 = (duration) => {\n        const { el, slides } = swiper;\n        slides.forEach((slideEl) => {\n          slideEl.style.transitionDuration = `${duration}ms`;\n          slideEl\n            .querySelectorAll(\n              \".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\"\n            )\n            .forEach((subEl) => {\n              subEl.style.transitionDuration = `${duration}ms`;\n            });\n        });\n        if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n          const shadowEl = el.querySelector(\".swiper-cube-shadow\");\n          if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n        }\n      };\n      effectInit({\n        effect: \"cube\",\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        recreateShadows,\n        getEffectParams: () => swiper.params.cubeEffect,\n        perspective: () => true,\n        overwriteParams: () => ({\n          slidesPerView: 1,\n          slidesPerGroup: 1,\n          watchSlidesProgress: true,\n          resistanceRatio: 0,\n          spaceBetween: 0,\n          centeredSlides: false,\n          virtualTranslate: true,\n        }),\n      });\n    }\n    function createShadow(params, slideEl, side) {\n      const shadowClass = `swiper-slide-shadow${side ? `-${side}` : \"\"}`;\n      const shadowContainer = getSlideTransformEl(slideEl);\n      let shadowEl = shadowContainer.querySelector(`.${shadowClass}`);\n      if (!shadowEl) {\n        shadowEl = createElement(\n          \"div\",\n          `swiper-slide-shadow${side ? `-${side}` : \"\"}`\n        );\n        shadowContainer.append(shadowEl);\n      }\n      return shadowEl;\n    }\n    function EffectFlip({ swiper, extendParams, on }) {\n      extendParams({\n        flipEffect: {\n          slideShadows: true,\n          limitRotation: true,\n        },\n      });\n      const createSlideShadows = (slideEl, progress, params) => {\n        let shadowBefore = swiper.isHorizontal()\n          ? slideEl.querySelector(\".swiper-slide-shadow-left\")\n          : slideEl.querySelector(\".swiper-slide-shadow-top\");\n        let shadowAfter = swiper.isHorizontal()\n          ? slideEl.querySelector(\".swiper-slide-shadow-right\")\n          : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n        if (!shadowBefore) {\n          shadowBefore = createShadow(\n            params,\n            slideEl,\n            swiper.isHorizontal() ? \"left\" : \"top\"\n          );\n        }\n        if (!shadowAfter) {\n          shadowAfter = createShadow(\n            params,\n            slideEl,\n            swiper.isHorizontal() ? \"right\" : \"bottom\"\n          );\n        }\n        if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n        if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n      };\n      const recreateShadows = () => {\n        const params = swiper.params.flipEffect;\n        swiper.slides.forEach((slideEl) => {\n          let progress = slideEl.progress;\n          if (swiper.params.flipEffect.limitRotation) {\n            progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          }\n          createSlideShadows(slideEl, progress, params);\n        });\n      };\n      const setTranslate2 = () => {\n        const { slides, rtlTranslate: rtl } = swiper;\n        const params = swiper.params.flipEffect;\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          let progress = slideEl.progress;\n          if (swiper.params.flipEffect.limitRotation) {\n            progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          }\n          const offset = slideEl.swiperSlideOffset;\n          const rotate = -180 * progress;\n          let rotateY = rotate;\n          let rotateX = 0;\n          let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n          let ty = 0;\n          if (!swiper.isHorizontal()) {\n            ty = tx;\n            tx = 0;\n            rotateX = -rotateY;\n            rotateY = 0;\n          } else if (rtl) {\n            rotateY = -rotateY;\n          }\n          slideEl.style.zIndex =\n            -Math.abs(Math.round(progress)) + slides.length;\n          if (params.slideShadows) {\n            createSlideShadows(slideEl, progress, params);\n          }\n          const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = transform;\n        }\n      };\n      const setTransition2 = (duration) => {\n        const transformElements = swiper.slides.map((slideEl) =>\n          getSlideTransformEl(slideEl)\n        );\n        transformElements.forEach((el) => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll(\n            \".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\"\n          ).forEach((shadowEl) => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements,\n        });\n      };\n      effectInit({\n        effect: \"flip\",\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        recreateShadows,\n        getEffectParams: () => swiper.params.flipEffect,\n        perspective: () => true,\n        overwriteParams: () => ({\n          slidesPerView: 1,\n          slidesPerGroup: 1,\n          watchSlidesProgress: true,\n          spaceBetween: 0,\n          virtualTranslate: !swiper.params.cssMode,\n        }),\n      });\n    }\n    function EffectCoverflow({ swiper, extendParams, on }) {\n      extendParams({\n        coverflowEffect: {\n          rotate: 50,\n          stretch: 0,\n          depth: 100,\n          scale: 1,\n          modifier: 1,\n          slideShadows: true,\n        },\n      });\n      const setTranslate2 = () => {\n        const {\n          width: swiperWidth,\n          height: swiperHeight,\n          slides,\n          slidesSizesGrid,\n        } = swiper;\n        const params = swiper.params.coverflowEffect;\n        const isHorizontal = swiper.isHorizontal();\n        const transform = swiper.translate;\n        const center = isHorizontal\n          ? -transform + swiperWidth / 2\n          : -transform + swiperHeight / 2;\n        const rotate = isHorizontal ? params.rotate : -params.rotate;\n        const translate2 = params.depth;\n        for (let i = 0, length = slides.length; i < length; i += 1) {\n          const slideEl = slides[i];\n          const slideSize = slidesSizesGrid[i];\n          const slideOffset = slideEl.swiperSlideOffset;\n          const centerOffset =\n            (center - slideOffset - slideSize / 2) / slideSize;\n          const offsetMultiplier =\n            typeof params.modifier === \"function\"\n              ? params.modifier(centerOffset)\n              : centerOffset * params.modifier;\n          let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n          let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n          let translateZ = -translate2 * Math.abs(offsetMultiplier);\n          let stretch = params.stretch;\n          if (typeof stretch === \"string\" && stretch.indexOf(\"%\") !== -1) {\n            stretch = (parseFloat(params.stretch) / 100) * slideSize;\n          }\n          let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n          let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n          let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n          if (Math.abs(translateX) < 1e-3) translateX = 0;\n          if (Math.abs(translateY) < 1e-3) translateY = 0;\n          if (Math.abs(translateZ) < 1e-3) translateZ = 0;\n          if (Math.abs(rotateY) < 1e-3) rotateY = 0;\n          if (Math.abs(rotateX) < 1e-3) rotateX = 0;\n          if (Math.abs(scale) < 1e-3) scale = 0;\n          const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = slideTransform;\n          slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n          if (params.slideShadows) {\n            let shadowBeforeEl = isHorizontal\n              ? slideEl.querySelector(\".swiper-slide-shadow-left\")\n              : slideEl.querySelector(\".swiper-slide-shadow-top\");\n            let shadowAfterEl = isHorizontal\n              ? slideEl.querySelector(\".swiper-slide-shadow-right\")\n              : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n            if (!shadowBeforeEl) {\n              shadowBeforeEl = createShadow(\n                params,\n                slideEl,\n                isHorizontal ? \"left\" : \"top\"\n              );\n            }\n            if (!shadowAfterEl) {\n              shadowAfterEl = createShadow(\n                params,\n                slideEl,\n                isHorizontal ? \"right\" : \"bottom\"\n              );\n            }\n            if (shadowBeforeEl)\n              shadowBeforeEl.style.opacity =\n                offsetMultiplier > 0 ? offsetMultiplier : 0;\n            if (shadowAfterEl)\n              shadowAfterEl.style.opacity =\n                -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n          }\n        }\n      };\n      const setTransition2 = (duration) => {\n        const transformElements = swiper.slides.map((slideEl) =>\n          getSlideTransformEl(slideEl)\n        );\n        transformElements.forEach((el) => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll(\n            \".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\"\n          ).forEach((shadowEl) => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n      };\n      effectInit({\n        effect: \"coverflow\",\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        perspective: () => true,\n        overwriteParams: () => ({\n          watchSlidesProgress: true,\n        }),\n      });\n    }\n    function EffectCreative({ swiper, extendParams, on }) {\n      extendParams({\n        creativeEffect: {\n          limitProgress: 1,\n          shadowPerProgress: false,\n          progressMultiplier: 1,\n          perspective: true,\n          prev: {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            opacity: 1,\n            scale: 1,\n          },\n          next: {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            opacity: 1,\n            scale: 1,\n          },\n        },\n      });\n      const getTranslateValue = (value) => {\n        if (typeof value === \"string\") return value;\n        return `${value}px`;\n      };\n      const setTranslate2 = () => {\n        const { slides, wrapperEl, slidesSizesGrid } = swiper;\n        const params = swiper.params.creativeEffect;\n        const { progressMultiplier: multiplier } = params;\n        const isCenteredSlides = swiper.params.centeredSlides;\n        if (isCenteredSlides) {\n          const margin =\n            slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n          wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n        }\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          const slideProgress = slideEl.progress;\n          const progress = Math.min(\n            Math.max(slideEl.progress, -params.limitProgress),\n            params.limitProgress\n          );\n          let originalProgress = progress;\n          if (!isCenteredSlides) {\n            originalProgress = Math.min(\n              Math.max(slideEl.originalProgress, -params.limitProgress),\n              params.limitProgress\n            );\n          }\n          const offset = slideEl.swiperSlideOffset;\n          const t = [\n            swiper.params.cssMode ? -offset - swiper.translate : -offset,\n            0,\n            0,\n          ];\n          const r = [0, 0, 0];\n          let custom = false;\n          if (!swiper.isHorizontal()) {\n            t[1] = t[0];\n            t[0] = 0;\n          }\n          let data = {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            scale: 1,\n            opacity: 1,\n          };\n          if (progress < 0) {\n            data = params.next;\n            custom = true;\n          } else if (progress > 0) {\n            data = params.prev;\n            custom = true;\n          }\n          t.forEach((value, index) => {\n            t[index] = `calc(${value}px + (${getTranslateValue(\n              data.translate[index]\n            )} * ${Math.abs(progress * multiplier)}))`;\n          });\n          r.forEach((value, index) => {\n            r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n          });\n          slideEl.style.zIndex =\n            -Math.abs(Math.round(slideProgress)) + slides.length;\n          const translateString = t.join(\", \");\n          const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n          const scaleString =\n            originalProgress < 0\n              ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})`\n              : `scale(${\n                  1 - (1 - data.scale) * originalProgress * multiplier\n                })`;\n          const opacityString =\n            originalProgress < 0\n              ? 1 + (1 - data.opacity) * originalProgress * multiplier\n              : 1 - (1 - data.opacity) * originalProgress * multiplier;\n          const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n          if ((custom && data.shadow) || !custom) {\n            let shadowEl = slideEl.querySelector(\".swiper-slide-shadow\");\n            if (!shadowEl && data.shadow) {\n              shadowEl = createShadow(params, slideEl);\n            }\n            if (shadowEl) {\n              const shadowOpacity = params.shadowPerProgress\n                ? progress * (1 / params.limitProgress)\n                : progress;\n              shadowEl.style.opacity = Math.min(\n                Math.max(Math.abs(shadowOpacity), 0),\n                1\n              );\n            }\n          }\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = transform;\n          targetEl.style.opacity = opacityString;\n          if (data.origin) {\n            targetEl.style.transformOrigin = data.origin;\n          }\n        }\n      };\n      const setTransition2 = (duration) => {\n        const transformElements = swiper.slides.map((slideEl) =>\n          getSlideTransformEl(slideEl)\n        );\n        transformElements.forEach((el) => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll(\".swiper-slide-shadow\").forEach((shadowEl) => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements,\n          allSlides: true,\n        });\n      };\n      effectInit({\n        effect: \"creative\",\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        perspective: () => swiper.params.creativeEffect.perspective,\n        overwriteParams: () => ({\n          watchSlidesProgress: true,\n          virtualTranslate: !swiper.params.cssMode,\n        }),\n      });\n    }\n    function EffectCards({ swiper, extendParams, on }) {\n      extendParams({\n        cardsEffect: {\n          slideShadows: true,\n          rotate: true,\n          perSlideRotate: 2,\n          perSlideOffset: 8,\n        },\n      });\n      const setTranslate2 = () => {\n        const { slides, activeIndex } = swiper;\n        const params = swiper.params.cardsEffect;\n        const { startTranslate, isTouched } = swiper.touchEventsData;\n        const currentTranslate = swiper.translate;\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          const slideProgress = slideEl.progress;\n          const progress = Math.min(Math.max(slideProgress, -4), 4);\n          let offset = slideEl.swiperSlideOffset;\n          if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n            swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n          }\n          if (swiper.params.centeredSlides && swiper.params.cssMode) {\n            offset -= slides[0].swiperSlideOffset;\n          }\n          let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n          let tY = 0;\n          const tZ = -100 * Math.abs(progress);\n          let scale = 1;\n          let rotate = -params.perSlideRotate * progress;\n          let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n          const slideIndex =\n            swiper.virtual && swiper.params.virtual.enabled\n              ? swiper.virtual.from + i\n              : i;\n          const isSwipeToNext =\n            (slideIndex === activeIndex || slideIndex === activeIndex - 1) &&\n            progress > 0 &&\n            progress < 1 &&\n            (isTouched || swiper.params.cssMode) &&\n            currentTranslate < startTranslate;\n          const isSwipeToPrev =\n            (slideIndex === activeIndex || slideIndex === activeIndex + 1) &&\n            progress < 0 &&\n            progress > -1 &&\n            (isTouched || swiper.params.cssMode) &&\n            currentTranslate > startTranslate;\n          if (isSwipeToNext || isSwipeToPrev) {\n            const subProgress =\n              (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n            rotate += -28 * progress * subProgress;\n            scale += -0.5 * subProgress;\n            tXAdd += 96 * subProgress;\n            tY = `${-25 * subProgress * Math.abs(progress)}%`;\n          }\n          if (progress < 0) {\n            tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;\n          } else if (progress > 0) {\n            tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;\n          } else {\n            tX = `${tX}px`;\n          }\n          if (!swiper.isHorizontal()) {\n            const prevY = tY;\n            tY = tX;\n            tX = prevY;\n          }\n          const scaleString =\n            progress < 0\n              ? `${1 + (1 - scale) * progress}`\n              : `${1 - (1 - scale) * progress}`;\n          const transform = `\n          translate3d(${tX}, ${tY}, ${tZ}px)\n          rotateZ(${params.rotate ? rotate : 0}deg)\n          scale(${scaleString})\n        `;\n          if (params.slideShadows) {\n            let shadowEl = slideEl.querySelector(\".swiper-slide-shadow\");\n            if (!shadowEl) {\n              shadowEl = createShadow(params, slideEl);\n            }\n            if (shadowEl)\n              shadowEl.style.opacity = Math.min(\n                Math.max((Math.abs(progress) - 0.5) / 0.5, 0),\n                1\n              );\n          }\n          slideEl.style.zIndex =\n            -Math.abs(Math.round(slideProgress)) + slides.length;\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = transform;\n        }\n      };\n      const setTransition2 = (duration) => {\n        const transformElements = swiper.slides.map((slideEl) =>\n          getSlideTransformEl(slideEl)\n        );\n        transformElements.forEach((el) => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll(\".swiper-slide-shadow\").forEach((shadowEl) => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements,\n        });\n      };\n      effectInit({\n        effect: \"cards\",\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        perspective: () => true,\n        overwriteParams: () => ({\n          watchSlidesProgress: true,\n          virtualTranslate: !swiper.params.cssMode,\n        }),\n      });\n    }\n    window.addEventListener(\"DOMContentLoaded\", () => {\n      const vacanyTitle = () => {\n        const vacancyTitleEl = document.querySelector(\n          \".tmpl_hh_content p:first-of-type\"\n        );\n        if (vacancyTitleEl) {\n          vacancyTitleEl.classList.add(\"tmpl_hh_content_vacancy-title\");\n        }\n      };\n      new Swiper(\".tmpl_hh_aside-second .swiper\", {\n        loop: true,\n        modules: [Navigation, Pagination],\n        spaceBetween: 10,\n        pagination: {\n          el: \".tmpl_hh_aside-second .swiper-pagination\",\n          clickable: true,\n          bulletClass: \"tmpl_hh_swiper__pagination-bullet\",\n          bulletActiveClass: \"tmpl_hh_swiper__pagination-bullet-active\",\n        },\n        navigation: {\n          nextEl: \".tmpl_hh_aside-second .swiper-button-next\",\n          prevEl: \".tmpl_hh_aside-second .swiper-button-prev\",\n        },\n      });\n      vacanyTitle();\n      customTitle();\n    });\n\n    //\n  </script>\n",
  "vacancy_constructor_template": null,
  "key_skills": [
    {
      "name": "ЦФТ"
    },
    {
      "name": "BPMN"
    },
    {
      "name": "ORACLE"
    },
    {
      "name": "PostgreSQL"
    },
    {
      "name": "ERD"
    },
    {
      "name": "XML"
    },
    {
      "name": "Atlassian Confluence"
    },
    {
      "name": "Atlassian Jira"
    },
    {
      "name": "Системный анализ"
    },
    {
      "name": "Системная интеграция"
    }
  ],
  "accept_handicapped": false,
  "accept_kids": false,
  "archived": false,
  "response_url": null,
  "specializations": [],
  "professional_roles": [
    {
      "id": "148",
      "name": "Системный аналитик"
    }
  ],
  "code": null,
  "hidden": false,
  "quick_responses_allowed": false,
  "driver_license_types": [],
  "accept_incomplete_resumes": false,
  "employer": {
    "id": "4649269",
    "name": "Т1",
    "url": "https://api.hh.ru/employers/4649269",
    "alternate_url": "https://hh.ru/employer/4649269",
    "logo_urls": {
      "original": "https://img.hhcdn.ru/employer-logo-original/1334956.png",
      "90": "https://img.hhcdn.ru/employer-logo/6959834.png",
      "240": "https://img.hhcdn.ru/employer-logo/6959835.png"
    },
    "vacancies_url": "https://api.hh.ru/vacancies?employer_id=4649269",
    "accredited_it_employer": true,
    "trusted": true
  },
  "published_at": "2025-06-05T15:18:05+0300",
  "created_at": "2025-06-05T15:18:05+0300",
  "initial_created_at": "2025-06-05T15:18:05+0300",
  "negotiations_url": null,
  "suitable_resumes_url": null,
  "apply_alternate_url": "https://hh.ru/applicant/vacancy_response?vacancyId=121389224",
  "has_test": false,
  "test": null,
  "alternate_url": "https://hh.ru/vacancy/121389224",
  "working_days": [],
  "working_time_intervals": [],
  "working_time_modes": [],
  "accept_temporary": false,
  "languages": [],
  "approved": true,
  "employment_form": {
    "id": "FULL",
    "name": "Полная"
  },
  "fly_in_fly_out_duration": [],
  "internship": false,
  "night_shifts": false,
  "work_format": [
    {
      "id": "REMOTE",
      "name": "Удалённо"
    }
  ],
  "work_schedule_by_days": [
    {
      "id": "FIVE_ON_TWO_OFF",
      "name": "5/2"
    }
  ],
  "working_hours": [
    {
      "id": "HOURS_8",
      "name": "8 часов"
    }
  ],
  "show_logo_in_search": true
}
{
  "id": "121211626",
  "premium": false,
  "billing_type": {
    "id": "standard",
    "name": "Стандарт"
  },
  "relations": [],
  "name": "Системный аналитик",
  "insider_interview": null,
  "response_letter_required": false,
  "area": {
    "id": "1",
    "name": "Москва",
    "url": "https://api.hh.ru/areas/1"
  },
  "salary": null,
  "salary_range": null,
  "type": {
    "id": "open",
    "name": "Открытая"
  },
  "address": null,
  "allow_messages": false,
  "experience": {
    "id": "between1And3",
    "name": "От 1 года до 3 лет"
  },
  "schedule": {
    "id": "fullDay",
    "name": "Полный день"
  },
  "employment": {
    "id": "full",
    "name": "Полная занятость"
  },
  "department": null,
  "show_contacts": false,
  "contacts": null,
  "description": "<p>Наша команда разрабатывает новый инструмент автоматизации взаимодействия с клиентом на основе событий по инвестиционному портфелю и на финансовом рынке. Проект создаётся с нуля, что делает его идеальной возможностью для тех, кто хочет получить ценный опыт запуска новых продуктов.</p> <p>Каждому новому сотруднику предоставляется ментор, который поможет быстро адаптироваться и освоиться в процессах. У каждой компетенции есть лидер, готовый оказать поддержку в сложных ситуациях.</p><h3><strong>Обязанности</strong></h3> <ul> <li>Работа в небольшой команде по методологии Agile (Scrum);</li> <li>Сбор и проработка пользовательских, функциональных и нефункциональных требований для продукта;</li> <li>Проектирование API;</li> <li>Проектирование интеграционных потоков и разработка интеграционных спецификаций;</li> <li>Разработка архитектурной документации на уровне функциональной области команды;</li> <li>Участие в функциональном и интеграционном тестировании в роли эксперта;</li> <li>Участие в приемо-сдаточных испытаниях.</li> </ul><h3><strong>Требования</strong></h3> <ul> <li>Опыт работы в роли системного аналитика от 2 лет;</li> <li>Опыт сбора и подготовки требований, описания процессов;</li> <li>Навыки описания моделей данных ИТ-систем (до атрибутов сущностей);</li> <li>Знание методологий функционального, информационного и процессного моделирования (BPMN, UML);</li> <li>Понимание принципов работы REST/Web сервисов, очередей сообщений, XML/JSON, XSD/JSON Schema;</li> <li>Опыт проектирования и документирования API;</li> <li>Понимание принципов обеспечения безопасности при проектировании API;</li> <li>Базовое понимание принципов реляционных СУБД и знание SQL;</li> <li>Опыт командной работы с использованием Confluence, Jira.</li> </ul><h3><strong>Условия</strong></h3> <ul> <li>Гибридный формат работы (современный офис в Москве на Кутузовском проспекте);</li> <li>Льготные ипотечные условия кредитования;</li> <li>Бесплатная подписка СберПрайм+, скидки на продукты компаний-партнеров: Okko, Сбер Маркет, Мега Маркет, Самокат, Еаптека и другие;</li> <li>ДМС с первого дня и скидки на страхование для близких;</li> <li>Корпоративная пенсионная программа;</li> <li>Детский отдых и подарки за счет Компании;</li> <li>Обучение за счет Компании: онлайн курсы, неограниченный доступ к библиотеке и обучение на базе Корпоративного университета тренинги, митапы и возможность получить новую квалификацию;</li> <li>Скидки на отдых в курортном комплексе «Mriya Resort &amp; SPA» в Ялте.</li> </ul>",
  "branded_description": "\n<style>\n.tmpl-hh-wrapper {\n  box-shadow: 0 0 14px rgba(48, 50, 51, 0.1);\n  background: #FFFFFF;\n}\n\n.hht-vacancydescription {\n  padding: 0 !important;\n}\n\n.vacancy-branded-user-content ul,\n.vacancy-branded-user-content ol {\n  margin-left: 0;\n}\n\n.vacancy-branded-user-content p {\n  margin-top: 0 !important;\n}\n\n.vacancy-branded-user-content p:first-child b,\n.vacancy-branded-user-content p:first-child strong {\n  margin-top: 0 !important;\n}\n\n.tmpl-hh-wrapper {\n  width: 100%;\n  margin: 0 auto;\n  max-width: 690px;\n  position: relative;\n  overflow: hidden;\n  font-family: \"Arial\", sans-serif;\n  font-style: normal;\n  font-weight: 400;\n  font-size: 14px;\n  color: #334047;\n  line-height: 1.1428571429;\n}\n\n.tmpl-hh-wrapper * {\n  box-sizing: border-box;\n  padding: 0;\n  margin: 0;\n}\n\n.tmpl-hh-wrapper sup {\n  vertical-align: top;\n}\n\n.tmpl-hh-wrapper .mt-0 {\n  margin-top: -15px !important;\n}\n\n.tmpl-hh-content ol:not(:first-child),\n.tmpl-hh-content ul:not(:first-child) {\n  margin-top: 16px;\n}\n\n.tmpl-hh-content ol li p,\n.tmpl-hh-content ul li p {\n  margin: 0 !important;\n}\n\n.tmpl-hh-content ol li p b,\n.tmpl-hh-content ol li p strong,\n.tmpl-hh-content ul li p b,\n.tmpl-hh-content ul li p strong {\n  font-weight: 700;\n  font-size: inherit !important;\n  margin: 0 !important;\n  text-transform: none;\n  color: inherit !important;\n  display: initial;\n}\n\n.tmpl-hh-content ol li em,\n.tmpl-hh-content ul li em {\n  font-style: normal !important;\n}\n\n.tmpl-hh-content ol li em b,\n.tmpl-hh-content ol li em strong,\n.tmpl-hh-content ul li em b,\n.tmpl-hh-content ul li em strong {\n  text-transform: none;\n  display: inherit;\n  font-weight: 700;\n  font-size: inherit;\n  color: inherit;\n  font-style: normal !important;\n}\n\n.tmpl-hh-content ol li b,\n.tmpl-hh-content ol li strong,\n.tmpl-hh-content ul li b,\n.tmpl-hh-content ul li strong {\n  font-weight: 700;\n  font-size: inherit !important;\n  margin: 0 !important;\n  text-transform: none;\n  color: inherit !important;\n}\n\n.tmpl-hh-content p {\n  margin-bottom: 16px;\n}\n\n.tmpl-hh-content p b,\n.tmpl-hh-content p strong {\n  display: inline-block;\n  font-weight: 700;\n  font-size: 20px;\n  line-height: 22px;\n  color: #21A038;\n  letter-spacing: 0.2px;\n  margin-top: 36px !important;\n}\n\n.tmpl-hh-content p:first-child b,\n.tmpl-hh-content p:first-child strong {\n  margin-top: 0 !important;\n}\n\n.tmpl-hh-content p:last-child {\n  margin-bottom: 0 !important;\n}\n\n.tmpl-hh-content p em b,\n.tmpl-hh-content p em strong {\n  text-transform: none;\n  display: inherit;\n  font-weight: 700;\n  font-size: inherit;\n  color: inherit !important;\n  font-style: normal !important;\n  background: transparent;\n  padding: 0;\n}\n\n.tmpl-hh-content p + p b,\n.tmpl-hh-content p + p strong {\n  margin-top: 20px !important;\n}\n\n.tmpl-hh-content .l-paddings {\n  padding: 0;\n}\n\n@media (max-width: 1019px) {\n  .tmpl-hh-wrapper {\n    max-width: 610px;\n  }\n}\n\n@media (max-width: 699px) {\n  .tmpl-hh-content p b,\n  .tmpl-hh-content p strong {\n    margin-top: 32px !important;\n    letter-spacing: 0;\n  }\n  .tmpl-hh-content p + p b,\n  .tmpl-hh-content p + p strong {\n    margin-top: 13px !important;\n  }\n}\n\n.tmpl-hh-header {\n  position: relative;\n}\n\n.tmpl-hh-header__inner {\n  padding: 24px 48px 0;\n}\n\n.tmpl-hh-header__logo {\n  width: 166px;\n  height: 28px;\n  position: relative;\n  z-index: 3;\n}\n\n.tmpl-hh-header__logo img {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\n.tmpl-hh-header__image {\n  width: 476px;\n  height: 463px;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: 2;\n}\n\n.tmpl-hh-header__image img {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\n.tmpl-hh-header__title {\n  width: 191px;\n  height: 94px;\n  margin-top: 66px;\n  position: relative;\n  z-index: 3;\n}\n\n.tmpl-hh-header__title img {\n  width: 100%;\n  height: 100%;\n}\n\n.tmpl-hh-header__text {\n  line-height: 22px;\n  padding: 32px;\n  background: rgba(255, 255, 255, 0.9);\n  border: 1px solid #ECF8EC;\n  border-radius: 12px;\n  position: relative;\n  z-index: 3;\n  margin-top: 143px;\n}\n\n.UNSAFE-vacancy-branded-is-desktop .tmpl-hh-header__text {\n  backdrop-filter: blur(4px);\n}\n\n.tmpl-hh-header__pattern {\n  width: 528px;\n  height: 910px;\n  position: absolute;\n  z-index: 1;\n  right: 0;\n  top: 60px;\n}\n\n.tmpl-hh-header__pattern img {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\n@media (max-width: 699px) {\n  .tmpl-hh-header__inner {\n    padding: 24px 10px 0;\n  }\n  .tmpl-hh-header__image {\n    width: 100%;\n    height: auto;\n    position: relative;\n    margin-top: 10px;\n    top: 0;\n    left: 0;\n    padding-bottom: 101.1764705882%;\n  }\n  .tmpl-hh-header__image img {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n  }\n  .tmpl-hh-header__title {\n    margin-top: 30px;\n  }\n  .tmpl-hh-header__text {\n    font-size: 14px;\n    margin-top: -46px;\n  }\n  .tmpl-hh-header__pattern {\n    width: 290px;\n    height: 700px;\n    top: 100%;\n    margin-top: -290px;\n  }\n}\n\n.tmpl-hh-content {\n  padding: 48px;\n  position: relative;\n  z-index: 3;\n  letter-spacing: 0.168px;\n}\n\n.tmpl-hh-content ul,\n.tmpl-hh-content ol {\n  margin-left: 17px;\n}\n\n.tmpl-hh-content ul li,\n.tmpl-hh-content ol li {\n  position: relative;\n}\n\n.tmpl-hh-content ul li:not(:last-child),\n.tmpl-hh-content ol li:not(:last-child) {\n  margin-bottom: 16px;\n}\n\n.tmpl-hh-content ul li {\n  list-style: none;\n}\n\n.tmpl-hh-content ul li:before {\n  content: \"\";\n  position: absolute;\n  width: 4px;\n  height: 4px;\n  border-radius: 50%;\n  top: 6px;\n  left: -17px;\n  background: #00D900;\n}\n\n@media (max-width: 699px) {\n  .tmpl-hh-content {\n    padding: 50px 10px;\n    letter-spacing: 0;\n  }\n}\n\n.tmpl-hh-footer {\n  position: relative;\n  padding: 4px 48px 48px;\n}\n\n.tmpl-hh-footer__benefits {\n  margin-bottom: 58px;\n  position: relative;\n  z-index: 2;\n}\n\n.tmpl-hh-footer__benefits-title {\n  font-weight: 700;\n  font-size: 20px;\n  line-height: 1.1;\n  color: #21A038;\n  margin-bottom: 24px;\n}\n\n.tmpl-hh-footer__benefits-list {\n  background: rgba(255, 255, 255, 0.8);\n  border: 1px solid #ECF8EC;\n  padding: 43px 40px 47px;\n  border-radius: 12px;\n}\n\n.UNSAFE-vacancy-branded-is-desktop .tmpl-hh-footer__benefits-list {\n  backdrop-filter: blur(4px);\n}\n\n.tmpl-hh-footer__benefits-slider {\n  overflow: hidden;\n}\n\n.tmpl-hh-footer__benefits-slider-wrapper {\n  display: flex;\n  flex-wrap: nowrap;\n}\n\n.tmpl-hh-footer__benefits-slider-pug {\n  display: flex;\n  justify-content: center;\n  margin-top: 14px;\n}\n\n.tmpl-hh-footer__benefits-slider-pug .swiper-pagination-bullet {\n  width: 6px;\n  height: 6px;\n  transition: width 0.3s;\n  border: 1px solid #00D900;\n  border-radius: 5px;\n  display: block;\n  margin: 0 4px;\n}\n\n.tmpl-hh-footer__benefits-slider-pug .swiper-pagination-bullet-active {\n  background: #00D900;\n  width: 24px;\n}\n\n.tmpl-hh-footer__benefit {\n  flex-shrink: 0;\n  display: flex;\n  align-items: flex-start;\n}\n\n.tmpl-hh-footer__benefit-icon {\n  width: 32px;\n  height: 32px;\n  flex-shrink: 0;\n  margin-right: 10px;\n  margin-top: 10px;\n}\n\n.tmpl-hh-footer__benefit-icon svg {\n  width: 100%;\n  height: 100%;\n}\n\n.tmpl-hh-footer__benefit-text {\n  line-height: 18px;\n  height: 54px;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n}\n\n.tmpl-hh-footer__pattern {\n  position: absolute;\n  left: 0;\n  width: 637px;\n  height: 519px;\n  top: -65px;\n  z-index: 1;\n}\n\n.tmpl-hh-footer__pattern img {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\n.tmpl-hh-footer__notes {\n  position: relative;\n  font-size: 12px;\n  line-height: 16px;\n  color: rgba(51, 63, 72, 0.6);\n  z-index: 2;\n}\n\n.tmpl-hh-footer__text {\n  font-size: 12px;\n  line-height: 16px;\n  color: rgba(51, 63, 72, 0.6);\n  margin-top: 16px;\n  position: relative;\n  z-index: 2;\n}\n\n.tmpl-hh-footer__text p:not(:last-child) {\n  margin-bottom: 8px;\n}\n\n@media (max-width: 699px) {\n  .tmpl-hh-footer {\n    padding: 4px 10px 40px;\n  }\n  .tmpl-hh-footer__benefits-list {\n    padding: 36px 16px;\n  }\n  .tmpl-hh-footer__benefit-text {\n    height: 72px;\n    max-width: 280px;\n  }\n  .tmpl-hh-footer__benefit-icon {\n    margin-top: 19px;\n  }\n  .tmpl-hh-footer__pattern {\n    top: -70px;\n  }\n}\n</style>\n\n<script type=\"text/javascript\">  \n//\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n(function polyfill() {\n  const relList = document.createElement(\"link\").relList;\n  if (relList && relList.supports && relList.supports(\"modulepreload\")) {\n    return;\n  }\n  for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n    processPreload(link);\n  }\n  new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      if (mutation.type !== \"childList\") {\n        continue;\n      }\n      for (const node of mutation.addedNodes) {\n        if (node.tagName === \"LINK\" && node.rel === \"modulepreload\")\n          processPreload(node);\n      }\n    }\n  }).observe(document, { childList: true, subtree: true });\n  function getFetchOpts(script) {\n    const fetchOpts = {};\n    if (script.integrity)\n      fetchOpts.integrity = script.integrity;\n    if (script.referrerpolicy)\n      fetchOpts.referrerPolicy = script.referrerpolicy;\n    if (script.crossorigin === \"use-credentials\")\n      fetchOpts.credentials = \"include\";\n    else if (script.crossorigin === \"anonymous\")\n      fetchOpts.credentials = \"omit\";\n    else\n      fetchOpts.credentials = \"same-origin\";\n    return fetchOpts;\n  }\n  function processPreload(link) {\n    if (link.ep)\n      return;\n    link.ep = true;\n    const fetchOpts = getFetchOpts(link);\n    fetch(link.href, fetchOpts);\n  }\n})();\nconst index$1 = \"\";\nfunction isObject$1(obj) {\n  return obj !== null && typeof obj === \"object\" && \"constructor\" in obj && obj.constructor === Object;\n}\nfunction extend$1(target = {}, src = {}) {\n  Object.keys(src).forEach((key) => {\n    if (typeof target[key] === \"undefined\")\n      target[key] = src[key];\n    else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n      extend$1(target[key], src[key]);\n    }\n  });\n}\nconst ssrDocument = {\n  body: {},\n  addEventListener() {\n  },\n  removeEventListener() {\n  },\n  activeElement: {\n    blur() {\n    },\n    nodeName: \"\"\n  },\n  querySelector() {\n    return null;\n  },\n  querySelectorAll() {\n    return [];\n  },\n  getElementById() {\n    return null;\n  },\n  createEvent() {\n    return {\n      initEvent() {\n      }\n    };\n  },\n  createElement() {\n    return {\n      children: [],\n      childNodes: [],\n      style: {},\n      setAttribute() {\n      },\n      getElementsByTagName() {\n        return [];\n      }\n    };\n  },\n  createElementNS() {\n    return {};\n  },\n  importNode() {\n    return null;\n  },\n  location: {\n    hash: \"\",\n    host: \"\",\n    hostname: \"\",\n    href: \"\",\n    origin: \"\",\n    pathname: \"\",\n    protocol: \"\",\n    search: \"\"\n  }\n};\nfunction getDocument() {\n  const doc = typeof document !== \"undefined\" ? document : {};\n  extend$1(doc, ssrDocument);\n  return doc;\n}\nconst ssrWindow = {\n  document: ssrDocument,\n  navigator: {\n    userAgent: \"\"\n  },\n  location: {\n    hash: \"\",\n    host: \"\",\n    hostname: \"\",\n    href: \"\",\n    origin: \"\",\n    pathname: \"\",\n    protocol: \"\",\n    search: \"\"\n  },\n  history: {\n    replaceState() {\n    },\n    pushState() {\n    },\n    go() {\n    },\n    back() {\n    }\n  },\n  CustomEvent: function CustomEvent() {\n    return this;\n  },\n  addEventListener() {\n  },\n  removeEventListener() {\n  },\n  getComputedStyle() {\n    return {\n      getPropertyValue() {\n        return \"\";\n      }\n    };\n  },\n  Image() {\n  },\n  Date() {\n  },\n  screen: {},\n  setTimeout() {\n  },\n  clearTimeout() {\n  },\n  matchMedia() {\n    return {};\n  },\n  requestAnimationFrame(callback) {\n    if (typeof setTimeout === \"undefined\") {\n      callback();\n      return null;\n    }\n    return setTimeout(callback, 0);\n  },\n  cancelAnimationFrame(id) {\n    if (typeof setTimeout === \"undefined\") {\n      return;\n    }\n    clearTimeout(id);\n  }\n};\nfunction getWindow() {\n  const win = typeof window !== \"undefined\" ? window : {};\n  extend$1(win, ssrWindow);\n  return win;\n}\nfunction makeReactive(obj) {\n  const proto = obj.__proto__;\n  Object.defineProperty(obj, \"__proto__\", {\n    get() {\n      return proto;\n    },\n    set(value) {\n      proto.__proto__ = value;\n    }\n  });\n}\nclass Dom7 extends Array {\n  constructor(items) {\n    if (typeof items === \"number\") {\n      super(items);\n    } else {\n      super(...items || []);\n      makeReactive(this);\n    }\n  }\n}\nfunction arrayFlat(arr = []) {\n  const res = [];\n  arr.forEach((el) => {\n    if (Array.isArray(el)) {\n      res.push(...arrayFlat(el));\n    } else {\n      res.push(el);\n    }\n  });\n  return res;\n}\nfunction arrayFilter(arr, callback) {\n  return Array.prototype.filter.call(arr, callback);\n}\nfunction arrayUnique(arr) {\n  const uniqueArray = [];\n  for (let i = 0; i < arr.length; i += 1) {\n    if (uniqueArray.indexOf(arr[i]) === -1)\n      uniqueArray.push(arr[i]);\n  }\n  return uniqueArray;\n}\nfunction qsa(selector, context) {\n  if (typeof selector !== \"string\") {\n    return [selector];\n  }\n  const a = [];\n  const res = context.querySelectorAll(selector);\n  for (let i = 0; i < res.length; i += 1) {\n    a.push(res[i]);\n  }\n  return a;\n}\nfunction $(selector, context) {\n  const window2 = getWindow();\n  const document2 = getDocument();\n  let arr = [];\n  if (!context && selector instanceof Dom7) {\n    return selector;\n  }\n  if (!selector) {\n    return new Dom7(arr);\n  }\n  if (typeof selector === \"string\") {\n    const html2 = selector.trim();\n    if (html2.indexOf(\"<\") >= 0 && html2.indexOf(\">\") >= 0) {\n      let toCreate = \"div\";\n      if (html2.indexOf(\"<li\") === 0)\n        toCreate = \"ul\";\n      if (html2.indexOf(\"<tr\") === 0)\n        toCreate = \"tbody\";\n      if (html2.indexOf(\"<td\") === 0 || html2.indexOf(\"<th\") === 0)\n        toCreate = \"tr\";\n      if (html2.indexOf(\"<tbody\") === 0)\n        toCreate = \"table\";\n      if (html2.indexOf(\"<option\") === 0)\n        toCreate = \"select\";\n      const tempParent = document2.createElement(toCreate);\n      tempParent.innerHTML = html2;\n      for (let i = 0; i < tempParent.childNodes.length; i += 1) {\n        arr.push(tempParent.childNodes[i]);\n      }\n    } else {\n      arr = qsa(selector.trim(), context || document2);\n    }\n  } else if (selector.nodeType || selector === window2 || selector === document2) {\n    arr.push(selector);\n  } else if (Array.isArray(selector)) {\n    if (selector instanceof Dom7)\n      return selector;\n    arr = selector;\n  }\n  return new Dom7(arrayUnique(arr));\n}\n$.fn = Dom7.prototype;\nfunction addClass(...classes2) {\n  const classNames = arrayFlat(classes2.map((c) => c.split(\" \")));\n  this.forEach((el) => {\n    el.classList.add(...classNames);\n  });\n  return this;\n}\nfunction removeClass(...classes2) {\n  const classNames = arrayFlat(classes2.map((c) => c.split(\" \")));\n  this.forEach((el) => {\n    el.classList.remove(...classNames);\n  });\n  return this;\n}\nfunction toggleClass(...classes2) {\n  const classNames = arrayFlat(classes2.map((c) => c.split(\" \")));\n  this.forEach((el) => {\n    classNames.forEach((className) => {\n      el.classList.toggle(className);\n    });\n  });\n}\nfunction hasClass(...classes2) {\n  const classNames = arrayFlat(classes2.map((c) => c.split(\" \")));\n  return arrayFilter(this, (el) => {\n    return classNames.filter((className) => el.classList.contains(className)).length > 0;\n  }).length > 0;\n}\nfunction attr(attrs, value) {\n  if (arguments.length === 1 && typeof attrs === \"string\") {\n    if (this[0])\n      return this[0].getAttribute(attrs);\n    return void 0;\n  }\n  for (let i = 0; i < this.length; i += 1) {\n    if (arguments.length === 2) {\n      this[i].setAttribute(attrs, value);\n    } else {\n      for (const attrName in attrs) {\n        this[i][attrName] = attrs[attrName];\n        this[i].setAttribute(attrName, attrs[attrName]);\n      }\n    }\n  }\n  return this;\n}\nfunction removeAttr(attr2) {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].removeAttribute(attr2);\n  }\n  return this;\n}\nfunction transform(transform2) {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].style.transform = transform2;\n  }\n  return this;\n}\nfunction transition$1(duration) {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].style.transitionDuration = typeof duration !== \"string\" ? `${duration}ms` : duration;\n  }\n  return this;\n}\nfunction on(...args) {\n  let [eventType, targetSelector, listener, capture] = args;\n  if (typeof args[1] === \"function\") {\n    [eventType, listener, capture] = args;\n    targetSelector = void 0;\n  }\n  if (!capture)\n    capture = false;\n  function handleLiveEvent(e) {\n    const target = e.target;\n    if (!target)\n      return;\n    const eventData = e.target.dom7EventData || [];\n    if (eventData.indexOf(e) < 0) {\n      eventData.unshift(e);\n    }\n    if ($(target).is(targetSelector))\n      listener.apply(target, eventData);\n    else {\n      const parents2 = $(target).parents();\n      for (let k = 0; k < parents2.length; k += 1) {\n        if ($(parents2[k]).is(targetSelector))\n          listener.apply(parents2[k], eventData);\n      }\n    }\n  }\n  function handleEvent(e) {\n    const eventData = e && e.target ? e.target.dom7EventData || [] : [];\n    if (eventData.indexOf(e) < 0) {\n      eventData.unshift(e);\n    }\n    listener.apply(this, eventData);\n  }\n  const events2 = eventType.split(\" \");\n  let j;\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (!targetSelector) {\n      for (j = 0; j < events2.length; j += 1) {\n        const event = events2[j];\n        if (!el.dom7Listeners)\n          el.dom7Listeners = {};\n        if (!el.dom7Listeners[event])\n          el.dom7Listeners[event] = [];\n        el.dom7Listeners[event].push({\n          listener,\n          proxyListener: handleEvent\n        });\n        el.addEventListener(event, handleEvent, capture);\n      }\n    } else {\n      for (j = 0; j < events2.length; j += 1) {\n        const event = events2[j];\n        if (!el.dom7LiveListeners)\n          el.dom7LiveListeners = {};\n        if (!el.dom7LiveListeners[event])\n          el.dom7LiveListeners[event] = [];\n        el.dom7LiveListeners[event].push({\n          listener,\n          proxyListener: handleLiveEvent\n        });\n        el.addEventListener(event, handleLiveEvent, capture);\n      }\n    }\n  }\n  return this;\n}\nfunction off(...args) {\n  let [eventType, targetSelector, listener, capture] = args;\n  if (typeof args[1] === \"function\") {\n    [eventType, listener, capture] = args;\n    targetSelector = void 0;\n  }\n  if (!capture)\n    capture = false;\n  const events2 = eventType.split(\" \");\n  for (let i = 0; i < events2.length; i += 1) {\n    const event = events2[i];\n    for (let j = 0; j < this.length; j += 1) {\n      const el = this[j];\n      let handlers;\n      if (!targetSelector && el.dom7Listeners) {\n        handlers = el.dom7Listeners[event];\n      } else if (targetSelector && el.dom7LiveListeners) {\n        handlers = el.dom7LiveListeners[event];\n      }\n      if (handlers && handlers.length) {\n        for (let k = handlers.length - 1; k >= 0; k -= 1) {\n          const handler = handlers[k];\n          if (listener && handler.listener === listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          } else if (!listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          }\n        }\n      }\n    }\n  }\n  return this;\n}\nfunction trigger(...args) {\n  const window2 = getWindow();\n  const events2 = args[0].split(\" \");\n  const eventData = args[1];\n  for (let i = 0; i < events2.length; i += 1) {\n    const event = events2[i];\n    for (let j = 0; j < this.length; j += 1) {\n      const el = this[j];\n      if (window2.CustomEvent) {\n        const evt = new window2.CustomEvent(event, {\n          detail: eventData,\n          bubbles: true,\n          cancelable: true\n        });\n        el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);\n        el.dispatchEvent(evt);\n        el.dom7EventData = [];\n        delete el.dom7EventData;\n      }\n    }\n  }\n  return this;\n}\nfunction transitionEnd$1(callback) {\n  const dom = this;\n  function fireCallBack(e) {\n    if (e.target !== this)\n      return;\n    callback.call(this, e);\n    dom.off(\"transitionend\", fireCallBack);\n  }\n  if (callback) {\n    dom.on(\"transitionend\", fireCallBack);\n  }\n  return this;\n}\nfunction outerWidth(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      const styles2 = this.styles();\n      return this[0].offsetWidth + parseFloat(styles2.getPropertyValue(\"margin-right\")) + parseFloat(styles2.getPropertyValue(\"margin-left\"));\n    }\n    return this[0].offsetWidth;\n  }\n  return null;\n}\nfunction outerHeight(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      const styles2 = this.styles();\n      return this[0].offsetHeight + parseFloat(styles2.getPropertyValue(\"margin-top\")) + parseFloat(styles2.getPropertyValue(\"margin-bottom\"));\n    }\n    return this[0].offsetHeight;\n  }\n  return null;\n}\nfunction offset() {\n  if (this.length > 0) {\n    const window2 = getWindow();\n    const document2 = getDocument();\n    const el = this[0];\n    const box = el.getBoundingClientRect();\n    const body = document2.body;\n    const clientTop = el.clientTop || body.clientTop || 0;\n    const clientLeft = el.clientLeft || body.clientLeft || 0;\n    const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;\n    const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;\n    return {\n      top: box.top + scrollTop - clientTop,\n      left: box.left + scrollLeft - clientLeft\n    };\n  }\n  return null;\n}\nfunction styles() {\n  const window2 = getWindow();\n  if (this[0])\n    return window2.getComputedStyle(this[0], null);\n  return {};\n}\nfunction css(props, value) {\n  const window2 = getWindow();\n  let i;\n  if (arguments.length === 1) {\n    if (typeof props === \"string\") {\n      if (this[0])\n        return window2.getComputedStyle(this[0], null).getPropertyValue(props);\n    } else {\n      for (i = 0; i < this.length; i += 1) {\n        for (const prop in props) {\n          this[i].style[prop] = props[prop];\n        }\n      }\n      return this;\n    }\n  }\n  if (arguments.length === 2 && typeof props === \"string\") {\n    for (i = 0; i < this.length; i += 1) {\n      this[i].style[props] = value;\n    }\n    return this;\n  }\n  return this;\n}\nfunction each(callback) {\n  if (!callback)\n    return this;\n  this.forEach((el, index2) => {\n    callback.apply(el, [el, index2]);\n  });\n  return this;\n}\nfunction filter(callback) {\n  const result = arrayFilter(this, callback);\n  return $(result);\n}\nfunction html(html2) {\n  if (typeof html2 === \"undefined\") {\n    return this[0] ? this[0].innerHTML : null;\n  }\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].innerHTML = html2;\n  }\n  return this;\n}\nfunction text(text2) {\n  if (typeof text2 === \"undefined\") {\n    return this[0] ? this[0].textContent.trim() : null;\n  }\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].textContent = text2;\n  }\n  return this;\n}\nfunction is(selector) {\n  const window2 = getWindow();\n  const document2 = getDocument();\n  const el = this[0];\n  let compareWith;\n  let i;\n  if (!el || typeof selector === \"undefined\")\n    return false;\n  if (typeof selector === \"string\") {\n    if (el.matches)\n      return el.matches(selector);\n    if (el.webkitMatchesSelector)\n      return el.webkitMatchesSelector(selector);\n    if (el.msMatchesSelector)\n      return el.msMatchesSelector(selector);\n    compareWith = $(selector);\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el)\n        return true;\n    }\n    return false;\n  }\n  if (selector === document2) {\n    return el === document2;\n  }\n  if (selector === window2) {\n    return el === window2;\n  }\n  if (selector.nodeType || selector instanceof Dom7) {\n    compareWith = selector.nodeType ? [selector] : selector;\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el)\n        return true;\n    }\n    return false;\n  }\n  return false;\n}\nfunction index() {\n  let child = this[0];\n  let i;\n  if (child) {\n    i = 0;\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1)\n        i += 1;\n    }\n    return i;\n  }\n  return void 0;\n}\nfunction eq(index2) {\n  if (typeof index2 === \"undefined\")\n    return this;\n  const length = this.length;\n  if (index2 > length - 1) {\n    return $([]);\n  }\n  if (index2 < 0) {\n    const returnIndex = length + index2;\n    if (returnIndex < 0)\n      return $([]);\n    return $([this[returnIndex]]);\n  }\n  return $([this[index2]]);\n}\nfunction append(...els) {\n  let newChild;\n  const document2 = getDocument();\n  for (let k = 0; k < els.length; k += 1) {\n    newChild = els[k];\n    for (let i = 0; i < this.length; i += 1) {\n      if (typeof newChild === \"string\") {\n        const tempDiv = document2.createElement(\"div\");\n        tempDiv.innerHTML = newChild;\n        while (tempDiv.firstChild) {\n          this[i].appendChild(tempDiv.firstChild);\n        }\n      } else if (newChild instanceof Dom7) {\n        for (let j = 0; j < newChild.length; j += 1) {\n          this[i].appendChild(newChild[j]);\n        }\n      } else {\n        this[i].appendChild(newChild);\n      }\n    }\n  }\n  return this;\n}\nfunction prepend(newChild) {\n  const document2 = getDocument();\n  let i;\n  let j;\n  for (i = 0; i < this.length; i += 1) {\n    if (typeof newChild === \"string\") {\n      const tempDiv = document2.createElement(\"div\");\n      tempDiv.innerHTML = newChild;\n      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {\n        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);\n      }\n    } else if (newChild instanceof Dom7) {\n      for (j = 0; j < newChild.length; j += 1) {\n        this[i].insertBefore(newChild[j], this[i].childNodes[0]);\n      }\n    } else {\n      this[i].insertBefore(newChild, this[i].childNodes[0]);\n    }\n  }\n  return this;\n}\nfunction next(selector) {\n  if (this.length > 0) {\n    if (selector) {\n      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {\n        return $([this[0].nextElementSibling]);\n      }\n      return $([]);\n    }\n    if (this[0].nextElementSibling)\n      return $([this[0].nextElementSibling]);\n    return $([]);\n  }\n  return $([]);\n}\nfunction nextAll(selector) {\n  const nextEls = [];\n  let el = this[0];\n  if (!el)\n    return $([]);\n  while (el.nextElementSibling) {\n    const next2 = el.nextElementSibling;\n    if (selector) {\n      if ($(next2).is(selector))\n        nextEls.push(next2);\n    } else\n      nextEls.push(next2);\n    el = next2;\n  }\n  return $(nextEls);\n}\nfunction prev(selector) {\n  if (this.length > 0) {\n    const el = this[0];\n    if (selector) {\n      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {\n        return $([el.previousElementSibling]);\n      }\n      return $([]);\n    }\n    if (el.previousElementSibling)\n      return $([el.previousElementSibling]);\n    return $([]);\n  }\n  return $([]);\n}\nfunction prevAll(selector) {\n  const prevEls = [];\n  let el = this[0];\n  if (!el)\n    return $([]);\n  while (el.previousElementSibling) {\n    const prev2 = el.previousElementSibling;\n    if (selector) {\n      if ($(prev2).is(selector))\n        prevEls.push(prev2);\n    } else\n      prevEls.push(prev2);\n    el = prev2;\n  }\n  return $(prevEls);\n}\nfunction parent(selector) {\n  const parents2 = [];\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i].parentNode !== null) {\n      if (selector) {\n        if ($(this[i].parentNode).is(selector))\n          parents2.push(this[i].parentNode);\n      } else {\n        parents2.push(this[i].parentNode);\n      }\n    }\n  }\n  return $(parents2);\n}\nfunction parents(selector) {\n  const parents2 = [];\n  for (let i = 0; i < this.length; i += 1) {\n    let parent2 = this[i].parentNode;\n    while (parent2) {\n      if (selector) {\n        if ($(parent2).is(selector))\n          parents2.push(parent2);\n      } else {\n        parents2.push(parent2);\n      }\n      parent2 = parent2.parentNode;\n    }\n  }\n  return $(parents2);\n}\nfunction closest(selector) {\n  let closest2 = this;\n  if (typeof selector === \"undefined\") {\n    return $([]);\n  }\n  if (!closest2.is(selector)) {\n    closest2 = closest2.parents(selector).eq(0);\n  }\n  return closest2;\n}\nfunction find(selector) {\n  const foundElements = [];\n  for (let i = 0; i < this.length; i += 1) {\n    const found = this[i].querySelectorAll(selector);\n    for (let j = 0; j < found.length; j += 1) {\n      foundElements.push(found[j]);\n    }\n  }\n  return $(foundElements);\n}\nfunction children(selector) {\n  const children2 = [];\n  for (let i = 0; i < this.length; i += 1) {\n    const childNodes = this[i].children;\n    for (let j = 0; j < childNodes.length; j += 1) {\n      if (!selector || $(childNodes[j]).is(selector)) {\n        children2.push(childNodes[j]);\n      }\n    }\n  }\n  return $(children2);\n}\nfunction remove() {\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i].parentNode)\n      this[i].parentNode.removeChild(this[i]);\n  }\n  return this;\n}\nconst Methods = {\n  addClass,\n  removeClass,\n  hasClass,\n  toggleClass,\n  attr,\n  removeAttr,\n  transform,\n  transition: transition$1,\n  on,\n  off,\n  trigger,\n  transitionEnd: transitionEnd$1,\n  outerWidth,\n  outerHeight,\n  styles,\n  offset,\n  css,\n  each,\n  html,\n  text,\n  is,\n  index,\n  eq,\n  append,\n  prepend,\n  next,\n  nextAll,\n  prev,\n  prevAll,\n  parent,\n  parents,\n  closest,\n  find,\n  children,\n  filter,\n  remove\n};\nObject.keys(Methods).forEach((methodName) => {\n  Object.defineProperty($.fn, methodName, {\n    value: Methods[methodName],\n    writable: true\n  });\n});\nfunction deleteProps(obj) {\n  const object = obj;\n  Object.keys(object).forEach((key) => {\n    try {\n      object[key] = null;\n    } catch (e) {\n    }\n    try {\n      delete object[key];\n    } catch (e) {\n    }\n  });\n}\nfunction nextTick(callback, delay = 0) {\n  return setTimeout(callback, delay);\n}\nfunction now() {\n  return Date.now();\n}\nfunction getComputedStyle$1(el) {\n  const window2 = getWindow();\n  let style;\n  if (window2.getComputedStyle) {\n    style = window2.getComputedStyle(el, null);\n  }\n  if (!style && el.currentStyle) {\n    style = el.currentStyle;\n  }\n  if (!style) {\n    style = el.style;\n  }\n  return style;\n}\nfunction getTranslate(el, axis = \"x\") {\n  const window2 = getWindow();\n  let matrix;\n  let curTransform;\n  let transformMatrix;\n  const curStyle = getComputedStyle$1(el);\n  if (window2.WebKitCSSMatrix) {\n    curTransform = curStyle.transform || curStyle.webkitTransform;\n    if (curTransform.split(\",\").length > 6) {\n      curTransform = curTransform.split(\", \").map((a) => a.replace(\",\", \".\")).join(\", \");\n    }\n    transformMatrix = new window2.WebKitCSSMatrix(curTransform === \"none\" ? \"\" : curTransform);\n  } else {\n    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\");\n    matrix = transformMatrix.toString().split(\",\");\n  }\n  if (axis === \"x\") {\n    if (window2.WebKitCSSMatrix)\n      curTransform = transformMatrix.m41;\n    else if (matrix.length === 16)\n      curTransform = parseFloat(matrix[12]);\n    else\n      curTransform = parseFloat(matrix[4]);\n  }\n  if (axis === \"y\") {\n    if (window2.WebKitCSSMatrix)\n      curTransform = transformMatrix.m42;\n    else if (matrix.length === 16)\n      curTransform = parseFloat(matrix[13]);\n    else\n      curTransform = parseFloat(matrix[5]);\n  }\n  return curTransform || 0;\n}\nfunction isObject(o) {\n  return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\";\n}\nfunction isNode(node) {\n  if (typeof window !== \"undefined\" && typeof window.HTMLElement !== \"undefined\") {\n    return node instanceof HTMLElement;\n  }\n  return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction extend(...args) {\n  const to = Object(args[0]);\n  const noExtend = [\"__proto__\", \"constructor\", \"prototype\"];\n  for (let i = 1; i < args.length; i += 1) {\n    const nextSource = args[i];\n    if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {\n      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);\n      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n        const nextKey = keysArray[nextIndex];\n        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n        if (desc !== void 0 && desc.enumerable) {\n          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            to[nextKey] = {};\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n  }\n  return to;\n}\nfunction setCSSProperty(el, varName, varValue) {\n  el.style.setProperty(varName, varValue);\n}\nfunction animateCSSModeScroll({\n  swiper,\n  targetPosition,\n  side\n}) {\n  const window2 = getWindow();\n  const startPosition = -swiper.translate;\n  let startTime = null;\n  let time;\n  const duration = swiper.params.speed;\n  swiper.wrapperEl.style.scrollSnapType = \"none\";\n  window2.cancelAnimationFrame(swiper.cssModeFrameID);\n  const dir = targetPosition > startPosition ? \"next\" : \"prev\";\n  const isOutOfBound = (current, target) => {\n    return dir === \"next\" && current >= target || dir === \"prev\" && current <= target;\n  };\n  const animate = () => {\n    time = new Date().getTime();\n    if (startTime === null) {\n      startTime = time;\n    }\n    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      currentPosition = targetPosition;\n    }\n    swiper.wrapperEl.scrollTo({\n      [side]: currentPosition\n    });\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      swiper.wrapperEl.style.overflow = \"hidden\";\n      swiper.wrapperEl.style.scrollSnapType = \"\";\n      setTimeout(() => {\n        swiper.wrapperEl.style.overflow = \"\";\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition\n        });\n      });\n      window2.cancelAnimationFrame(swiper.cssModeFrameID);\n      return;\n    }\n    swiper.cssModeFrameID = window2.requestAnimationFrame(animate);\n  };\n  animate();\n}\nlet support;\nfunction calcSupport() {\n  const window2 = getWindow();\n  const document2 = getDocument();\n  return {\n    smoothScroll: document2.documentElement && \"scrollBehavior\" in document2.documentElement.style,\n    touch: !!(\"ontouchstart\" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),\n    passiveListener: function checkPassiveListener() {\n      let supportsPassive = false;\n      try {\n        const opts = Object.defineProperty({}, \"passive\", {\n          // eslint-disable-next-line\n          get() {\n            supportsPassive = true;\n          }\n        });\n        window2.addEventListener(\"testPassiveListener\", null, opts);\n      } catch (e) {\n      }\n      return supportsPassive;\n    }(),\n    gestures: function checkGestures() {\n      return \"ongesturestart\" in window2;\n    }()\n  };\n}\nfunction getSupport() {\n  if (!support) {\n    support = calcSupport();\n  }\n  return support;\n}\nlet deviceCached;\nfunction calcDevice({\n  userAgent\n} = {}) {\n  const support2 = getSupport();\n  const window2 = getWindow();\n  const platform = window2.navigator.platform;\n  const ua = userAgent || window2.navigator.userAgent;\n  const device = {\n    ios: false,\n    android: false\n  };\n  const screenWidth = window2.screen.width;\n  const screenHeight = window2.screen.height;\n  const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n  let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n  const windows = platform === \"Win32\";\n  let macos = platform === \"MacIntel\";\n  const iPadScreens = [\"1024x1366\", \"1366x1024\", \"834x1194\", \"1194x834\", \"834x1112\", \"1112x834\", \"768x1024\", \"1024x768\", \"820x1180\", \"1180x820\", \"810x1080\", \"1080x810\"];\n  if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n    ipad = ua.match(/(Version)\\/([\\d.]+)/);\n    if (!ipad)\n      ipad = [0, 1, \"13_0_0\"];\n    macos = false;\n  }\n  if (android && !windows) {\n    device.os = \"android\";\n    device.android = true;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = \"ios\";\n    device.ios = true;\n  }\n  return device;\n}\nfunction getDevice(overrides = {}) {\n  if (!deviceCached) {\n    deviceCached = calcDevice(overrides);\n  }\n  return deviceCached;\n}\nlet browser;\nfunction calcBrowser() {\n  const window2 = getWindow();\n  function isSafari() {\n    const ua = window2.navigator.userAgent.toLowerCase();\n    return ua.indexOf(\"safari\") >= 0 && ua.indexOf(\"chrome\") < 0 && ua.indexOf(\"android\") < 0;\n  }\n  return {\n    isSafari: isSafari(),\n    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)\n  };\n}\nfunction getBrowser() {\n  if (!browser) {\n    browser = calcBrowser();\n  }\n  return browser;\n}\nfunction Resize({\n  swiper,\n  on: on2,\n  emit\n}) {\n  const window2 = getWindow();\n  let observer = null;\n  let animationFrame = null;\n  const resizeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized)\n      return;\n    emit(\"beforeResize\");\n    emit(\"resize\");\n  };\n  const createObserver = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized)\n      return;\n    observer = new ResizeObserver((entries) => {\n      animationFrame = window2.requestAnimationFrame(() => {\n        const {\n          width,\n          height\n        } = swiper;\n        let newWidth = width;\n        let newHeight = height;\n        entries.forEach(({\n          contentBoxSize,\n          contentRect,\n          target\n        }) => {\n          if (target && target !== swiper.el)\n            return;\n          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n        });\n        if (newWidth !== width || newHeight !== height) {\n          resizeHandler();\n        }\n      });\n    });\n    observer.observe(swiper.el);\n  };\n  const removeObserver = () => {\n    if (animationFrame) {\n      window2.cancelAnimationFrame(animationFrame);\n    }\n    if (observer && observer.unobserve && swiper.el) {\n      observer.unobserve(swiper.el);\n      observer = null;\n    }\n  };\n  const orientationChangeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized)\n      return;\n    emit(\"orientationchange\");\n  };\n  on2(\"init\", () => {\n    if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== \"undefined\") {\n      createObserver();\n      return;\n    }\n    window2.addEventListener(\"resize\", resizeHandler);\n    window2.addEventListener(\"orientationchange\", orientationChangeHandler);\n  });\n  on2(\"destroy\", () => {\n    removeObserver();\n    window2.removeEventListener(\"resize\", resizeHandler);\n    window2.removeEventListener(\"orientationchange\", orientationChangeHandler);\n  });\n}\nfunction Observer({\n  swiper,\n  extendParams,\n  on: on2,\n  emit\n}) {\n  const observers = [];\n  const window2 = getWindow();\n  const attach = (target, options = {}) => {\n    const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;\n    const observer = new ObserverFunc((mutations) => {\n      if (mutations.length === 1) {\n        emit(\"observerUpdate\", mutations[0]);\n        return;\n      }\n      const observerUpdate = function observerUpdate2() {\n        emit(\"observerUpdate\", mutations[0]);\n      };\n      if (window2.requestAnimationFrame) {\n        window2.requestAnimationFrame(observerUpdate);\n      } else {\n        window2.setTimeout(observerUpdate, 0);\n      }\n    });\n    observer.observe(target, {\n      attributes: typeof options.attributes === \"undefined\" ? true : options.attributes,\n      childList: typeof options.childList === \"undefined\" ? true : options.childList,\n      characterData: typeof options.characterData === \"undefined\" ? true : options.characterData\n    });\n    observers.push(observer);\n  };\n  const init = () => {\n    if (!swiper.params.observer)\n      return;\n    if (swiper.params.observeParents) {\n      const containerParents = swiper.$el.parents();\n      for (let i = 0; i < containerParents.length; i += 1) {\n        attach(containerParents[i]);\n      }\n    }\n    attach(swiper.$el[0], {\n      childList: swiper.params.observeSlideChildren\n    });\n    attach(swiper.$wrapperEl[0], {\n      attributes: false\n    });\n  };\n  const destroy = () => {\n    observers.forEach((observer) => {\n      observer.disconnect();\n    });\n    observers.splice(0, observers.length);\n  };\n  extendParams({\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false\n  });\n  on2(\"init\", init);\n  on2(\"destroy\", destroy);\n}\nconst eventsEmitter = {\n  on(events2, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (typeof handler !== \"function\")\n      return self;\n    const method = priority ? \"unshift\" : \"push\";\n    events2.split(\" \").forEach((event) => {\n      if (!self.eventsListeners[event])\n        self.eventsListeners[event] = [];\n      self.eventsListeners[event][method](handler);\n    });\n    return self;\n  },\n  once(events2, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (typeof handler !== \"function\")\n      return self;\n    function onceHandler(...args) {\n      self.off(events2, onceHandler);\n      if (onceHandler.__emitterProxy) {\n        delete onceHandler.__emitterProxy;\n      }\n      handler.apply(self, args);\n    }\n    onceHandler.__emitterProxy = handler;\n    return self.on(events2, onceHandler, priority);\n  },\n  onAny(handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (typeof handler !== \"function\")\n      return self;\n    const method = priority ? \"unshift\" : \"push\";\n    if (self.eventsAnyListeners.indexOf(handler) < 0) {\n      self.eventsAnyListeners[method](handler);\n    }\n    return self;\n  },\n  offAny(handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (!self.eventsAnyListeners)\n      return self;\n    const index2 = self.eventsAnyListeners.indexOf(handler);\n    if (index2 >= 0) {\n      self.eventsAnyListeners.splice(index2, 1);\n    }\n    return self;\n  },\n  off(events2, handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (!self.eventsListeners)\n      return self;\n    events2.split(\" \").forEach((event) => {\n      if (typeof handler === \"undefined\") {\n        self.eventsListeners[event] = [];\n      } else if (self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler, index2) => {\n          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n            self.eventsListeners[event].splice(index2, 1);\n          }\n        });\n      }\n    });\n    return self;\n  },\n  emit(...args) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed)\n      return self;\n    if (!self.eventsListeners)\n      return self;\n    let events2;\n    let data;\n    let context;\n    if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n      events2 = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events2 = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n    data.unshift(context);\n    const eventsArray = Array.isArray(events2) ? events2 : events2.split(\" \");\n    eventsArray.forEach((event) => {\n      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n        self.eventsAnyListeners.forEach((eventHandler) => {\n          eventHandler.apply(context, [event, ...data]);\n        });\n      }\n      if (self.eventsListeners && self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler) => {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  }\n};\nfunction updateSize() {\n  const swiper = this;\n  let width;\n  let height;\n  const $el = swiper.$el;\n  if (typeof swiper.params.width !== \"undefined\" && swiper.params.width !== null) {\n    width = swiper.params.width;\n  } else {\n    width = $el[0].clientWidth;\n  }\n  if (typeof swiper.params.height !== \"undefined\" && swiper.params.height !== null) {\n    height = swiper.params.height;\n  } else {\n    height = $el[0].clientHeight;\n  }\n  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n    return;\n  }\n  width = width - parseInt($el.css(\"padding-left\") || 0, 10) - parseInt($el.css(\"padding-right\") || 0, 10);\n  height = height - parseInt($el.css(\"padding-top\") || 0, 10) - parseInt($el.css(\"padding-bottom\") || 0, 10);\n  if (Number.isNaN(width))\n    width = 0;\n  if (Number.isNaN(height))\n    height = 0;\n  Object.assign(swiper, {\n    width,\n    height,\n    size: swiper.isHorizontal() ? width : height\n  });\n}\nfunction updateSlides() {\n  const swiper = this;\n  function getDirectionLabel(property) {\n    if (swiper.isHorizontal()) {\n      return property;\n    }\n    return {\n      \"width\": \"height\",\n      \"margin-top\": \"margin-left\",\n      \"margin-bottom \": \"margin-right\",\n      \"margin-left\": \"margin-top\",\n      \"margin-right\": \"margin-bottom\",\n      \"padding-left\": \"padding-top\",\n      \"padding-right\": \"padding-bottom\",\n      \"marginRight\": \"marginBottom\"\n    }[property];\n  }\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n  }\n  const params = swiper.params;\n  const {\n    $wrapperEl,\n    size: swiperSize,\n    rtlTranslate: rtl,\n    wrongRTL\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === \"function\") {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === \"function\") {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index2 = 0;\n  if (typeof swiperSize === \"undefined\") {\n    return;\n  }\n  if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiperSize;\n  }\n  swiper.virtualSize = -spaceBetween;\n  if (rtl)\n    slides.css({\n      marginLeft: \"\",\n      marginBottom: \"\",\n      marginTop: \"\"\n    });\n  else\n    slides.css({\n      marginRight: \"\",\n      marginBottom: \"\",\n      marginTop: \"\"\n    });\n  if (params.centeredSlides && params.cssMode) {\n    setCSSProperty(swiper.wrapperEl, \"--swiper-centered-offset-before\", \"\");\n    setCSSProperty(swiper.wrapperEl, \"--swiper-centered-offset-after\", \"\");\n  }\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n  if (gridEnabled) {\n    swiper.grid.initSlides(slidesLength);\n  }\n  let slideSize;\n  const shouldResetSlideSize = params.slidesPerView === \"auto\" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {\n    return typeof params.breakpoints[key].slidesPerView !== \"undefined\";\n  }).length > 0;\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    const slide2 = slides.eq(i);\n    if (gridEnabled) {\n      swiper.grid.updateSlide(i, slide2, slidesLength, getDirectionLabel);\n    }\n    if (slide2.css(\"display\") === \"none\")\n      continue;\n    if (params.slidesPerView === \"auto\") {\n      if (shouldResetSlideSize) {\n        slides[i].style[getDirectionLabel(\"width\")] = ``;\n      }\n      const slideStyles = getComputedStyle(slide2[0]);\n      const currentTransform = slide2[0].style.transform;\n      const currentWebKitTransform = slide2[0].style.webkitTransform;\n      if (currentTransform) {\n        slide2[0].style.transform = \"none\";\n      }\n      if (currentWebKitTransform) {\n        slide2[0].style.webkitTransform = \"none\";\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal() ? slide2.outerWidth(true) : slide2.outerHeight(true);\n      } else {\n        const width = getDirectionPropertyValue(slideStyles, \"width\");\n        const paddingLeft = getDirectionPropertyValue(slideStyles, \"padding-left\");\n        const paddingRight = getDirectionPropertyValue(slideStyles, \"padding-right\");\n        const marginLeft = getDirectionPropertyValue(slideStyles, \"margin-left\");\n        const marginRight = getDirectionPropertyValue(slideStyles, \"margin-right\");\n        const boxSizing = slideStyles.getPropertyValue(\"box-sizing\");\n        if (boxSizing && boxSizing === \"border-box\") {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const {\n            clientWidth,\n            offsetWidth\n          } = slide2[0];\n          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n        }\n      }\n      if (currentTransform) {\n        slide2[0].style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide2[0].style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths)\n        slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths)\n        slideSize = Math.floor(slideSize);\n      if (slides[i]) {\n        slides[i].style[getDirectionLabel(\"width\")] = `${slideSize}px`;\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0)\n        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0)\n        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1e3)\n        slidePosition = 0;\n      if (params.roundLengths)\n        slidePosition = Math.floor(slidePosition);\n      if (index2 % params.slidesPerGroup === 0)\n        snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths)\n        slidePosition = Math.floor(slidePosition);\n      if ((index2 - Math.min(swiper.params.slidesPerGroupSkip, index2)) % swiper.params.slidesPerGroup === 0)\n        snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n    swiper.virtualSize += slideSize + spaceBetween;\n    prevSlideSize = slideSize;\n    index2 += 1;\n  }\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n  if (rtl && wrongRTL && (params.effect === \"slide\" || params.effect === \"coverflow\")) {\n    $wrapperEl.css({\n      width: `${swiper.virtualSize + params.spaceBetween}px`\n    });\n  }\n  if (params.setWrapperSize) {\n    $wrapperEl.css({\n      [getDirectionLabel(\"width\")]: `${swiper.virtualSize + params.spaceBetween}px`\n    });\n  }\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n  }\n  if (!params.centeredSlides) {\n    const newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths)\n        slidesGridItem = Math.floor(slidesGridItem);\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (snapGrid.length === 0)\n    snapGrid = [0];\n  if (params.spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? \"marginLeft\" : getDirectionLabel(\"marginRight\");\n    slides.filter((_, slideIndex) => {\n      if (!params.cssMode)\n        return true;\n      if (slideIndex === slides.length - 1) {\n        return false;\n      }\n      return true;\n    }).css({\n      [key]: `${spaceBetween}px`\n    });\n  }\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map((snap) => {\n      if (snap < 0)\n        return -offsetBefore;\n      if (snap > maxSnap)\n        return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid\n  });\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    setCSSProperty(swiper.wrapperEl, \"--swiper-centered-offset-before\", `${-snapGrid[0]}px`);\n    setCSSProperty(swiper.wrapperEl, \"--swiper-centered-offset-after\", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);\n  }\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit(\"slidesLengthChange\");\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow)\n      swiper.checkOverflow();\n    swiper.emit(\"snapGridLengthChange\");\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit(\"slidesGridLengthChange\");\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  if (!isVirtual && !params.cssMode && (params.effect === \"slide\" || params.effect === \"fade\")) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded)\n        swiper.$el.addClass(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.$el.removeClass(backFaceHiddenClass);\n    }\n  }\n}\nfunction updateAutoHeight(speed) {\n  const swiper = this;\n  const activeSlides = [];\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  let newHeight = 0;\n  let i;\n  if (typeof speed === \"number\") {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n  const getSlideByIndex = (index2) => {\n    if (isVirtual) {\n      return swiper.slides.filter((el) => parseInt(el.getAttribute(\"data-swiper-slide-index\"), 10) === index2)[0];\n    }\n    return swiper.slides.eq(index2)[0];\n  };\n  if (swiper.params.slidesPerView !== \"auto\" && swiper.params.slidesPerView > 1) {\n    if (swiper.params.centeredSlides) {\n      (swiper.visibleSlides || $([])).each((slide2) => {\n        activeSlides.push(slide2);\n      });\n    } else {\n      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n        const index2 = swiper.activeIndex + i;\n        if (index2 > swiper.slides.length && !isVirtual)\n          break;\n        activeSlides.push(getSlideByIndex(index2));\n      }\n    }\n  } else {\n    activeSlides.push(getSlideByIndex(swiper.activeIndex));\n  }\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== \"undefined\") {\n      const height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n  if (newHeight || newHeight === 0)\n    swiper.$wrapperEl.css(\"height\", `${newHeight}px`);\n}\nfunction updateSlidesOffset() {\n  const swiper = this;\n  const slides = swiper.slides;\n  for (let i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;\n  }\n}\nfunction updateSlidesProgress(translate2 = this && this.translate || 0) {\n  const swiper = this;\n  const params = swiper.params;\n  const {\n    slides,\n    rtlTranslate: rtl,\n    snapGrid\n  } = swiper;\n  if (slides.length === 0)\n    return;\n  if (typeof slides[0].swiperSlideOffset === \"undefined\")\n    swiper.updateSlidesOffset();\n  let offsetCenter = -translate2;\n  if (rtl)\n    offsetCenter = translate2;\n  slides.removeClass(params.slideVisibleClass);\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n  for (let i = 0; i < slides.length; i += 1) {\n    const slide2 = slides[i];\n    let slideOffset = slide2.swiperSlideOffset;\n    if (params.cssMode && params.centeredSlides) {\n      slideOffset -= slides[0].swiperSlideOffset;\n    }\n    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + params.spaceBetween);\n    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + params.spaceBetween);\n    const slideBefore = -(offsetCenter - slideOffset);\n    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n    if (isVisible) {\n      swiper.visibleSlides.push(slide2);\n      swiper.visibleSlidesIndexes.push(i);\n      slides.eq(i).addClass(params.slideVisibleClass);\n    }\n    slide2.progress = rtl ? -slideProgress : slideProgress;\n    slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n  }\n  swiper.visibleSlides = $(swiper.visibleSlides);\n}\nfunction updateProgress(translate2) {\n  const swiper = this;\n  if (typeof translate2 === \"undefined\") {\n    const multiplier = swiper.rtlTranslate ? -1 : 1;\n    translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;\n  }\n  const params = swiper.params;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  let {\n    progress,\n    isBeginning,\n    isEnd\n  } = swiper;\n  const wasBeginning = isBeginning;\n  const wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate2 - swiper.minTranslate()) / translatesDiff;\n    isBeginning = progress <= 0;\n    isEnd = progress >= 1;\n  }\n  Object.assign(swiper, {\n    progress,\n    isBeginning,\n    isEnd\n  });\n  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)\n    swiper.updateSlidesProgress(translate2);\n  if (isBeginning && !wasBeginning) {\n    swiper.emit(\"reachBeginning toEdge\");\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit(\"reachEnd toEdge\");\n  }\n  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n    swiper.emit(\"fromEdge\");\n  }\n  swiper.emit(\"progress\", progress);\n}\nfunction updateSlidesClasses() {\n  const swiper = this;\n  const {\n    slides,\n    params,\n    $wrapperEl,\n    activeIndex,\n    realIndex\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);\n  let activeSlide;\n  if (isVirtual) {\n    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index=\"${activeIndex}\"]`);\n  } else {\n    activeSlide = slides.eq(activeIndex);\n  }\n  activeSlide.addClass(params.slideActiveClass);\n  if (params.loop) {\n    if (activeSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${realIndex}\"]`).addClass(params.slideDuplicateActiveClass);\n    } else {\n      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${realIndex}\"]`).addClass(params.slideDuplicateActiveClass);\n    }\n  }\n  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);\n  if (params.loop && nextSlide.length === 0) {\n    nextSlide = slides.eq(0);\n    nextSlide.addClass(params.slideNextClass);\n  }\n  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);\n  if (params.loop && prevSlide.length === 0) {\n    prevSlide = slides.eq(-1);\n    prevSlide.addClass(params.slidePrevClass);\n  }\n  if (params.loop) {\n    if (nextSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${nextSlide.attr(\"data-swiper-slide-index\")}\"]`).addClass(params.slideDuplicateNextClass);\n    } else {\n      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${nextSlide.attr(\"data-swiper-slide-index\")}\"]`).addClass(params.slideDuplicateNextClass);\n    }\n    if (prevSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${prevSlide.attr(\"data-swiper-slide-index\")}\"]`).addClass(params.slideDuplicatePrevClass);\n    } else {\n      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${prevSlide.attr(\"data-swiper-slide-index\")}\"]`).addClass(params.slideDuplicatePrevClass);\n    }\n  }\n  swiper.emitSlidesClasses();\n}\nfunction updateActiveIndex(newActiveIndex) {\n  const swiper = this;\n  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  const {\n    slidesGrid,\n    snapGrid,\n    params,\n    activeIndex: previousIndex,\n    realIndex: previousRealIndex,\n    snapIndex: previousSnapIndex\n  } = swiper;\n  let activeIndex = newActiveIndex;\n  let snapIndex;\n  if (typeof activeIndex === \"undefined\") {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      if (typeof slidesGrid[i + 1] !== \"undefined\") {\n        if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n          activeIndex = i;\n        } else if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1]) {\n          activeIndex = i + 1;\n        }\n      } else if (translate2 >= slidesGrid[i]) {\n        activeIndex = i;\n      }\n    }\n    if (params.normalizeSlideIndex) {\n      if (activeIndex < 0 || typeof activeIndex === \"undefined\")\n        activeIndex = 0;\n    }\n  }\n  if (snapGrid.indexOf(translate2) >= 0) {\n    snapIndex = snapGrid.indexOf(translate2);\n  } else {\n    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length)\n    snapIndex = snapGrid.length - 1;\n  if (activeIndex === previousIndex) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit(\"snapIndexChange\");\n    }\n    return;\n  }\n  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr(\"data-swiper-slide-index\") || activeIndex, 10);\n  Object.assign(swiper, {\n    snapIndex,\n    realIndex,\n    previousIndex,\n    activeIndex\n  });\n  swiper.emit(\"activeIndexChange\");\n  swiper.emit(\"snapIndexChange\");\n  if (previousRealIndex !== realIndex) {\n    swiper.emit(\"realIndexChange\");\n  }\n  if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n    swiper.emit(\"slideChange\");\n  }\n}\nfunction updateClickedSlide(e) {\n  const swiper = this;\n  const params = swiper.params;\n  const slide2 = $(e).closest(`.${params.slideClass}`)[0];\n  let slideFound = false;\n  let slideIndex;\n  if (slide2) {\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide2) {\n        slideFound = true;\n        slideIndex = i;\n        break;\n      }\n    }\n  }\n  if (slide2 && slideFound) {\n    swiper.clickedSlide = slide2;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt($(slide2).attr(\"data-swiper-slide-index\"), 10);\n    } else {\n      swiper.clickedIndex = slideIndex;\n    }\n  } else {\n    swiper.clickedSlide = void 0;\n    swiper.clickedIndex = void 0;\n    return;\n  }\n  if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {\n    swiper.slideToClickedSlide();\n  }\n}\nconst update = {\n  updateSize,\n  updateSlides,\n  updateAutoHeight,\n  updateSlidesOffset,\n  updateSlidesProgress,\n  updateProgress,\n  updateSlidesClasses,\n  updateActiveIndex,\n  updateClickedSlide\n};\nfunction getSwiperTranslate(axis = this.isHorizontal() ? \"x\" : \"y\") {\n  const swiper = this;\n  const {\n    params,\n    rtlTranslate: rtl,\n    translate: translate2,\n    $wrapperEl\n  } = swiper;\n  if (params.virtualTranslate) {\n    return rtl ? -translate2 : translate2;\n  }\n  if (params.cssMode) {\n    return translate2;\n  }\n  let currentTranslate = getTranslate($wrapperEl[0], axis);\n  if (rtl)\n    currentTranslate = -currentTranslate;\n  return currentTranslate || 0;\n}\nfunction setTranslate(translate2, byController) {\n  const swiper = this;\n  const {\n    rtlTranslate: rtl,\n    params,\n    $wrapperEl,\n    wrapperEl,\n    progress\n  } = swiper;\n  let x = 0;\n  let y = 0;\n  const z = 0;\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate2 : translate2;\n  } else {\n    y = translate2;\n  }\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n  if (params.cssMode) {\n    wrapperEl[swiper.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = swiper.isHorizontal() ? -x : -y;\n  } else if (!params.virtualTranslate) {\n    $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);\n  }\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y;\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate2);\n  }\n  swiper.emit(\"setTranslate\", swiper.translate, byController);\n}\nfunction minTranslate() {\n  return -this.snapGrid[0];\n}\nfunction maxTranslate() {\n  return -this.snapGrid[this.snapGrid.length - 1];\n}\nfunction translateTo(translate2 = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {\n  const swiper = this;\n  const {\n    params,\n    wrapperEl\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n  const minTranslate2 = swiper.minTranslate();\n  const maxTranslate2 = swiper.maxTranslate();\n  let newTranslate;\n  if (translateBounds && translate2 > minTranslate2)\n    newTranslate = minTranslate2;\n  else if (translateBounds && translate2 < maxTranslate2)\n    newTranslate = maxTranslate2;\n  else\n    newTranslate = translate2;\n  swiper.updateProgress(newTranslate);\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    if (speed === 0) {\n      wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = -newTranslate;\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: -newTranslate,\n          side: isH ? \"left\" : \"top\"\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? \"left\" : \"top\"]: -newTranslate,\n        behavior: \"smooth\"\n      });\n    }\n    return true;\n  }\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit(\"beforeTransitionStart\", speed, internal);\n      swiper.emit(\"transitionEnd\");\n    }\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit(\"beforeTransitionStart\", speed, internal);\n      swiper.emit(\"transitionStart\");\n    }\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onTranslateToWrapperTransitionEnd) {\n        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e) {\n          if (!swiper || swiper.destroyed)\n            return;\n          if (e.target !== this)\n            return;\n          swiper.$wrapperEl[0].removeEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener(\"webkitTransitionEnd\", swiper.onTranslateToWrapperTransitionEnd);\n          swiper.onTranslateToWrapperTransitionEnd = null;\n          delete swiper.onTranslateToWrapperTransitionEnd;\n          if (runCallbacks) {\n            swiper.emit(\"transitionEnd\");\n          }\n        };\n      }\n      swiper.$wrapperEl[0].addEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener(\"webkitTransitionEnd\", swiper.onTranslateToWrapperTransitionEnd);\n    }\n  }\n  return true;\n}\nconst translate = {\n  getTranslate: getSwiperTranslate,\n  setTranslate,\n  minTranslate,\n  maxTranslate,\n  translateTo\n};\nfunction setTransition(duration, byController) {\n  const swiper = this;\n  if (!swiper.params.cssMode) {\n    swiper.$wrapperEl.transition(duration);\n  }\n  swiper.emit(\"setTransition\", duration, byController);\n}\nfunction transitionEmit({\n  swiper,\n  runCallbacks,\n  direction,\n  step\n}) {\n  const {\n    activeIndex,\n    previousIndex\n  } = swiper;\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex)\n      dir = \"next\";\n    else if (activeIndex < previousIndex)\n      dir = \"prev\";\n    else\n      dir = \"reset\";\n  }\n  swiper.emit(`transition${step}`);\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === \"reset\") {\n      swiper.emit(`slideResetTransition${step}`);\n      return;\n    }\n    swiper.emit(`slideChangeTransition${step}`);\n    if (dir === \"next\") {\n      swiper.emit(`slideNextTransition${step}`);\n    } else {\n      swiper.emit(`slidePrevTransition${step}`);\n    }\n  }\n}\nfunction transitionStart(runCallbacks = true, direction) {\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  if (params.cssMode)\n    return;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n  transitionEmit({\n    swiper,\n    runCallbacks,\n    direction,\n    step: \"Start\"\n  });\n}\nfunction transitionEnd(runCallbacks = true, direction) {\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  swiper.animating = false;\n  if (params.cssMode)\n    return;\n  swiper.setTransition(0);\n  transitionEmit({\n    swiper,\n    runCallbacks,\n    direction,\n    step: \"End\"\n  });\n}\nconst transition = {\n  setTransition,\n  transitionStart,\n  transitionEnd\n};\nfunction slideTo(index2 = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {\n  if (typeof index2 !== \"number\" && typeof index2 !== \"string\") {\n    throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index2}] given.`);\n  }\n  if (typeof index2 === \"string\") {\n    const indexAsNumber = parseInt(index2, 10);\n    const isValidNumber = isFinite(indexAsNumber);\n    if (!isValidNumber) {\n      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);\n    }\n    index2 = indexAsNumber;\n  }\n  const swiper = this;\n  let slideIndex = index2;\n  if (slideIndex < 0)\n    slideIndex = 0;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl,\n    enabled\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n    return false;\n  }\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length)\n    snapIndex = snapGrid.length - 1;\n  const translate2 = -snapGrid[snapIndex];\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      const normalizedTranslate = -Math.floor(translate2 * 100);\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n      if (typeof slidesGrid[i + 1] !== \"undefined\") {\n        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  }\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && translate2 < swiper.translate && translate2 < swiper.minTranslate()) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex)\n        return false;\n    }\n  }\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit(\"beforeSlideChangeStart\");\n  }\n  swiper.updateProgress(translate2);\n  let direction;\n  if (slideIndex > activeIndex)\n    direction = \"next\";\n  else if (slideIndex < activeIndex)\n    direction = \"prev\";\n  else\n    direction = \"reset\";\n  if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex);\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== \"slide\") {\n      swiper.setTranslate(translate2);\n    }\n    if (direction !== \"reset\") {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    const t = rtl ? translate2 : -translate2;\n    if (speed === 0) {\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = \"none\";\n        swiper._immediateVirtual = true;\n      }\n      wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n      if (isVirtual) {\n        requestAnimationFrame(() => {\n          swiper.wrapperEl.style.scrollSnapType = \"\";\n          swiper._swiperImmediateVirtual = false;\n        });\n      }\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: t,\n          side: isH ? \"left\" : \"top\"\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? \"left\" : \"top\"]: t,\n        behavior: \"smooth\"\n      });\n    }\n    return true;\n  }\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate2);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit(\"beforeTransitionStart\", speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e) {\n        if (!swiper || swiper.destroyed)\n          return;\n        if (e.target !== this)\n          return;\n        swiper.$wrapperEl[0].removeEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n        swiper.$wrapperEl[0].removeEventListener(\"webkitTransitionEnd\", swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n    swiper.$wrapperEl[0].addEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n    swiper.$wrapperEl[0].addEventListener(\"webkitTransitionEnd\", swiper.onSlideToWrapperTransitionEnd);\n  }\n  return true;\n}\nfunction slideToLoop(index2 = 0, speed = this.params.speed, runCallbacks = true, internal) {\n  if (typeof index2 === \"string\") {\n    const indexAsNumber = parseInt(index2, 10);\n    const isValidNumber = isFinite(indexAsNumber);\n    if (!isValidNumber) {\n      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);\n    }\n    index2 = indexAsNumber;\n  }\n  const swiper = this;\n  let newIndex = index2;\n  if (swiper.params.loop) {\n    newIndex += swiper.loopedSlides;\n  }\n  return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n}\nfunction slideNext(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const {\n    animating,\n    enabled,\n    params\n  } = swiper;\n  if (!enabled)\n    return swiper;\n  let perGroup = params.slidesPerGroup;\n  if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n    perGroup = Math.max(swiper.slidesPerViewDynamic(\"current\", true), 1);\n  }\n  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n  if (params.loop) {\n    if (animating && params.loopPreventsSlide)\n      return false;\n    swiper.loopFix();\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n  }\n  if (params.rewind && swiper.isEnd) {\n    return swiper.slideTo(0, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\nfunction slidePrev(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const {\n    params,\n    animating,\n    snapGrid,\n    slidesGrid,\n    rtlTranslate,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return swiper;\n  if (params.loop) {\n    if (animating && params.loopPreventsSlide)\n      return false;\n    swiper.loopFix();\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n  }\n  const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;\n  function normalize(val) {\n    if (val < 0)\n      return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n  const normalizedTranslate = normalize(translate2);\n  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));\n  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n  if (typeof prevSnap === \"undefined\" && params.cssMode) {\n    let prevSnapIndex;\n    snapGrid.forEach((snap, snapIndex) => {\n      if (normalizedTranslate >= snap) {\n        prevSnapIndex = snapIndex;\n      }\n    });\n    if (typeof prevSnapIndex !== \"undefined\") {\n      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n    }\n  }\n  let prevIndex = 0;\n  if (typeof prevSnap !== \"undefined\") {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0)\n      prevIndex = swiper.activeIndex - 1;\n    if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n      prevIndex = prevIndex - swiper.slidesPerViewDynamic(\"previous\", true) + 1;\n      prevIndex = Math.max(prevIndex, 0);\n    }\n  }\n  if (params.rewind && swiper.isBeginning) {\n    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\nfunction slideReset(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\nfunction slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {\n  const swiper = this;\n  let index2 = swiper.activeIndex;\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, index2);\n  const snapIndex = skip + Math.floor((index2 - skip) / swiper.params.slidesPerGroup);\n  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  if (translate2 >= swiper.snapGrid[snapIndex]) {\n    const currentSnap = swiper.snapGrid[snapIndex];\n    const nextSnap = swiper.snapGrid[snapIndex + 1];\n    if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {\n      index2 += swiper.params.slidesPerGroup;\n    }\n  } else {\n    const prevSnap = swiper.snapGrid[snapIndex - 1];\n    const currentSnap = swiper.snapGrid[snapIndex];\n    if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {\n      index2 -= swiper.params.slidesPerGroup;\n    }\n  }\n  index2 = Math.max(index2, 0);\n  index2 = Math.min(index2, swiper.slidesGrid.length - 1);\n  return swiper.slideTo(index2, speed, runCallbacks, internal);\n}\nfunction slideToClickedSlide() {\n  const swiper = this;\n  const {\n    params,\n    $wrapperEl\n  } = swiper;\n  const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  let slideToIndex = swiper.clickedIndex;\n  let realIndex;\n  if (params.loop) {\n    if (swiper.animating)\n      return;\n    realIndex = parseInt($(swiper.clickedSlide).attr(\"data-swiper-slide-index\"), 10);\n    if (params.centeredSlides) {\n      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n        swiper.loopFix();\n        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`).eq(0).index();\n        nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`).eq(0).index();\n      nextTick(() => {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\nconst slide = {\n  slideTo,\n  slideToLoop,\n  slideNext,\n  slidePrev,\n  slideReset,\n  slideToClosest,\n  slideToClickedSlide\n};\nfunction loopCreate() {\n  const swiper = this;\n  const document2 = getDocument();\n  const {\n    params,\n    $wrapperEl\n  } = swiper;\n  const $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;\n  $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();\n  let slides = $selector.children(`.${params.slideClass}`);\n  if (params.loopFillGroupWithBlank) {\n    const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;\n    if (blankSlidesNum !== params.slidesPerGroup) {\n      for (let i = 0; i < blankSlidesNum; i += 1) {\n        const blankNode = $(document2.createElement(\"div\")).addClass(`${params.slideClass} ${params.slideBlankClass}`);\n        $selector.append(blankNode);\n      }\n      slides = $selector.children(`.${params.slideClass}`);\n    }\n  }\n  if (params.slidesPerView === \"auto\" && !params.loopedSlides)\n    params.loopedSlides = slides.length;\n  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));\n  swiper.loopedSlides += params.loopAdditionalSlides;\n  if (swiper.loopedSlides > slides.length && swiper.params.loopedSlidesLimit) {\n    swiper.loopedSlides = slides.length;\n  }\n  const prependSlides = [];\n  const appendSlides = [];\n  slides.each((el, index2) => {\n    const slide2 = $(el);\n    slide2.attr(\"data-swiper-slide-index\", index2);\n  });\n  for (let i = 0; i < swiper.loopedSlides; i += 1) {\n    const index2 = i - Math.floor(i / slides.length) * slides.length;\n    appendSlides.push(slides.eq(index2)[0]);\n    prependSlides.unshift(slides.eq(slides.length - index2 - 1)[0]);\n  }\n  for (let i = 0; i < appendSlides.length; i += 1) {\n    $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {\n    $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n}\nfunction loopFix() {\n  const swiper = this;\n  swiper.emit(\"beforeLoopFix\");\n  const {\n    activeIndex,\n    slides,\n    loopedSlides,\n    allowSlidePrev,\n    allowSlideNext,\n    snapGrid,\n    rtlTranslate: rtl\n  } = swiper;\n  let newIndex;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n  const snapTranslate = -snapGrid[activeIndex];\n  const diff = snapTranslate - swiper.getTranslate();\n  if (activeIndex < loopedSlides) {\n    newIndex = slides.length - loopedSlides * 3 + activeIndex;\n    newIndex += loopedSlides;\n    const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n    if (slideChanged && diff !== 0) {\n      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n    }\n  } else if (activeIndex >= slides.length - loopedSlides) {\n    newIndex = -slides.length + activeIndex + loopedSlides;\n    newIndex += loopedSlides;\n    const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n    if (slideChanged && diff !== 0) {\n      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n    }\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  swiper.emit(\"loopFix\");\n}\nfunction loopDestroy() {\n  const swiper = this;\n  const {\n    $wrapperEl,\n    params,\n    slides\n  } = swiper;\n  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();\n  slides.removeAttr(\"data-swiper-slide-index\");\n}\nconst loop = {\n  loopCreate,\n  loopFix,\n  loopDestroy\n};\nfunction setGrabCursor(moving) {\n  const swiper = this;\n  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)\n    return;\n  const el = swiper.params.touchEventsTarget === \"container\" ? swiper.el : swiper.wrapperEl;\n  el.style.cursor = \"move\";\n  el.style.cursor = moving ? \"grabbing\" : \"grab\";\n}\nfunction unsetGrabCursor() {\n  const swiper = this;\n  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n    return;\n  }\n  swiper[swiper.params.touchEventsTarget === \"container\" ? \"el\" : \"wrapperEl\"].style.cursor = \"\";\n}\nconst grabCursor = {\n  setGrabCursor,\n  unsetGrabCursor\n};\nfunction closestElement(selector, base = this) {\n  function __closestFrom(el) {\n    if (!el || el === getDocument() || el === getWindow())\n      return null;\n    if (el.assignedSlot)\n      el = el.assignedSlot;\n    const found = el.closest(selector);\n    if (!found && !el.getRootNode) {\n      return null;\n    }\n    return found || __closestFrom(el.getRootNode().host);\n  }\n  return __closestFrom(base);\n}\nfunction onTouchStart(event) {\n  const swiper = this;\n  const document2 = getDocument();\n  const window2 = getWindow();\n  const data = swiper.touchEventsData;\n  const {\n    params,\n    touches,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n  if (!swiper.animating && params.cssMode && params.loop) {\n    swiper.loopFix();\n  }\n  let e = event;\n  if (e.originalEvent)\n    e = e.originalEvent;\n  let $targetEl = $(e.target);\n  if (params.touchEventsTarget === \"wrapper\") {\n    if (!$targetEl.closest(swiper.wrapperEl).length)\n      return;\n  }\n  data.isTouchEvent = e.type === \"touchstart\";\n  if (!data.isTouchEvent && \"which\" in e && e.which === 3)\n    return;\n  if (!data.isTouchEvent && \"button\" in e && e.button > 0)\n    return;\n  if (data.isTouched && data.isMoved)\n    return;\n  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== \"\";\n  const eventPath = event.composedPath ? event.composedPath() : event.path;\n  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n    $targetEl = $(eventPath[0]);\n  }\n  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n  const isTargetShadow = !!(e.target && e.target.shadowRoot);\n  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {\n    swiper.allowClick = true;\n    return;\n  }\n  if (params.swipeHandler) {\n    if (!$targetEl.closest(params.swipeHandler)[0])\n      return;\n  }\n  touches.currentX = e.type === \"touchstart\" ? e.targetTouches[0].pageX : e.pageX;\n  touches.currentY = e.type === \"touchstart\" ? e.targetTouches[0].pageY : e.pageY;\n  const startX = touches.currentX;\n  const startY = touches.currentY;\n  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {\n    if (edgeSwipeDetection === \"prevent\") {\n      event.preventDefault();\n    } else {\n      return;\n    }\n  }\n  Object.assign(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: void 0,\n    startMoving: void 0\n  });\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = now();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = void 0;\n  if (params.threshold > 0)\n    data.allowThresholdMove = false;\n  if (e.type !== \"touchstart\") {\n    let preventDefault = true;\n    if ($targetEl.is(data.focusableElements)) {\n      preventDefault = false;\n      if ($targetEl[0].nodeName === \"SELECT\") {\n        data.isTouched = false;\n      }\n    }\n    if (document2.activeElement && $(document2.activeElement).is(data.focusableElements) && document2.activeElement !== $targetEl[0]) {\n      document2.activeElement.blur();\n    }\n    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {\n      e.preventDefault();\n    }\n  }\n  if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n    swiper.freeMode.onTouchStart();\n  }\n  swiper.emit(\"touchStart\", e);\n}\nfunction onTouchMove(event) {\n  const document2 = getDocument();\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return;\n  let e = event;\n  if (e.originalEvent)\n    e = e.originalEvent;\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit(\"touchMoveOpposite\", e);\n    }\n    return;\n  }\n  if (data.isTouchEvent && e.type !== \"touchmove\")\n    return;\n  const targetTouch = e.type === \"touchmove\" && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);\n  const pageX = e.type === \"touchmove\" ? targetTouch.pageX : e.pageX;\n  const pageY = e.type === \"touchmove\" ? targetTouch.pageY : e.pageY;\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    if (!$(e.target).is(data.focusableElements)) {\n      swiper.allowClick = false;\n    }\n    if (data.isTouched) {\n      Object.assign(touches, {\n        startX: pageX,\n        startY: pageY,\n        currentX: pageX,\n        currentY: pageY\n      });\n      data.touchStartTime = now();\n    }\n    return;\n  }\n  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n      return;\n    }\n  }\n  if (data.isTouchEvent && document2.activeElement) {\n    if (e.target === document2.activeElement && $(e.target).is(data.focusableElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit(\"touchMove\", e);\n  }\n  if (e.targetTouches && e.targetTouches.length > 1)\n    return;\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n  const diffX = touches.currentX - touches.startX;\n  const diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)\n    return;\n  if (typeof data.isScrolling === \"undefined\") {\n    let touchAngle;\n    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n      data.isScrolling = false;\n    } else {\n      if (diffX * diffX + diffY * diffY >= 25) {\n        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit(\"touchMoveOpposite\", e);\n  }\n  if (typeof data.startMoving === \"undefined\") {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (data.isScrolling) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  if (!params.cssMode && e.cancelable) {\n    e.preventDefault();\n  }\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n  if (!data.isMoved) {\n    if (params.loop && !params.cssMode) {\n      swiper.loopFix();\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      swiper.$wrapperEl.trigger(\"webkitTransitionEnd transitionend\");\n    }\n    data.allowMomentumBounce = false;\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit(\"sliderFirstMove\", e);\n  }\n  swiper.emit(\"sliderMove\", e);\n  data.isMoved = true;\n  let diff = swiper.isHorizontal() ? diffX : diffY;\n  touches.diff = diff;\n  diff *= params.touchRatio;\n  if (rtl)\n    diff = -diff;\n  swiper.swipeDirection = diff > 0 ? \"prev\" : \"next\";\n  data.currentTranslate = diff + data.startTranslate;\n  let disableParentSwiper = true;\n  let resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {\n    disableParentSwiper = false;\n    if (params.resistance)\n      data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {\n    disableParentSwiper = false;\n    if (params.resistance)\n      data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n  }\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n  if (!swiper.allowSlideNext && swiper.swipeDirection === \"next\" && data.currentTranslate < data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && swiper.swipeDirection === \"prev\" && data.currentTranslate > data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n  if (!params.followFinger || params.cssMode)\n    return;\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n    swiper.freeMode.onTouchMove();\n  }\n  swiper.updateProgress(data.currentTranslate);\n  swiper.setTranslate(data.currentTranslate);\n}\nfunction onTouchEnd(event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    slidesGrid,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return;\n  let e = event;\n  if (e.originalEvent)\n    e = e.originalEvent;\n  if (data.allowTouchCallbacks) {\n    swiper.emit(\"touchEnd\", e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  }\n  const touchEndTime = now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n  if (swiper.allowClick) {\n    const pathTree = e.path || e.composedPath && e.composedPath();\n    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n    swiper.emit(\"tap click\", e);\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit(\"doubleTap doubleClick\", e);\n    }\n  }\n  data.lastClickTime = now();\n  nextTick(() => {\n    if (!swiper.destroyed)\n      swiper.allowClick = true;\n  });\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n  if (params.cssMode) {\n    return;\n  }\n  if (swiper.params.freeMode && params.freeMode.enabled) {\n    swiper.freeMode.onTouchEnd({\n      currentPos\n    });\n    return;\n  }\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (typeof slidesGrid[i + increment2] !== \"undefined\") {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment2] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n  let rewindFirstIndex = null;\n  let rewindLastIndex = null;\n  if (params.rewind) {\n    if (swiper.isBeginning) {\n      rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    } else if (swiper.isEnd) {\n      rewindFirstIndex = 0;\n    }\n  }\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n  if (timeDiff > params.longSwipesMs) {\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === \"next\") {\n      if (ratio >= params.longSwipesRatio)\n        swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n      else\n        swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === \"prev\") {\n      if (ratio > 1 - params.longSwipesRatio) {\n        swiper.slideTo(stopIndex + increment);\n      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n        swiper.slideTo(rewindLastIndex);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  } else {\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === \"next\") {\n        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n      }\n      if (swiper.swipeDirection === \"prev\") {\n        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\nfunction onResize() {\n  const swiper = this;\n  const {\n    params,\n    el\n  } = swiper;\n  if (el && el.offsetWidth === 0)\n    return;\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n  const {\n    allowSlideNext,\n    allowSlidePrev,\n    snapGrid\n  } = swiper;\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n  swiper.updateSize();\n  swiper.updateSlides();\n  swiper.updateSlidesClasses();\n  if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {\n    swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n  } else {\n    swiper.slideTo(swiper.activeIndex, 0, false, true);\n  }\n  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n    swiper.autoplay.run();\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\nfunction onClick(e) {\n  const swiper = this;\n  if (!swiper.enabled)\n    return;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks)\n      e.preventDefault();\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\nfunction onScroll() {\n  const swiper = this;\n  const {\n    wrapperEl,\n    rtlTranslate,\n    enabled\n  } = swiper;\n  if (!enabled)\n    return;\n  swiper.previousTranslate = swiper.translate;\n  if (swiper.isHorizontal()) {\n    swiper.translate = -wrapperEl.scrollLeft;\n  } else {\n    swiper.translate = -wrapperEl.scrollTop;\n  }\n  if (swiper.translate === 0)\n    swiper.translate = 0;\n  swiper.updateActiveIndex();\n  swiper.updateSlidesClasses();\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== swiper.progress) {\n    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n  }\n  swiper.emit(\"setTranslate\", swiper.translate, false);\n}\nlet dummyEventAttached = false;\nfunction dummyEventListener() {\n}\nconst events = (swiper, method) => {\n  const document2 = getDocument();\n  const {\n    params,\n    touchEvents,\n    el,\n    wrapperEl,\n    device,\n    support: support2\n  } = swiper;\n  const capture = !!params.nested;\n  const domMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n  const swiperMethod = method;\n  if (!support2.touch) {\n    el[domMethod](touchEvents.start, swiper.onTouchStart, false);\n    document2[domMethod](touchEvents.move, swiper.onTouchMove, capture);\n    document2[domMethod](touchEvents.end, swiper.onTouchEnd, false);\n  } else {\n    const passiveListener = touchEvents.start === \"touchstart\" && support2.passiveListener && params.passiveListeners ? {\n      passive: true,\n      capture: false\n    } : false;\n    el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);\n    el[domMethod](touchEvents.move, swiper.onTouchMove, support2.passiveListener ? {\n      passive: false,\n      capture\n    } : capture);\n    el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);\n    if (touchEvents.cancel) {\n      el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);\n    }\n  }\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el[domMethod](\"click\", swiper.onClick, true);\n  }\n  if (params.cssMode) {\n    wrapperEl[domMethod](\"scroll\", swiper.onScroll);\n  }\n  if (params.updateOnWindowResize) {\n    swiper[swiperMethod](device.ios || device.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", onResize, true);\n  } else {\n    swiper[swiperMethod](\"observerUpdate\", onResize, true);\n  }\n};\nfunction attachEvents() {\n  const swiper = this;\n  const document2 = getDocument();\n  const {\n    params,\n    support: support2\n  } = swiper;\n  swiper.onTouchStart = onTouchStart.bind(swiper);\n  swiper.onTouchMove = onTouchMove.bind(swiper);\n  swiper.onTouchEnd = onTouchEnd.bind(swiper);\n  if (params.cssMode) {\n    swiper.onScroll = onScroll.bind(swiper);\n  }\n  swiper.onClick = onClick.bind(swiper);\n  if (support2.touch && !dummyEventAttached) {\n    document2.addEventListener(\"touchstart\", dummyEventListener);\n    dummyEventAttached = true;\n  }\n  events(swiper, \"on\");\n}\nfunction detachEvents() {\n  const swiper = this;\n  events(swiper, \"off\");\n}\nconst events$1 = {\n  attachEvents,\n  detachEvents\n};\nconst isGridEnabled = (swiper, params) => {\n  return swiper.grid && params.grid && params.grid.rows > 1;\n};\nfunction setBreakpoint() {\n  const swiper = this;\n  const {\n    activeIndex,\n    initialized,\n    loopedSlides = 0,\n    params,\n    $el\n  } = swiper;\n  const breakpoints2 = params.breakpoints;\n  if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)\n    return;\n  const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);\n  if (!breakpoint || swiper.currentBreakpoint === breakpoint)\n    return;\n  const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;\n  const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n  const wasMultiRow = isGridEnabled(swiper, params);\n  const isMultiRow = isGridEnabled(swiper, breakpointParams);\n  const wasEnabled = params.enabled;\n  if (wasMultiRow && !isMultiRow) {\n    $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);\n    swiper.emitContainerClasses();\n  } else if (!wasMultiRow && isMultiRow) {\n    $el.addClass(`${params.containerModifierClass}grid`);\n    if (breakpointParams.grid.fill && breakpointParams.grid.fill === \"column\" || !breakpointParams.grid.fill && params.grid.fill === \"column\") {\n      $el.addClass(`${params.containerModifierClass}grid-column`);\n    }\n    swiper.emitContainerClasses();\n  }\n  [\"navigation\", \"pagination\", \"scrollbar\"].forEach((prop) => {\n    const wasModuleEnabled = params[prop] && params[prop].enabled;\n    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n    if (wasModuleEnabled && !isModuleEnabled) {\n      swiper[prop].disable();\n    }\n    if (!wasModuleEnabled && isModuleEnabled) {\n      swiper[prop].enable();\n    }\n  });\n  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n  if (directionChanged && initialized) {\n    swiper.changeDirection();\n  }\n  extend(swiper.params, breakpointParams);\n  const isEnabled = swiper.params.enabled;\n  Object.assign(swiper, {\n    allowTouchMove: swiper.params.allowTouchMove,\n    allowSlideNext: swiper.params.allowSlideNext,\n    allowSlidePrev: swiper.params.allowSlidePrev\n  });\n  if (wasEnabled && !isEnabled) {\n    swiper.disable();\n  } else if (!wasEnabled && isEnabled) {\n    swiper.enable();\n  }\n  swiper.currentBreakpoint = breakpoint;\n  swiper.emit(\"_beforeBreakpoint\", breakpointParams);\n  if (needsReLoop && initialized) {\n    swiper.loopDestroy();\n    swiper.loopCreate();\n    swiper.updateSlides();\n    swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);\n  }\n  swiper.emit(\"breakpoint\", breakpointParams);\n}\nfunction getBreakpoint(breakpoints2, base = \"window\", containerEl) {\n  if (!breakpoints2 || base === \"container\" && !containerEl)\n    return void 0;\n  let breakpoint = false;\n  const window2 = getWindow();\n  const currentHeight = base === \"window\" ? window2.innerHeight : containerEl.clientHeight;\n  const points = Object.keys(breakpoints2).map((point) => {\n    if (typeof point === \"string\" && point.indexOf(\"@\") === 0) {\n      const minRatio = parseFloat(point.substr(1));\n      const value = currentHeight * minRatio;\n      return {\n        value,\n        point\n      };\n    }\n    return {\n      value: point,\n      point\n    };\n  });\n  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n  for (let i = 0; i < points.length; i += 1) {\n    const {\n      point,\n      value\n    } = points[i];\n    if (base === \"window\") {\n      if (window2.matchMedia(`(min-width: ${value}px)`).matches) {\n        breakpoint = point;\n      }\n    } else if (value <= containerEl.clientWidth) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || \"max\";\n}\nconst breakpoints = {\n  setBreakpoint,\n  getBreakpoint\n};\nfunction prepareClasses(entries, prefix) {\n  const resultClasses = [];\n  entries.forEach((item) => {\n    if (typeof item === \"object\") {\n      Object.keys(item).forEach((classNames) => {\n        if (item[classNames]) {\n          resultClasses.push(prefix + classNames);\n        }\n      });\n    } else if (typeof item === \"string\") {\n      resultClasses.push(prefix + item);\n    }\n  });\n  return resultClasses;\n}\nfunction addClasses() {\n  const swiper = this;\n  const {\n    classNames,\n    params,\n    rtl,\n    $el,\n    device,\n    support: support2\n  } = swiper;\n  const suffixes = prepareClasses([\"initialized\", params.direction, {\n    \"pointer-events\": !support2.touch\n  }, {\n    \"free-mode\": swiper.params.freeMode && params.freeMode.enabled\n  }, {\n    \"autoheight\": params.autoHeight\n  }, {\n    \"rtl\": rtl\n  }, {\n    \"grid\": params.grid && params.grid.rows > 1\n  }, {\n    \"grid-column\": params.grid && params.grid.rows > 1 && params.grid.fill === \"column\"\n  }, {\n    \"android\": device.android\n  }, {\n    \"ios\": device.ios\n  }, {\n    \"css-mode\": params.cssMode\n  }, {\n    \"centered\": params.cssMode && params.centeredSlides\n  }, {\n    \"watch-progress\": params.watchSlidesProgress\n  }], params.containerModifierClass);\n  classNames.push(...suffixes);\n  $el.addClass([...classNames].join(\" \"));\n  swiper.emitContainerClasses();\n}\nfunction removeClasses() {\n  const swiper = this;\n  const {\n    $el,\n    classNames\n  } = swiper;\n  $el.removeClass(classNames.join(\" \"));\n  swiper.emitContainerClasses();\n}\nconst classes = {\n  addClasses,\n  removeClasses\n};\nfunction loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {\n  const window2 = getWindow();\n  let image;\n  function onReady() {\n    if (callback)\n      callback();\n  }\n  const isPicture = $(imageEl).parent(\"picture\")[0];\n  if (!isPicture && (!imageEl.complete || !checkForComplete)) {\n    if (src) {\n      image = new window2.Image();\n      image.onload = onReady;\n      image.onerror = onReady;\n      if (sizes) {\n        image.sizes = sizes;\n      }\n      if (srcset) {\n        image.srcset = srcset;\n      }\n      if (src) {\n        image.src = src;\n      }\n    } else {\n      onReady();\n    }\n  } else {\n    onReady();\n  }\n}\nfunction preloadImages() {\n  const swiper = this;\n  swiper.imagesToLoad = swiper.$el.find(\"img\");\n  function onReady() {\n    if (typeof swiper === \"undefined\" || swiper === null || !swiper || swiper.destroyed)\n      return;\n    if (swiper.imagesLoaded !== void 0)\n      swiper.imagesLoaded += 1;\n    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {\n      if (swiper.params.updateOnImagesReady)\n        swiper.update();\n      swiper.emit(\"imagesReady\");\n    }\n  }\n  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {\n    const imageEl = swiper.imagesToLoad[i];\n    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute(\"src\"), imageEl.srcset || imageEl.getAttribute(\"srcset\"), imageEl.sizes || imageEl.getAttribute(\"sizes\"), true, onReady);\n  }\n}\nconst images = {\n  loadImage,\n  preloadImages\n};\nfunction checkOverflow() {\n  const swiper = this;\n  const {\n    isLocked: wasLocked,\n    params\n  } = swiper;\n  const {\n    slidesOffsetBefore\n  } = params;\n  if (slidesOffsetBefore) {\n    const lastSlideIndex = swiper.slides.length - 1;\n    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n    swiper.isLocked = swiper.size > lastSlideRightEdge;\n  } else {\n    swiper.isLocked = swiper.snapGrid.length === 1;\n  }\n  if (params.allowSlideNext === true) {\n    swiper.allowSlideNext = !swiper.isLocked;\n  }\n  if (params.allowSlidePrev === true) {\n    swiper.allowSlidePrev = !swiper.isLocked;\n  }\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n  }\n  if (wasLocked !== swiper.isLocked) {\n    swiper.emit(swiper.isLocked ? \"lock\" : \"unlock\");\n  }\n}\nconst checkOverflow$1 = {\n  checkOverflow\n};\nconst defaults = {\n  init: true,\n  direction: \"horizontal\",\n  touchEventsTarget: \"wrapper\",\n  initialSlide: 0,\n  speed: 300,\n  cssMode: false,\n  updateOnWindowResize: true,\n  resizeObserver: true,\n  nested: false,\n  createElements: false,\n  enabled: true,\n  focusableElements: \"input, select, option, textarea, button, video, label\",\n  // Overrides\n  width: null,\n  height: null,\n  //\n  preventInteractionOnTransition: false,\n  // ssr\n  userAgent: null,\n  url: null,\n  // To support iOS's swipe-to-go-back gesture (when being used in-app).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n  // Autoheight\n  autoHeight: false,\n  // Set wrapper width\n  setWrapperSize: false,\n  // Virtual Translate\n  virtualTranslate: false,\n  // Effects\n  effect: \"slide\",\n  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n  // Breakpoints\n  breakpoints: void 0,\n  breakpointsBase: \"window\",\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerGroup: 1,\n  slidesPerGroupSkip: 0,\n  slidesPerGroupAuto: false,\n  centeredSlides: false,\n  centeredSlidesBounds: false,\n  slidesOffsetBefore: 0,\n  // in px\n  slidesOffsetAfter: 0,\n  // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: true,\n  // Round length\n  roundLengths: false,\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 0,\n  touchMoveStopPropagation: false,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n  // Progress\n  watchSlidesProgress: false,\n  // Cursor\n  grabCursor: false,\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n  // Images\n  preloadImages: true,\n  updateOnImagesReady: true,\n  // loop\n  loop: false,\n  loopAdditionalSlides: 0,\n  loopedSlides: null,\n  loopedSlidesLimit: true,\n  loopFillGroupWithBlank: false,\n  loopPreventsSlide: true,\n  // rewind\n  rewind: false,\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null,\n  // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: \"swiper-no-swiping\",\n  noSwipingSelector: null,\n  // Passive Listeners\n  passiveListeners: true,\n  maxBackfaceHiddenSlides: 10,\n  // NS\n  containerModifierClass: \"swiper-\",\n  // NEW\n  slideClass: \"swiper-slide\",\n  slideBlankClass: \"swiper-slide-invisible-blank\",\n  slideActiveClass: \"swiper-slide-active\",\n  slideDuplicateActiveClass: \"swiper-slide-duplicate-active\",\n  slideVisibleClass: \"swiper-slide-visible\",\n  slideDuplicateClass: \"swiper-slide-duplicate\",\n  slideNextClass: \"swiper-slide-next\",\n  slideDuplicateNextClass: \"swiper-slide-duplicate-next\",\n  slidePrevClass: \"swiper-slide-prev\",\n  slideDuplicatePrevClass: \"swiper-slide-duplicate-prev\",\n  wrapperClass: \"swiper-wrapper\",\n  // Callbacks\n  runCallbacksOnInit: true,\n  // Internals\n  _emitClasses: false\n};\nfunction moduleExtendParams(params, allModulesParams) {\n  return function extendParams(obj = {}) {\n    const moduleParamName = Object.keys(obj)[0];\n    const moduleParams = obj[moduleParamName];\n    if (typeof moduleParams !== \"object\" || moduleParams === null) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if ([\"navigation\", \"pagination\", \"scrollbar\"].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {\n      params[moduleParamName] = {\n        auto: true\n      };\n    }\n    if (!(moduleParamName in params && \"enabled\" in moduleParams)) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if (params[moduleParamName] === true) {\n      params[moduleParamName] = {\n        enabled: true\n      };\n    }\n    if (typeof params[moduleParamName] === \"object\" && !(\"enabled\" in params[moduleParamName])) {\n      params[moduleParamName].enabled = true;\n    }\n    if (!params[moduleParamName])\n      params[moduleParamName] = {\n        enabled: false\n      };\n    extend(allModulesParams, obj);\n  };\n}\nconst prototypes = {\n  eventsEmitter,\n  update,\n  translate,\n  transition,\n  slide,\n  loop,\n  grabCursor,\n  events: events$1,\n  breakpoints,\n  checkOverflow: checkOverflow$1,\n  classes,\n  images\n};\nconst extendedDefaults = {};\nclass Swiper {\n  constructor(...args) {\n    let el;\n    let params;\n    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === \"Object\") {\n      params = args[0];\n    } else {\n      [el, params] = args;\n    }\n    if (!params)\n      params = {};\n    params = extend({}, params);\n    if (el && !params.el)\n      params.el = el;\n    if (params.el && $(params.el).length > 1) {\n      const swipers = [];\n      $(params.el).each((containerEl) => {\n        const newParams = extend({}, params, {\n          el: containerEl\n        });\n        swipers.push(new Swiper(newParams));\n      });\n      return swipers;\n    }\n    const swiper = this;\n    swiper.__swiper__ = true;\n    swiper.support = getSupport();\n    swiper.device = getDevice({\n      userAgent: params.userAgent\n    });\n    swiper.browser = getBrowser();\n    swiper.eventsListeners = {};\n    swiper.eventsAnyListeners = [];\n    swiper.modules = [...swiper.__modules__];\n    if (params.modules && Array.isArray(params.modules)) {\n      swiper.modules.push(...params.modules);\n    }\n    const allModulesParams = {};\n    swiper.modules.forEach((mod) => {\n      mod({\n        swiper,\n        extendParams: moduleExtendParams(params, allModulesParams),\n        on: swiper.on.bind(swiper),\n        once: swiper.once.bind(swiper),\n        off: swiper.off.bind(swiper),\n        emit: swiper.emit.bind(swiper)\n      });\n    });\n    const swiperParams = extend({}, defaults, allModulesParams);\n    swiper.params = extend({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = extend({}, swiper.params);\n    swiper.passedParams = extend({}, params);\n    if (swiper.params && swiper.params.on) {\n      Object.keys(swiper.params.on).forEach((eventName) => {\n        swiper.on(eventName, swiper.params.on[eventName]);\n      });\n    }\n    if (swiper.params && swiper.params.onAny) {\n      swiper.onAny(swiper.params.onAny);\n    }\n    swiper.$ = $;\n    Object.assign(swiper, {\n      enabled: swiper.params.enabled,\n      el,\n      // Classes\n      classNames: [],\n      // Slides\n      slides: $(),\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n      // isDirection\n      isHorizontal() {\n        return swiper.params.direction === \"horizontal\";\n      },\n      isVertical() {\n        return swiper.params.direction === \"vertical\";\n      },\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n      //\n      isBeginning: true,\n      isEnd: false,\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n      // Touch Events\n      touchEvents: function touchEvents() {\n        const touch = [\"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\"];\n        const desktop = [\"pointerdown\", \"pointermove\", \"pointerup\"];\n        swiper.touchEventsTouch = {\n          start: touch[0],\n          move: touch[1],\n          end: touch[2],\n          cancel: touch[3]\n        };\n        swiper.touchEventsDesktop = {\n          start: desktop[0],\n          move: desktop[1],\n          end: desktop[2]\n        };\n        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;\n      }(),\n      touchEventsData: {\n        isTouched: void 0,\n        isMoved: void 0,\n        allowTouchCallbacks: void 0,\n        touchStartTime: void 0,\n        isScrolling: void 0,\n        currentTranslate: void 0,\n        startTranslate: void 0,\n        allowThresholdMove: void 0,\n        // Form elements to match\n        focusableElements: swiper.params.focusableElements,\n        // Last click time\n        lastClickTime: now(),\n        clickTimeout: void 0,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: void 0,\n        isTouchEvent: void 0,\n        startMoving: void 0\n      },\n      // Clicks\n      allowClick: true,\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0\n      },\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0\n    });\n    swiper.emit(\"_swiper\");\n    if (swiper.params.init) {\n      swiper.init();\n    }\n    return swiper;\n  }\n  enable() {\n    const swiper = this;\n    if (swiper.enabled)\n      return;\n    swiper.enabled = true;\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n    swiper.emit(\"enable\");\n  }\n  disable() {\n    const swiper = this;\n    if (!swiper.enabled)\n      return;\n    swiper.enabled = false;\n    if (swiper.params.grabCursor) {\n      swiper.unsetGrabCursor();\n    }\n    swiper.emit(\"disable\");\n  }\n  setProgress(progress, speed) {\n    const swiper = this;\n    progress = Math.min(Math.max(progress, 0), 1);\n    const min = swiper.minTranslate();\n    const max = swiper.maxTranslate();\n    const current = (max - min) * progress + min;\n    swiper.translateTo(current, typeof speed === \"undefined\" ? 0 : speed);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  emitContainerClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el)\n      return;\n    const cls = swiper.el.className.split(\" \").filter((className) => {\n      return className.indexOf(\"swiper\") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n    });\n    swiper.emit(\"_containerClasses\", cls.join(\" \"));\n  }\n  getSlideClasses(slideEl) {\n    const swiper = this;\n    if (swiper.destroyed)\n      return \"\";\n    return slideEl.className.split(\" \").filter((className) => {\n      return className.indexOf(\"swiper-slide\") === 0 || className.indexOf(swiper.params.slideClass) === 0;\n    }).join(\" \");\n  }\n  emitSlidesClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el)\n      return;\n    const updates = [];\n    swiper.slides.each((slideEl) => {\n      const classNames = swiper.getSlideClasses(slideEl);\n      updates.push({\n        slideEl,\n        classNames\n      });\n      swiper.emit(\"_slideClass\", slideEl, classNames);\n    });\n    swiper.emit(\"_slideClasses\", updates);\n  }\n  slidesPerViewDynamic(view = \"current\", exact = false) {\n    const swiper = this;\n    const {\n      params,\n      slides,\n      slidesGrid,\n      slidesSizesGrid,\n      size: swiperSize,\n      activeIndex\n    } = swiper;\n    let spv = 1;\n    if (params.centeredSlides) {\n      let slideSize = slides[activeIndex].swiperSlideSize;\n      let breakLoop;\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize)\n            breakLoop = true;\n        }\n      }\n      for (let i = activeIndex - 1; i >= 0; i -= 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize)\n            breakLoop = true;\n        }\n      }\n    } else {\n      if (view === \"current\") {\n        for (let i = activeIndex + 1; i < slides.length; i += 1) {\n          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      } else {\n        for (let i = activeIndex - 1; i >= 0; i -= 1) {\n          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      }\n    }\n    return spv;\n  }\n  update() {\n    const swiper = this;\n    if (!swiper || swiper.destroyed)\n      return;\n    const {\n      snapGrid,\n      params\n    } = swiper;\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n    function setTranslate2() {\n      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    let translated;\n    if (swiper.params.freeMode && swiper.params.freeMode.enabled) {\n      setTranslate2();\n      if (swiper.params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if ((swiper.params.slidesPerView === \"auto\" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\n        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate2();\n      }\n    }\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n    swiper.emit(\"update\");\n  }\n  changeDirection(newDirection, needUpdate = true) {\n    const swiper = this;\n    const currentDirection = swiper.params.direction;\n    if (!newDirection) {\n      newDirection = currentDirection === \"horizontal\" ? \"vertical\" : \"horizontal\";\n    }\n    if (newDirection === currentDirection || newDirection !== \"horizontal\" && newDirection !== \"vertical\") {\n      return swiper;\n    }\n    swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);\n    swiper.emitContainerClasses();\n    swiper.params.direction = newDirection;\n    swiper.slides.each((slideEl) => {\n      if (newDirection === \"vertical\") {\n        slideEl.style.width = \"\";\n      } else {\n        slideEl.style.height = \"\";\n      }\n    });\n    swiper.emit(\"changeDirection\");\n    if (needUpdate)\n      swiper.update();\n    return swiper;\n  }\n  changeLanguageDirection(direction) {\n    const swiper = this;\n    if (swiper.rtl && direction === \"rtl\" || !swiper.rtl && direction === \"ltr\")\n      return;\n    swiper.rtl = direction === \"rtl\";\n    swiper.rtlTranslate = swiper.params.direction === \"horizontal\" && swiper.rtl;\n    if (swiper.rtl) {\n      swiper.$el.addClass(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = \"rtl\";\n    } else {\n      swiper.$el.removeClass(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = \"ltr\";\n    }\n    swiper.update();\n  }\n  mount(el) {\n    const swiper = this;\n    if (swiper.mounted)\n      return true;\n    const $el = $(el || swiper.params.el);\n    el = $el[0];\n    if (!el) {\n      return false;\n    }\n    el.swiper = swiper;\n    const getWrapperSelector = () => {\n      return `.${(swiper.params.wrapperClass || \"\").trim().split(\" \").join(\".\")}`;\n    };\n    const getWrapper = () => {\n      if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n        const res = $(el.shadowRoot.querySelector(getWrapperSelector()));\n        res.children = (options) => $el.children(options);\n        return res;\n      }\n      if (!$el.children) {\n        return $($el).children(getWrapperSelector());\n      }\n      return $el.children(getWrapperSelector());\n    };\n    let $wrapperEl = getWrapper();\n    if ($wrapperEl.length === 0 && swiper.params.createElements) {\n      const document2 = getDocument();\n      const wrapper = document2.createElement(\"div\");\n      $wrapperEl = $(wrapper);\n      wrapper.className = swiper.params.wrapperClass;\n      $el.append(wrapper);\n      $el.children(`.${swiper.params.slideClass}`).each((slideEl) => {\n        $wrapperEl.append(slideEl);\n      });\n    }\n    Object.assign(swiper, {\n      $el,\n      el,\n      $wrapperEl,\n      wrapperEl: $wrapperEl[0],\n      mounted: true,\n      // RTL\n      rtl: el.dir.toLowerCase() === \"rtl\" || $el.css(\"direction\") === \"rtl\",\n      rtlTranslate: swiper.params.direction === \"horizontal\" && (el.dir.toLowerCase() === \"rtl\" || $el.css(\"direction\") === \"rtl\"),\n      wrongRTL: $wrapperEl.css(\"display\") === \"-webkit-box\"\n    });\n    return true;\n  }\n  init(el) {\n    const swiper = this;\n    if (swiper.initialized)\n      return swiper;\n    const mounted = swiper.mount(el);\n    if (mounted === false)\n      return swiper;\n    swiper.emit(\"beforeInit\");\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    swiper.addClasses();\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    }\n    swiper.updateSize();\n    swiper.updateSlides();\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    }\n    if (swiper.params.grabCursor && swiper.enabled) {\n      swiper.setGrabCursor();\n    }\n    if (swiper.params.preloadImages) {\n      swiper.preloadImages();\n    }\n    if (swiper.params.loop) {\n      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n    }\n    swiper.attachEvents();\n    swiper.initialized = true;\n    swiper.emit(\"init\");\n    swiper.emit(\"afterInit\");\n    return swiper;\n  }\n  destroy(deleteInstance = true, cleanStyles = true) {\n    const swiper = this;\n    const {\n      params,\n      $el,\n      $wrapperEl,\n      slides\n    } = swiper;\n    if (typeof swiper.params === \"undefined\" || swiper.destroyed) {\n      return null;\n    }\n    swiper.emit(\"beforeDestroy\");\n    swiper.initialized = false;\n    swiper.detachEvents();\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n    if (cleanStyles) {\n      swiper.removeClasses();\n      $el.removeAttr(\"style\");\n      $wrapperEl.removeAttr(\"style\");\n      if (slides && slides.length) {\n        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(\" \")).removeAttr(\"style\").removeAttr(\"data-swiper-slide-index\");\n      }\n    }\n    swiper.emit(\"destroy\");\n    Object.keys(swiper.eventsListeners).forEach((eventName) => {\n      swiper.off(eventName);\n    });\n    if (deleteInstance !== false) {\n      swiper.$el[0].swiper = null;\n      deleteProps(swiper);\n    }\n    swiper.destroyed = true;\n    return null;\n  }\n  static extendDefaults(newDefaults) {\n    extend(extendedDefaults, newDefaults);\n  }\n  static get extendedDefaults() {\n    return extendedDefaults;\n  }\n  static get defaults() {\n    return defaults;\n  }\n  static installModule(mod) {\n    if (!Swiper.prototype.__modules__)\n      Swiper.prototype.__modules__ = [];\n    const modules = Swiper.prototype.__modules__;\n    if (typeof mod === \"function\" && modules.indexOf(mod) < 0) {\n      modules.push(mod);\n    }\n  }\n  static use(module) {\n    if (Array.isArray(module)) {\n      module.forEach((m) => Swiper.installModule(m));\n      return Swiper;\n    }\n    Swiper.installModule(module);\n    return Swiper;\n  }\n}\nObject.keys(prototypes).forEach((prototypeGroup) => {\n  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n  });\n});\nSwiper.use([Resize, Observer]);\nfunction createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n  const document2 = getDocument();\n  if (swiper.params.createElements) {\n    Object.keys(checkProps).forEach((key) => {\n      if (!params[key] && params.auto === true) {\n        let element = swiper.$el.children(`.${checkProps[key]}`)[0];\n        if (!element) {\n          element = document2.createElement(\"div\");\n          element.className = checkProps[key];\n          swiper.$el.append(element);\n        }\n        params[key] = element;\n        originalParams[key] = element;\n      }\n    });\n  }\n  return params;\n}\nfunction classesToSelector(classes2 = \"\") {\n  return `.${classes2.trim().replace(/([\\.:!\\/])/g, \"\\\\$1\").replace(/ /g, \".\")}`;\n}\nfunction Pagination({\n  swiper,\n  extendParams,\n  on: on2,\n  emit\n}) {\n  const pfx = \"swiper-pagination\";\n  extendParams({\n    pagination: {\n      el: null,\n      bulletElement: \"span\",\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: \"bullets\",\n      // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: (number) => number,\n      formatFractionTotal: (number) => number,\n      bulletClass: `${pfx}-bullet`,\n      bulletActiveClass: `${pfx}-bullet-active`,\n      modifierClass: `${pfx}-`,\n      currentClass: `${pfx}-current`,\n      totalClass: `${pfx}-total`,\n      hiddenClass: `${pfx}-hidden`,\n      progressbarFillClass: `${pfx}-progressbar-fill`,\n      progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n      clickableClass: `${pfx}-clickable`,\n      lockClass: `${pfx}-lock`,\n      horizontalClass: `${pfx}-horizontal`,\n      verticalClass: `${pfx}-vertical`,\n      paginationDisabledClass: `${pfx}-disabled`\n    }\n  });\n  swiper.pagination = {\n    el: null,\n    $el: null,\n    bullets: []\n  };\n  let bulletSize;\n  let dynamicBulletIndex = 0;\n  function isPaginationDisabled() {\n    return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;\n  }\n  function setSideBullets($bulletEl, position) {\n    const {\n      bulletActiveClass\n    } = swiper.params.pagination;\n    $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);\n  }\n  function update2() {\n    const rtl = swiper.rtl;\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled())\n      return;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    const $el = swiper.pagination.$el;\n    let current;\n    const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n    if (swiper.params.loop) {\n      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);\n      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {\n        current -= slidesLength - swiper.loopedSlides * 2;\n      }\n      if (current > total - 1)\n        current -= total;\n      if (current < 0 && swiper.params.paginationType !== \"bullets\")\n        current = total + current;\n    } else if (typeof swiper.snapIndex !== \"undefined\") {\n      current = swiper.snapIndex;\n    } else {\n      current = swiper.activeIndex || 0;\n    }\n    if (params.type === \"bullets\" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n      const bullets = swiper.pagination.bullets;\n      let firstIndex;\n      let lastIndex;\n      let midIndex;\n      if (params.dynamicBullets) {\n        bulletSize = bullets.eq(0)[swiper.isHorizontal() ? \"outerWidth\" : \"outerHeight\"](true);\n        $el.css(swiper.isHorizontal() ? \"width\" : \"height\", `${bulletSize * (params.dynamicMainBullets + 4)}px`);\n        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== void 0) {\n          dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);\n          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n            dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (dynamicBulletIndex < 0) {\n            dynamicBulletIndex = 0;\n          }\n        }\n        firstIndex = Math.max(current - dynamicBulletIndex, 0);\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n      bullets.removeClass([\"\", \"-next\", \"-next-next\", \"-prev\", \"-prev-prev\", \"-main\"].map((suffix) => `${params.bulletActiveClass}${suffix}`).join(\" \"));\n      if ($el.length > 1) {\n        bullets.each((bullet) => {\n          const $bullet = $(bullet);\n          const bulletIndex = $bullet.index();\n          if (bulletIndex === current) {\n            $bullet.addClass(params.bulletActiveClass);\n          }\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              $bullet.addClass(`${params.bulletActiveClass}-main`);\n            }\n            if (bulletIndex === firstIndex) {\n              setSideBullets($bullet, \"prev\");\n            }\n            if (bulletIndex === lastIndex) {\n              setSideBullets($bullet, \"next\");\n            }\n          }\n        });\n      } else {\n        const $bullet = bullets.eq(current);\n        const bulletIndex = $bullet.index();\n        $bullet.addClass(params.bulletActiveClass);\n        if (params.dynamicBullets) {\n          const $firstDisplayedBullet = bullets.eq(firstIndex);\n          const $lastDisplayedBullet = bullets.eq(lastIndex);\n          for (let i = firstIndex; i <= lastIndex; i += 1) {\n            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);\n          }\n          if (swiper.params.loop) {\n            if (bulletIndex >= bullets.length) {\n              for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {\n                bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);\n              }\n              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);\n            } else {\n              setSideBullets($firstDisplayedBullet, \"prev\");\n              setSideBullets($lastDisplayedBullet, \"next\");\n            }\n          } else {\n            setSideBullets($firstDisplayedBullet, \"prev\");\n            setSideBullets($lastDisplayedBullet, \"next\");\n          }\n        }\n      }\n      if (params.dynamicBullets) {\n        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n        const offsetProp = rtl ? \"right\" : \"left\";\n        bullets.css(swiper.isHorizontal() ? offsetProp : \"top\", `${bulletsOffset}px`);\n      }\n    }\n    if (params.type === \"fraction\") {\n      $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));\n      $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));\n    }\n    if (params.type === \"progressbar\") {\n      let progressbarDirection;\n      if (params.progressbarOpposite) {\n        progressbarDirection = swiper.isHorizontal() ? \"vertical\" : \"horizontal\";\n      } else {\n        progressbarDirection = swiper.isHorizontal() ? \"horizontal\" : \"vertical\";\n      }\n      const scale = (current + 1) / total;\n      let scaleX = 1;\n      let scaleY = 1;\n      if (progressbarDirection === \"horizontal\") {\n        scaleX = scale;\n      } else {\n        scaleY = scale;\n      }\n      $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);\n    }\n    if (params.type === \"custom\" && params.renderCustom) {\n      $el.html(params.renderCustom(swiper, current + 1, total));\n      emit(\"paginationRender\", $el[0]);\n    } else {\n      emit(\"paginationUpdate\", $el[0]);\n    }\n    if (swiper.params.watchOverflow && swiper.enabled) {\n      $el[swiper.isLocked ? \"addClass\" : \"removeClass\"](params.lockClass);\n    }\n  }\n  function render() {\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled())\n      return;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    const $el = swiper.pagination.$el;\n    let paginationHTML = \"\";\n    if (params.type === \"bullets\") {\n      let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n      if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {\n        numberOfBullets = slidesLength;\n      }\n      for (let i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          paginationHTML += `<${params.bulletElement} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n        }\n      }\n      $el.html(paginationHTML);\n      swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));\n    }\n    if (params.type === \"fraction\") {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML = `<span class=\"${params.currentClass}\"></span> / <span class=\"${params.totalClass}\"></span>`;\n      }\n      $el.html(paginationHTML);\n    }\n    if (params.type === \"progressbar\") {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n      }\n      $el.html(paginationHTML);\n    }\n    if (params.type !== \"custom\") {\n      emit(\"paginationRender\", swiper.pagination.$el[0]);\n    }\n  }\n  function init() {\n    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n      el: \"swiper-pagination\"\n    });\n    const params = swiper.params.pagination;\n    if (!params.el)\n      return;\n    let $el = $(params.el);\n    if ($el.length === 0)\n      return;\n    if (swiper.params.uniqueNavElements && typeof params.el === \"string\" && $el.length > 1) {\n      $el = swiper.$el.find(params.el);\n      if ($el.length > 1) {\n        $el = $el.filter((el) => {\n          if ($(el).parents(\".swiper\")[0] !== swiper.el)\n            return false;\n          return true;\n        });\n      }\n    }\n    if (params.type === \"bullets\" && params.clickable) {\n      $el.addClass(params.clickableClass);\n    }\n    $el.addClass(params.modifierClass + params.type);\n    $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    if (params.type === \"bullets\" && params.dynamicBullets) {\n      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);\n      dynamicBulletIndex = 0;\n      if (params.dynamicMainBullets < 1) {\n        params.dynamicMainBullets = 1;\n      }\n    }\n    if (params.type === \"progressbar\" && params.progressbarOpposite) {\n      $el.addClass(params.progressbarOppositeClass);\n    }\n    if (params.clickable) {\n      $el.on(\"click\", classesToSelector(params.bulletClass), function onClick2(e) {\n        e.preventDefault();\n        let index2 = $(this).index() * swiper.params.slidesPerGroup;\n        if (swiper.params.loop)\n          index2 += swiper.loopedSlides;\n        swiper.slideTo(index2);\n      });\n    }\n    Object.assign(swiper.pagination, {\n      $el,\n      el: $el[0]\n    });\n    if (!swiper.enabled) {\n      $el.addClass(params.lockClass);\n    }\n  }\n  function destroy() {\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled())\n      return;\n    const $el = swiper.pagination.$el;\n    $el.removeClass(params.hiddenClass);\n    $el.removeClass(params.modifierClass + params.type);\n    $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass)\n      swiper.pagination.bullets.removeClass(params.bulletActiveClass);\n    if (params.clickable) {\n      $el.off(\"click\", classesToSelector(params.bulletClass));\n    }\n  }\n  on2(\"init\", () => {\n    if (swiper.params.pagination.enabled === false) {\n      disable();\n    } else {\n      init();\n      render();\n      update2();\n    }\n  });\n  on2(\"activeIndexChange\", () => {\n    if (swiper.params.loop) {\n      update2();\n    } else if (typeof swiper.snapIndex === \"undefined\") {\n      update2();\n    }\n  });\n  on2(\"snapIndexChange\", () => {\n    if (!swiper.params.loop) {\n      update2();\n    }\n  });\n  on2(\"slidesLengthChange\", () => {\n    if (swiper.params.loop) {\n      render();\n      update2();\n    }\n  });\n  on2(\"snapGridLengthChange\", () => {\n    if (!swiper.params.loop) {\n      render();\n      update2();\n    }\n  });\n  on2(\"destroy\", () => {\n    destroy();\n  });\n  on2(\"enable disable\", () => {\n    const {\n      $el\n    } = swiper.pagination;\n    if ($el) {\n      $el[swiper.enabled ? \"removeClass\" : \"addClass\"](swiper.params.pagination.lockClass);\n    }\n  });\n  on2(\"lock unlock\", () => {\n    update2();\n  });\n  on2(\"click\", (_s, e) => {\n    const targetEl = e.target;\n    const {\n      $el\n    } = swiper.pagination;\n    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {\n      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))\n        return;\n      const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);\n      if (isHidden === true) {\n        emit(\"paginationShow\");\n      } else {\n        emit(\"paginationHide\");\n      }\n      $el.toggleClass(swiper.params.pagination.hiddenClass);\n    }\n  });\n  const enable = () => {\n    swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass);\n    if (swiper.pagination.$el) {\n      swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass);\n    }\n    init();\n    render();\n    update2();\n  };\n  const disable = () => {\n    swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass);\n    if (swiper.pagination.$el) {\n      swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass);\n    }\n    destroy();\n  };\n  Object.assign(swiper.pagination, {\n    enable,\n    disable,\n    render,\n    update: update2,\n    init,\n    destroy\n  });\n}\nfunction effectInit(params) {\n  const {\n    effect,\n    swiper,\n    on: on2,\n    setTranslate: setTranslate2,\n    setTransition: setTransition2,\n    overwriteParams,\n    perspective,\n    recreateShadows,\n    getEffectParams\n  } = params;\n  on2(\"beforeInit\", () => {\n    if (swiper.params.effect !== effect)\n      return;\n    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n    if (perspective && perspective()) {\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n    }\n    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n    Object.assign(swiper.params, overwriteParamsResult);\n    Object.assign(swiper.originalParams, overwriteParamsResult);\n  });\n  on2(\"setTranslate\", () => {\n    if (swiper.params.effect !== effect)\n      return;\n    setTranslate2();\n  });\n  on2(\"setTransition\", (_s, duration) => {\n    if (swiper.params.effect !== effect)\n      return;\n    setTransition2(duration);\n  });\n  on2(\"transitionEnd\", () => {\n    if (swiper.params.effect !== effect)\n      return;\n    if (recreateShadows) {\n      if (!getEffectParams || !getEffectParams().slideShadows)\n        return;\n      swiper.slides.each((slideEl) => {\n        const $slideEl = swiper.$(slideEl);\n        $slideEl.find(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").remove();\n      });\n      recreateShadows();\n    }\n  });\n  let requireUpdateOnVirtual;\n  on2(\"virtualUpdate\", () => {\n    if (swiper.params.effect !== effect)\n      return;\n    if (!swiper.slides.length) {\n      requireUpdateOnVirtual = true;\n    }\n    requestAnimationFrame(() => {\n      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n        setTranslate2();\n        requireUpdateOnVirtual = false;\n      }\n    });\n  });\n}\nfunction effectTarget(effectParams, $slideEl) {\n  if (effectParams.transformEl) {\n    return $slideEl.find(effectParams.transformEl).css({\n      \"backface-visibility\": \"hidden\",\n      \"-webkit-backface-visibility\": \"hidden\"\n    });\n  }\n  return $slideEl;\n}\nfunction effectVirtualTransitionEnd({\n  swiper,\n  duration,\n  transformEl,\n  allSlides\n}) {\n  const {\n    slides,\n    activeIndex,\n    $wrapperEl\n  } = swiper;\n  if (swiper.params.virtualTranslate && duration !== 0) {\n    let eventTriggered = false;\n    let $transitionEndTarget;\n    if (allSlides) {\n      $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;\n    } else {\n      $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);\n    }\n    $transitionEndTarget.transitionEnd(() => {\n      if (eventTriggered)\n        return;\n      if (!swiper || swiper.destroyed)\n        return;\n      eventTriggered = true;\n      swiper.animating = false;\n      const triggerEvents = [\"webkitTransitionEnd\", \"transitionend\"];\n      for (let i = 0; i < triggerEvents.length; i += 1) {\n        $wrapperEl.trigger(triggerEvents[i]);\n      }\n    });\n  }\n}\nfunction EffectFade({\n  swiper,\n  extendParams,\n  on: on2\n}) {\n  extendParams({\n    fadeEffect: {\n      crossFade: false,\n      transformEl: null\n    }\n  });\n  const setTranslate2 = () => {\n    const {\n      slides\n    } = swiper;\n    const params = swiper.params.fadeEffect;\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = swiper.slides.eq(i);\n      const offset2 = $slideEl[0].swiperSlideOffset;\n      let tx = -offset2;\n      if (!swiper.params.virtualTranslate)\n        tx -= swiper.translate;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n      }\n      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);\n      const $targetEl = effectTarget(params, $slideEl);\n      $targetEl.css({\n        opacity: slideOpacity\n      }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);\n    }\n  };\n  const setTransition2 = (duration) => {\n    const {\n      transformEl\n    } = swiper.params.fadeEffect;\n    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n    $transitionElements.transition(duration);\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformEl,\n      allSlides: true\n    });\n  };\n  effectInit({\n    effect: \"fade\",\n    swiper,\n    on: on2,\n    setTranslate: setTranslate2,\n    setTransition: setTransition2,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\nclass InitSlider {\n  constructor(props) {\n    __publicField(this, \"classSlider\", \"\");\n    __publicField(this, \"settingsSlider\", {});\n    __publicField(this, \"slider\", null);\n    this.classSlider = props.classSlider;\n    this.settingsSlider = props.settingsSlider;\n    this.checkSlider();\n    if (this.settingsSlider.destroySize) {\n      this.checkResizeSlider();\n    }\n  }\n  checkSlider() {\n    if (window.matchMedia(this.settingsSlider.destroySize).matches && this.settingsSlider.destroySize) {\n      if (this.slider) {\n        try {\n          this.destroySlider();\n        } catch (e) {\n          console.log(e);\n        }\n      }\n      return 1;\n    } else {\n      if (!this.slider) {\n        this.initSlider();\n      }\n    }\n  }\n  checkResizeSlider() {\n    window.addEventListener(\"resize\", () => {\n      this.checkSlider();\n    });\n  }\n  initSlider() {\n    this.slider = new Swiper(this.classSlider, this.settingsSlider) || null;\n  }\n  destroySlider() {\n    var _a, _b;\n    this.slider.destroy();\n    this.slider = null;\n    (_a = document.querySelectorAll(`${this.classSlider}__slider`)) == null ? void 0 : _a.forEach((i) => {\n      i.removeAttribute(\"style\");\n    });\n    (_b = document.querySelector(`${this.classSlider}__wrapper`)) == null ? void 0 : _b.removeAttribute(\"style\");\n  }\n}\nconst listSliders = [\n  {\n    classSlider: \".tmpl-hh-footer__benefits-slider\",\n    settingsSlider: {\n      modules: [Pagination, EffectFade],\n      direction: \"horizontal\",\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      spaceBetween: 20,\n      loop: true,\n      breakpoints: {\n        700: {\n          slidesPerView: 2,\n          slidesPerGroup: 2\n        }\n      },\n      pagination: {\n        el: \".swiper-pagination\",\n        type: \"bullets\"\n      }\n    }\n  }\n];\nconst initSliders = () => {\n  listSliders.map((i) => {\n    new InitSlider(i);\n  });\n};\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n  window.addEventListener(\"load\", () => {\n    initSliders();\n  });\n});\n\n\n//\n</script>\n<div class=\"tmpl-hh-wrapper\">\n    <div class=\"tmpl-hh-header\">\n        <div class=\"tmpl-hh-header__inner\">\n            <div class=\"tmpl-hh-header__logo\">\n                <img src=\"https://hhcdn.ru/ichameleon/278223.svg\" alt=\"\">\n            </div>\n            <div class=\"tmpl-hh-header__title\">\n                <img src=\"https://hhcdn.ru/ichameleon/278226.svg\" alt=\"\">\n            </div>\n            <div class=\"tmpl-hh-header__image\">\n                <picture>\n                    <source srcset=\"https://hhcdn.ru/ichameleon/278225.png\" media=\"(min-width: 700px)\"></source>\n                    <img src=\"https://hhcdn.ru/ichameleon/278224.png\" alt=\"\">\n                </picture>\n            </div>\n            <div class=\"tmpl-hh-header__text\">\n                НПФ Сбербанка работает на фондовом рынке более 30 лет и входит в ТОП-10\n                негосударственных пенсионных фондов России.* Надежность НПФ Сбербанка подтверждена ведущим рейтинговым\n                агентством: «Эксперт РА» - наивысший рейтинг надежности на уровне ruААА, прогноз\n                стабильный.\n            </div>\n            <div class=\"tmpl-hh-header__pattern\">\n                <picture>\n                    <source srcset=\"https://hhcdn.ru/ichameleon/278222.png\" media=\"(min-width: 700px)\"></source>\n                    <img src=\"https://hhcdn.ru/ichameleon/278221.png\" alt=\"\">\n                </picture>\n            </div>\n        </div>\n    </div>    <div class=\"tmpl-hh-content\">\n        <p>Наша команда разрабатывает новый инструмент автоматизации взаимодействия с клиентом на основе событий по инвестиционному портфелю и на финансовом рынке. Проект создаётся с нуля, что делает его идеальной возможностью для тех, кто хочет получить ценный опыт запуска новых продуктов.</p> <p>Каждому новому сотруднику предоставляется ментор, который поможет быстро адаптироваться и освоиться в процессах. У каждой компетенции есть лидер, готовый оказать поддержку в сложных ситуациях.</p><h3><strong>Обязанности</strong></h3> <ul> <li>Работа в небольшой команде по методологии Agile (Scrum);</li> <li>Сбор и проработка пользовательских, функциональных и нефункциональных требований для продукта;</li> <li>Проектирование API;</li> <li>Проектирование интеграционных потоков и разработка интеграционных спецификаций;</li> <li>Разработка архитектурной документации на уровне функциональной области команды;</li> <li>Участие в функциональном и интеграционном тестировании в роли эксперта;</li> <li>Участие в приемо-сдаточных испытаниях.</li> </ul><h3><strong>Требования</strong></h3> <ul> <li>Опыт работы в роли системного аналитика от 2 лет;</li> <li>Опыт сбора и подготовки требований, описания процессов;</li> <li>Навыки описания моделей данных ИТ-систем (до атрибутов сущностей);</li> <li>Знание методологий функционального, информационного и процессного моделирования (BPMN, UML);</li> <li>Понимание принципов работы REST/Web сервисов, очередей сообщений, XML/JSON, XSD/JSON Schema;</li> <li>Опыт проектирования и документирования API;</li> <li>Понимание принципов обеспечения безопасности при проектировании API;</li> <li>Базовое понимание принципов реляционных СУБД и знание SQL;</li> <li>Опыт командной работы с использованием Confluence, Jira.</li> </ul><h3><strong>Условия</strong></h3> <ul> <li>Гибридный формат работы (современный офис в Москве на Кутузовском проспекте);</li> <li>Льготные ипотечные условия кредитования;</li> <li>Бесплатная подписка СберПрайм+, скидки на продукты компаний-партнеров: Okko, Сбер Маркет, Мега Маркет, Самокат, Еаптека и другие;</li> <li>ДМС с первого дня и скидки на страхование для близких;</li> <li>Корпоративная пенсионная программа;</li> <li>Детский отдых и подарки за счет Компании;</li> <li>Обучение за счет Компании: онлайн курсы, неограниченный доступ к библиотеке и обучение на базе Корпоративного университета тренинги, митапы и возможность получить новую квалификацию;</li> <li>Скидки на отдых в курортном комплексе «Mriya Resort &amp; SPA» в Ялте.</li> </ul></div>    <div class=\"tmpl-hh-footer\">\n        <div class=\"tmpl-hh-footer__pattern\">\n            <img src=\"https://hhcdn.ru/ichameleon/278220.png\" alt=\"\">\n        </div>\n        <div class=\"tmpl-hh-footer__benefits\">\n            <div class=\"tmpl-hh-footer__benefits-title\">Работа в Сбере – это:</div>\n            <div class=\"tmpl-hh-footer__benefits-list\">\n                <div class=\"tmpl-hh-footer__benefits-slider\">\n                    <div class=\"tmpl-hh-footer__benefits-slider-wrapper swiper-wrapper\">\n                        <div class=\"tmpl-hh-footer__benefit swiper-slide\">\n                            <div class=\"tmpl-hh-footer__benefit-icon\">\n                                <svg>\n                                    <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#benefit-1\"></use>\n                                </svg>\n                            </div>\n                            <div class=\"tmpl-hh-footer__benefit-text\">\n                                Удобное расположение,\n                                комфортные условия труда\n                            </div>\n                        </div>\n                        <div class=\"tmpl-hh-footer__benefit swiper-slide\">\n                            <div class=\"tmpl-hh-footer__benefit-icon\">\n                                <svg>\n                                    <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#benefit-2\"></use>\n                                </svg>\n                            </div>\n                            <div class=\"tmpl-hh-footer__benefit-text\">\n                                Социальный пакет (ДМС, НС, скидки на услуги)\n                            </div>\n                        </div>\n                        <div class=\"tmpl-hh-footer__benefit swiper-slide\">\n                            <div class=\"tmpl-hh-footer__benefit-icon\">\n                                <svg>\n                                    <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#benefit-3\"></use>\n                                </svg>\n                            </div>\n                            <div class=\"tmpl-hh-footer__benefit-text\">\n                                Ипотечная субсидия для сотрудников Сбера (4% от рыночной ставки)\n                            </div>\n                        </div>\n                        <div class=\"tmpl-hh-footer__benefit swiper-slide\">\n                            <div class=\"tmpl-hh-footer__benefit-icon\">\n                                <svg>\n                                    <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#benefit-4\"></use>\n                                </svg>\n                            </div>\n                            <div class=\"tmpl-hh-footer__benefit-text\">\n                                Бесплатное обучение для сотрудников в Корпоративном университете\n                            </div>\n                        </div>\n                        <div class=\"tmpl-hh-footer__benefit swiper-slide\">\n                            <div class=\"tmpl-hh-footer__benefit-icon\">\n                                <svg>\n                                    <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#benefit-5\"></use>\n                                </svg>\n                            </div>\n                            <div class=\"tmpl-hh-footer__benefit-text\">\n                                Профессиональный\n                                и сплоченный коллектив\n                            </div>\n                        </div>\n                        <div class=\"tmpl-hh-footer__benefit swiper-slide\">\n                            <div class=\"tmpl-hh-footer__benefit-icon\">\n                                <svg>\n                                    <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#benefit-6\"></use>\n                                </svg>\n                            </div>\n                            <div class=\"tmpl-hh-footer__benefit-text\">\n                                Корпоративная пенсионная программа\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n    \n            <div class=\"tmpl-hh-footer__benefits-slider-pug swiper-pagination\"></div>\n        </div>\n        <div class=\"tmpl-hh-footer__notes\">\n            * Рейтинг НПФ по доходности пенсионных резервов, Investfunds, 2021\n        </div>\n        <div class=\"tmpl-hh-footer__text\">\n            <p>Отклик на данную вакансию соискателем посредством сайта http://hh.ru является действием самого\n                соискателя по предоставлению своего согласия в соответствии с Федеральным законом от 27.07.2006 г.\n                № 152-ФЗ \"О персональных данных\" на осуществление со всеми указанными в том\n                резюме соискателя на сайте http://hh.ru персональными данными (а также с самим резюме),\n                которое включается в содержание отклика на данную вакансию, следующих действий: сбор, запись,\n                систематизацию, хранение, уточнение (обновление или изменение), использование, обезличивание, блокирование,\n                уничтожение, для целей возможного трудоустройства соискателя у оператора персональных данных:\n                Акционерное общество \"Негосударственный пенсионный фонд Сбербанка\", адрес местонахождения:\n                Российская Федерация, 115162, город Москва, ул. Шаболовка, д.31 к.Г\n    \n            </p>\n            <p>Настоящее согласие на обработку персональных данных может быть отозвано соискателем путем направления\n                соответствующего заявления по адресу оператора: 115162, город Москва, ул. Шаболовка, д.31 к.Г.</p>\n            <p>Также предоставляется согласие на право со стороны: АО «Негосударственный пенсионный фонд Сбербанка»\n                поручить обработку указанных в настоящем согласии персональных данных, а именно осуществление\n                следующих действий: сбор, запись, накопление, хранение, уточнение (обновление, изменение), извлечение,\n                передача (предоставление, доступ), блокирование, удаление, обезличивание, систематизация, хранение,\n                уничтожение, другому лицу – Публичному акционерному обществу «Сбербанк России», ИНН\n                7707083893, адрес местонахождения: Российская Федерация, 117312, г. Москва, улица Вавилова 19 –\n                для целей подбора персонала.</p>\n        </div>\n    </div>    <svg class=\"tmpl-hh-icons\" style=\"display: none\">\n        <symbol id=\"benefit-1\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" fill=\"none\">\n            <g clip-path=\"url(#clip0_225_159)\">\n                <path d=\"M15.9411 5.7668C13.1642 5.7668 10.9131 8.02345 10.9131 10.8071C10.9131 13.5908 13.1642 15.8477 15.9411 15.8477C18.718 15.8477 20.9691 13.5908 20.9691 10.8071C20.9691 8.02345 18.718 5.7668 15.9411 5.7668ZM15.9411 7.93636C17.5202 7.93636 18.8049 9.2243 18.8049 10.8071C18.8049 12.3902 17.5202 13.6781 15.9411 13.6781C14.362 13.6781 13.0773 12.3902 13.0773 10.8071C13.0773 9.2243 14.362 7.93636 15.9411 7.93636Z\" fill=\"#334047\"></path>\n                <path d=\"M24.3343 16.1912L21.6719 15.7917L15.9366 21.5265L12.8382 18.4161L11.2881 19.9721L15.9374 24.6328L24.3343 16.1912Z\" fill=\"#219638\"></path>\n                <path d=\"M8.80366 7.48752C9.35817 6.10288 10.259 4.92155 11.4086 4.07139C12.6457 3.15646 14.0889 2.67156 15.6991 2.6305C15.7835 2.62833 15.8681 2.62709 15.9531 2.62709C16.038 2.62709 16.1225 2.62833 16.2074 2.6305C17.8171 2.67156 19.2602 3.15661 20.4966 4.07201C21.6455 4.92264 22.5453 6.10443 23.0985 7.48938C23.8234 9.30406 24.016 11.7862 22.8422 14.0754L25.0726 14.4124C27.6583 8.30297 23.5853 0.648914 16.2626 0.461557C16.1596 0.458921 16.0565 0.457527 15.9531 0.457527C15.8495 0.457527 15.7464 0.458921 15.6436 0.461557C6.95724 0.683783 2.83604 11.4078 8.97881 17.611L9.75747 18.3975L11.2891 16.8645L10.5148 16.0825C7.80934 13.3504 7.85695 9.85126 8.80366 7.48752Z\" fill=\"#334047\"></path>\n                <path d=\"M32.0464 31.1992H-0.0488281L3.39573 20.1359L9.2219 20.1703L11.1753 22.4376L5.0064 22.369L2.86456 28.9987H29.031L26.9293 22.4728L20.6 22.4034L22.5877 20.2045L28.5167 20.1703L32.0464 31.1992Z\" fill=\"#334047\"></path>\n            </g>\n            <defs>\n                <clipPath id=\"clip0_225_159\">\n                    <rect width=\"32\" height=\"32\" fill=\"white\"></rect>\n                </clipPath>\n            </defs>\n        </symbol>\n        <symbol id=\"benefit-2\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" fill=\"none\">\n            <g clip-path=\"url(#clip0_225_222)\">\n                <path d=\"M0.0419922 19.8374L2.32458 21.4777V29.6274H6.88975V31.9014H0.0419922V19.8374Z\" fill=\"#219638\"></path>\n                <path d=\"M13.8099 22.7073L10.9388 15.0596C10.5341 13.9818 9.62373 13.2387 8.56704 13.012V3.41413C8.56704 1.54145 7.03764 0.0179615 5.1579 0.0179615H5.0856C3.33273 0.0179615 1.88206 1.31945 1.6961 3.05163L0.0205078 13.6612V17.1615L2.2746 18.8072V13.8367L3.92765 3.3705L3.93602 3.30362C3.9935 2.71077 4.48763 2.26358 5.0856 2.26358H5.1579C5.79484 2.26358 6.31295 2.77975 6.31295 3.41413V13.3357C5.77149 13.6262 5.32132 14.0614 5.01299 14.6108C4.7359 15.105 4.59502 15.6478 4.59502 16.197C4.59502 16.5099 4.64074 16.8251 4.73332 17.1345L6.67023 23.6081L8.83029 22.9665L6.89338 16.4931C6.81401 16.2274 6.84508 15.9482 6.98065 15.7065C7.11638 15.4647 7.33889 15.2921 7.60745 15.2204C8.11767 15.0841 8.64239 15.3531 8.82755 15.8463L11.6986 23.4939C11.843 23.8789 11.9163 24.2825 11.9163 24.6934V31.9004H14.1704V24.6934C14.1704 24.013 14.0491 23.3449 13.8099 22.7073Z\" fill=\"#334047\"></path>\n                <path d=\"M31.9622 16.623V13.6608L30.2866 3.05127C30.1005 1.3191 28.65 0.0176105 26.8971 0.0176105H26.8248C24.9451 0.0176105 23.4157 1.5411 23.4157 3.41378V13.0186C22.3707 13.2523 21.4726 13.9909 21.0714 15.0592L18.2003 22.707C17.9611 23.3446 17.8398 24.0126 17.8398 24.6931V31.9H20.0939V24.6931C20.0939 24.2821 20.1672 23.8785 20.3116 23.4936L23.1827 15.846C23.3678 15.3529 23.8924 15.0838 24.4028 15.2201C24.6713 15.2918 24.8939 15.4644 25.0296 15.7061C25.1651 15.948 25.1962 16.2271 25.1168 16.4927L23.1799 22.9662L25.34 23.6078L27.2769 17.1342C27.3695 16.8247 27.4152 16.5096 27.4152 16.1966C27.4152 15.6474 27.2743 15.1046 26.9972 14.6106C26.6836 14.0516 26.2236 13.6103 25.6697 13.32V3.41378C25.6697 2.7794 26.1879 2.26322 26.8248 2.26322H26.8971C27.4951 2.26322 27.9892 2.71042 28.0467 3.30327L28.055 3.37015L29.7081 13.8363V16.623V18.8068V31.9424H31.9801V16.623H31.9622Z\" fill=\"#334047\"></path>\n                <path d=\"M13.7446 4.65499C13.1063 4.65499 12.5871 5.17228 12.5871 5.80795C12.5871 6.55975 12.8866 7.29295 13.4086 7.82179L16.0267 10.4743L18.6493 7.82163C19.1792 7.28573 19.4709 6.57066 19.4709 5.80795C19.4709 5.17228 18.9517 4.65499 18.3134 4.65499C17.6754 4.65499 17.1561 5.17228 17.1561 5.80795H14.902C14.902 5.17228 14.3828 4.65499 13.7446 4.65499ZM16.0254 13.6758L11.8014 9.39628C10.8545 8.43709 10.333 7.1635 10.333 5.81004C10.333 3.93399 11.8634 2.40938 13.7446 2.40938C14.6224 2.40938 15.4239 2.74125 16.0291 3.28597C16.6343 2.74125 17.4356 2.40938 18.3134 2.40938C20.1946 2.40938 21.725 3.93399 21.725 5.80795C21.725 7.16398 21.203 8.43869 20.2552 9.39741L16.0254 13.6758Z\" fill=\"#334047\"></path>\n            </g>\n            <defs>\n                <clipPath id=\"clip0_225_222\">\n                    <rect width=\"32\" height=\"32\" fill=\"white\"></rect>\n                </clipPath>\n            </defs>\n        </symbol>\n        <symbol id=\"benefit-3\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" fill=\"none\">\n            <g clip-path=\"url(#clip0_225_185)\">\n                <path d=\"M20.5613 13.7803H15.9616V11.4641H13.6875V13.7803H9.09576V9.14794H20.5613V13.7803ZM14.8286 2.99586L19.1783 6.88531H10.4786L14.8286 2.99586ZM25.0974 9.14794L14.8286 -0.0344448L4.55957 9.14794H6.84167V16.043H22.8154V9.14794H25.0974Z\" fill=\"#334047\"></path>\n                <path d=\"M19.5771 31.9873L21.2444 29.7245L29.6814 29.7137L29.6782 25.1294L31.9627 25.1312V32.0049L19.5771 31.9873Z\" fill=\"#219638\"></path>\n                <path d=\"M16.4603 18.3384C14.7646 18.3358 13.3613 19.6113 13.1963 21.3052C13.1879 21.3892 13.186 21.4728 13.184 21.5562L4.64264 18.5572C2.883 17.8935 0.91341 18.7906 0.252318 20.5569L0.226719 20.6248C-0.389774 22.2718 0.322839 24.0961 1.88492 24.8848L15.0879 32.0087L17.1633 32.041L18.8893 29.7516L15.9714 29.7247L2.96962 22.9011L2.90973 22.8695C2.37277 22.6054 2.12643 21.9825 2.33687 21.4207L2.36231 21.3527C2.58643 20.7542 3.25364 20.4504 3.84968 20.6752L16.0467 25.1946C16.0876 25.2121 22.8246 25.1295 22.8246 25.1295L22.9001 22.8837C22.9001 22.8837 17.073 22.8657 16.3769 22.8657C15.7258 22.7962 15.3674 22.1933 15.3735 21.7391C15.3824 21.072 15.9284 20.6002 16.4568 20.601L31.9979 20.5792L32.0337 18.2503L16.4603 18.3384Z\" fill=\"#334047\"></path>\n            </g>\n            <defs>\n                <clipPath id=\"clip0_225_185\">\n                    <rect width=\"32\" height=\"32\" fill=\"white\"></rect>\n                </clipPath>\n            </defs>\n        </symbol>\n        <symbol id=\"benefit-4\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" fill=\"none\">\n            <g clip-path=\"url(#clip0_225_211)\">\n                <path d=\"M16.3192 28.0068L14.9501 26.1968L7.06762 26.238L7.04691 21.9393H5.24219L5.24256 27.9361L16.3192 28.0068Z\" fill=\"#219638\"></path>\n                <path d=\"M3.98346 10.5692L15.9631 5.47487L27.9796 10.6766L21.9915 13.9244L15.8775 10.47L13.8089 11.3875L20.1535 14.9214L15.93 17.2121L3.98346 10.5692ZM31.9977 10.4993L15.9693 3.56084L-0.0166016 10.359L5.26371 13.295L5.2833 20.1705L7.02577 20.1911L7.04398 14.285L15.9193 19.22L21.1966 16.3577V22.7054H22.966V15.398L24.7405 14.4355V26.2175H17.3351L18.7665 27.9863L26.5088 27.9568L26.5229 13.4688L31.9977 10.4993Z\" fill=\"#334047\"></path>\n            </g>\n            <defs>\n                <clipPath id=\"clip0_225_211\">\n                    <rect width=\"32\" height=\"32\" fill=\"white\"></rect>\n                </clipPath>\n            </defs>\n        </symbol>\n        <symbol id=\"benefit-5\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" fill=\"none\">\n            <g clip-path=\"url(#clip0_225_175)\">\n                <path d=\"M15.8052 25.2705L12.2103 28.8397C12.0249 29.0238 11.8085 29.0512 11.696 29.0512C11.5835 29.0512 11.3671 29.0238 11.1817 28.8397C10.9963 28.6557 10.9687 28.4408 10.9687 28.3291C10.9687 28.2174 10.9963 28.0026 11.1817 27.8185L14.7766 24.2493C14.962 24.0652 15.1784 24.0378 15.2909 24.0378C15.4034 24.0378 15.6198 24.0652 15.8052 24.2493C16.0889 24.5309 16.0889 24.9889 15.8052 25.2705ZM9.66031 26.3081C9.47507 26.4922 9.25866 26.5196 9.14616 26.5196C9.03351 26.5196 8.81711 26.4922 8.63186 26.3081C8.44646 26.1242 8.41884 25.9091 8.41884 25.7974C8.41884 25.6876 8.44631 25.4781 8.62358 25.2961C8.62665 25.2932 8.62987 25.2908 8.63278 25.2879L12.2277 21.7185C12.2308 21.7156 12.2334 21.7123 12.2363 21.7092C12.4195 21.5335 12.6304 21.5061 12.7411 21.5061C12.8536 21.5061 13.07 21.5335 13.2554 21.7176C13.539 21.999 13.539 22.4573 13.2554 22.7389L9.66031 26.3081ZM7.10415 23.7875C6.9209 23.9634 6.70987 23.9908 6.59921 23.9908C6.48671 23.9908 6.27031 23.9634 6.08491 23.7793C5.89951 23.5952 5.87188 23.3804 5.87188 23.2687C5.87188 23.157 5.89951 22.9421 6.08491 22.7581L9.67981 19.1888C9.86521 19.0048 10.0816 18.9773 10.1941 18.9773C10.3066 18.9773 10.523 19.0048 10.7084 19.1888C10.9897 19.468 10.9911 19.9207 10.7144 20.2028C10.7121 20.2051 10.7096 20.2069 10.7075 20.209L7.11244 23.7784C7.10952 23.7813 7.10707 23.7846 7.10415 23.7875ZM4.55274 21.237C4.3675 21.4211 4.15094 21.4485 4.0386 21.4485C3.9261 21.4485 3.70954 21.4211 3.52414 21.237C3.33889 21.0529 3.31127 20.8381 3.31127 20.7264C3.31127 20.6147 3.33889 20.3998 3.52414 20.2157L7.11919 16.6465C7.30459 16.4624 7.52099 16.435 7.63349 16.435C7.74599 16.435 7.96239 16.4624 8.1478 16.6465C8.43142 16.928 8.43142 17.3862 8.1478 17.6678L4.55274 21.237ZM31.2061 17.1661L25.0746 10.9651L24.4962 13.1946L29.6868 18.6746C29.9704 18.9562 29.9704 19.4144 29.6868 19.696C29.4033 19.9774 28.9418 19.9774 28.6582 19.696L24.0708 15.1879L22.5908 16.6067L27.1369 21.2064C27.4205 21.4878 27.4205 21.946 27.1369 22.2276C26.8556 22.5069 26.3996 22.5083 26.1155 22.2333C26.1132 22.2311 26.1115 22.2288 26.1092 22.2266L21.4679 17.5526L19.7327 19.1404L24.5889 23.736C24.5912 23.7382 24.5936 23.74 24.5958 23.7421C24.8728 24.0242 24.8713 24.4769 24.59 24.7562C24.3063 25.0378 23.845 25.0378 23.5614 24.7562L18.9161 20.1031L17.317 21.6739L22.0294 26.2773C22.313 26.559 22.313 27.0171 22.0294 27.2987C21.7457 27.5802 21.2844 27.5802 21.0007 27.2987L18.1514 24.4696C18.0868 23.8384 17.8116 23.2243 17.3245 22.7407C16.8415 22.2611 16.2293 21.9891 15.5993 21.9221C15.5316 21.2964 15.2578 20.6887 14.7748 20.209C14.2924 19.7301 13.6811 19.4584 13.0519 19.3909C12.9839 18.7661 12.7101 18.1592 12.2277 17.6803C11.7424 17.1983 11.1265 16.9257 10.4929 16.8605C10.4271 16.2314 10.1525 15.6199 9.66707 15.1379C9.10565 14.5804 8.36957 14.3017 7.63349 14.3017C6.89742 14.3017 6.16149 14.5804 5.59977 15.1379L3.79181 16.9331L0.0322266 13.4142V14.833L0.084256 16.345L2.28144 18.4327L2.00487 18.7073C0.881724 19.8224 0.881724 21.6303 2.00487 22.7456C2.49032 23.2275 3.10622 23.5002 3.73962 23.5655C3.80546 24.1944 4.08019 24.8059 4.56548 25.2879C5.04786 25.7667 5.65916 26.0385 6.28842 26.106C6.35641 26.7308 6.63006 27.3376 7.11244 27.8165C7.59543 28.296 8.20765 28.5682 8.83783 28.6352C8.90536 29.2609 9.17932 29.8686 9.66231 30.3483C10.2239 30.9059 10.96 31.1846 11.696 31.1846C12.432 31.1846 13.168 30.9059 13.7296 30.3483L17.3245 26.7789C17.3438 26.7599 17.3601 26.739 17.3787 26.7195L19.4815 28.8071C20.6046 29.9222 22.4255 29.9222 23.5488 28.8071C24.0341 28.3251 24.3088 27.7136 24.3745 27.0848C25.008 27.0194 25.6239 26.7468 26.1094 26.2648C26.5916 25.7859 26.8654 25.1791 26.9334 24.5543C27.5627 24.4867 28.174 24.215 28.6562 23.736C29.1393 23.2565 29.4133 22.6486 29.4808 22.023C30.1108 21.9559 30.7231 21.6839 31.2062 21.2044C32.3294 20.0893 32.3294 18.2813 31.2061 17.1661Z\" fill=\"#334047\"></path>\n                <path d=\"M8.44489 10.1967C8.00318 10.5694 7.34062 10.5344 6.94326 10.108C6.5651 9.70225 6.56218 9.08693 6.91472 8.67642L6.91518 8.67703L15.4781 0.812951H12.2841L5.49997 7.03619L5.49367 7.02933C4.20339 8.24807 4.13325 10.2726 5.34649 11.5747C6.51169 12.8251 8.59913 13.0187 9.79656 11.9247L15.48 6.5728L14.0509 5.08632L8.44489 10.1967Z\" fill=\"#334047\"></path>\n                <path d=\"M21.8661 0.813422H18.6849L15.4443 3.89853L23.3682 12.0098L24.1026 9.69754L18.5203 3.94942L21.8661 0.813422Z\" fill=\"#219638\"></path>\n            </g>\n            <defs>\n                <clipPath id=\"clip0_225_175\">\n                    <rect width=\"32\" height=\"32\" fill=\"white\"></rect>\n                </clipPath>\n            </defs>\n        </symbol>\n        <symbol id=\"benefit-6\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" fill=\"none\">\n            <g clip-path=\"url(#clip0_225_197)\">\n                <path d=\"M9.14348 13.7363H9.14075C8.51346 13.7363 8.00488 13.2259 8.00488 12.5964C8.00488 11.9667 8.51346 11.4563 9.14075 11.4563H9.14348C9.77078 11.4563 10.2794 11.9667 10.2794 12.5964C10.2794 13.2259 9.77078 13.7363 9.14348 13.7363Z\" fill=\"#334047\"></path>\n                <path d=\"M16.8847 7.2624C15.5037 7.2624 14.3802 6.13488 14.3802 4.74893C14.3802 3.36283 15.5037 2.2353 16.8847 2.2353C18.2658 2.2353 19.3893 3.36283 19.3893 4.74893C19.3893 6.13488 18.2658 7.2624 16.8847 7.2624ZM30.7393 15.6033C30.7257 15.0556 30.68 14.513 30.6029 13.9777L29.9724 11.408C29.4876 10.029 28.7799 8.72692 27.8611 7.54191C26.1777 5.37138 23.8424 3.72832 21.2578 2.88384C20.5345 1.17765 18.8489 -0.0187836 16.8847 -0.0187836C14.8708 -0.0187836 13.151 1.23948 12.4595 3.0149C11.7079 3.28394 10.9787 3.61529 10.2842 4.01281L9.0158 3.23C8.33316 2.80849 7.49425 2.82298 6.82636 3.26816C6.15864 3.71318 5.8198 4.48359 5.94205 5.27864L6.28121 7.4825C5.05839 9.04796 4.1906 10.8578 3.73657 12.7846H1.18359V20.5166H3.45838L3.51181 15.0387H5.61204L5.76558 14.0928C6.09767 12.0457 6.98247 10.1236 8.32417 8.53403L8.65531 8.14166L8.2324 5.39264L10.2921 6.6641L10.886 6.28139C11.3089 6.00897 11.7489 5.76569 12.2025 5.55187C12.472 7.14567 13.529 8.46947 14.9583 9.10673H12.4714V11.3608H21.6483V9.10673H18.8112C20.2806 8.45144 21.3567 7.07081 21.5879 5.41711C23.3387 6.18575 24.9051 7.40055 26.0885 8.9264C27.6012 10.8773 28.4331 13.2055 28.4939 15.6594C28.4939 15.6605 28.4942 15.6615 28.4942 15.6623V18.2068L28.4714 19.0873L30.7477 17.499L30.7403 15.6033H30.7393Z\" fill=\"#334047\"></path>\n                <path d=\"M23.8911 25.0299H11.4706V25.0835H10.1902V29.5275H5.76206V20.5139H3.36133V29.5275V31.9368V31.9902H5.76206V31.9368H10.1902V31.9706H12.5375V27.3322H23.8911V25.0299Z\" fill=\"#334047\"></path>\n                <path d=\"M23.9005 29.6914H21.6064V26.2072H23.9005V29.6914Z\" fill=\"#334047\"></path>\n                <path d=\"M30.7651 19.5096L28.5011 21.1523L28.3991 29.5887L23.9189 29.6341L23.9366 31.9365H30.73L30.7651 19.5096Z\" fill=\"#219638\"></path>\n            </g>\n            <defs>\n                <clipPath id=\"clip0_225_197\">\n                    <rect width=\"32\" height=\"32\" fill=\"white\"></rect>\n                </clipPath>\n            </defs>\n        </symbol>\n    </svg>    \n</div>\n\n",
  "vacancy_constructor_template": null,
  "key_skills": [],
  "accept_handicapped": false,
  "accept_kids": false,
  "archived": false,
  "response_url": null,
  "specializations": [],
  "professional_roles": [
    {
      "id": "10",
      "name": "Аналитик"
    }
  ],
  "code": null,
  "hidden": false,
  "quick_responses_allowed": false,
  "driver_license_types": [],
  "accept_incomplete_resumes": false,
  "employer": {
    "id": "195398",
    "name": "Негосударственный Пенсионный Фонд Сбербанка",
    "url": "https://api.hh.ru/employers/195398",
    "alternate_url": "https://hh.ru/employer/195398",
    "logo_urls": {
      "original": "https://img.hhcdn.ru/employer-logo-original/1244563.png",
      "90": "https://img.hhcdn.ru/employer-logo/6598681.png",
      "240": "https://img.hhcdn.ru/employer-logo/6598682.png"
    },
    "vacancies_url": "https://api.hh.ru/vacancies?employer_id=195398",
    "accredited_it_employer": false,
    "trusted": true
  },
  "published_at": "2025-06-02T10:56:01+0300",
  "created_at": "2025-06-02T10:56:01+0300",
  "initial_created_at": "2025-06-02T10:56:01+0300",
  "negotiations_url": null,
  "suitable_resumes_url": null,
  "apply_alternate_url": "https://hh.ru/applicant/vacancy_response?vacancyId=121211626",
  "has_test": false,
  "test": null,
  "alternate_url": "https://hh.ru/vacancy/121211626",
  "working_days": [],
  "working_time_intervals": [],
  "working_time_modes": [],
  "accept_temporary": false,
  "languages": [],
  "approved": true,
  "employment_form": {
    "id": "FULL",
    "name": "Полная"
  },
  "fly_in_fly_out_duration": [],
  "internship": false,
  "night_shifts": false,
  "work_format": [],
  "work_schedule_by_days": [
    {
      "id": "FIVE_ON_TWO_OFF",
      "name": "5/2"
    }
  ],
  "working_hours": [
    {
      "id": "HOURS_8",
      "name": "8 часов"
    }
  ],
  "show_logo_in_search": true
}